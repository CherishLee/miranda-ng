// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pmsg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pmsg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pmsg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pmsg_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pmsg_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_pmsg_2eproto;
namespace proto {
class AdReplyInfo;
struct AdReplyInfoDefaultTypeInternal;
extern AdReplyInfoDefaultTypeInternal _AdReplyInfo_default_instance_;
class AppStateFatalExceptionNotification;
struct AppStateFatalExceptionNotificationDefaultTypeInternal;
extern AppStateFatalExceptionNotificationDefaultTypeInternal _AppStateFatalExceptionNotification_default_instance_;
class AppStateSyncKey;
struct AppStateSyncKeyDefaultTypeInternal;
extern AppStateSyncKeyDefaultTypeInternal _AppStateSyncKey_default_instance_;
class AppStateSyncKeyData;
struct AppStateSyncKeyDataDefaultTypeInternal;
extern AppStateSyncKeyDataDefaultTypeInternal _AppStateSyncKeyData_default_instance_;
class AppStateSyncKeyFingerprint;
struct AppStateSyncKeyFingerprintDefaultTypeInternal;
extern AppStateSyncKeyFingerprintDefaultTypeInternal _AppStateSyncKeyFingerprint_default_instance_;
class AppStateSyncKeyId;
struct AppStateSyncKeyIdDefaultTypeInternal;
extern AppStateSyncKeyIdDefaultTypeInternal _AppStateSyncKeyId_default_instance_;
class AppStateSyncKeyRequest;
struct AppStateSyncKeyRequestDefaultTypeInternal;
extern AppStateSyncKeyRequestDefaultTypeInternal _AppStateSyncKeyRequest_default_instance_;
class AppStateSyncKeyShare;
struct AppStateSyncKeyShareDefaultTypeInternal;
extern AppStateSyncKeyShareDefaultTypeInternal _AppStateSyncKeyShare_default_instance_;
class AudioMessage;
struct AudioMessageDefaultTypeInternal;
extern AudioMessageDefaultTypeInternal _AudioMessage_default_instance_;
class Button;
struct ButtonDefaultTypeInternal;
extern ButtonDefaultTypeInternal _Button_default_instance_;
class ButtonText;
struct ButtonTextDefaultTypeInternal;
extern ButtonTextDefaultTypeInternal _ButtonText_default_instance_;
class ButtonsMessage;
struct ButtonsMessageDefaultTypeInternal;
extern ButtonsMessageDefaultTypeInternal _ButtonsMessage_default_instance_;
class ButtonsResponseMessage;
struct ButtonsResponseMessageDefaultTypeInternal;
extern ButtonsResponseMessageDefaultTypeInternal _ButtonsResponseMessage_default_instance_;
class Call;
struct CallDefaultTypeInternal;
extern CallDefaultTypeInternal _Call_default_instance_;
class CallButton;
struct CallButtonDefaultTypeInternal;
extern CallButtonDefaultTypeInternal _CallButton_default_instance_;
class CancelPaymentRequestMessage;
struct CancelPaymentRequestMessageDefaultTypeInternal;
extern CancelPaymentRequestMessageDefaultTypeInternal _CancelPaymentRequestMessage_default_instance_;
class CatalogSnapshot;
struct CatalogSnapshotDefaultTypeInternal;
extern CatalogSnapshotDefaultTypeInternal _CatalogSnapshot_default_instance_;
class Chat;
struct ChatDefaultTypeInternal;
extern ChatDefaultTypeInternal _Chat_default_instance_;
class ContactMessage;
struct ContactMessageDefaultTypeInternal;
extern ContactMessageDefaultTypeInternal _ContactMessage_default_instance_;
class ContactsArrayMessage;
struct ContactsArrayMessageDefaultTypeInternal;
extern ContactsArrayMessageDefaultTypeInternal _ContactsArrayMessage_default_instance_;
class ContextInfo;
struct ContextInfoDefaultTypeInternal;
extern ContextInfoDefaultTypeInternal _ContextInfo_default_instance_;
class DeclinePaymentRequestMessage;
struct DeclinePaymentRequestMessageDefaultTypeInternal;
extern DeclinePaymentRequestMessageDefaultTypeInternal _DeclinePaymentRequestMessage_default_instance_;
class DeviceListMetadata;
struct DeviceListMetadataDefaultTypeInternal;
extern DeviceListMetadataDefaultTypeInternal _DeviceListMetadata_default_instance_;
class DeviceSentMessage;
struct DeviceSentMessageDefaultTypeInternal;
extern DeviceSentMessageDefaultTypeInternal _DeviceSentMessage_default_instance_;
class DocumentMessage;
struct DocumentMessageDefaultTypeInternal;
extern DocumentMessageDefaultTypeInternal _DocumentMessage_default_instance_;
class EphemeralSetting;
struct EphemeralSettingDefaultTypeInternal;
extern EphemeralSettingDefaultTypeInternal _EphemeralSetting_default_instance_;
class ExtendedTextMessage;
struct ExtendedTextMessageDefaultTypeInternal;
extern ExtendedTextMessageDefaultTypeInternal _ExtendedTextMessage_default_instance_;
class ExternalAdReplyInfo;
struct ExternalAdReplyInfoDefaultTypeInternal;
extern ExternalAdReplyInfoDefaultTypeInternal _ExternalAdReplyInfo_default_instance_;
class FourRowTemplate;
struct FourRowTemplateDefaultTypeInternal;
extern FourRowTemplateDefaultTypeInternal _FourRowTemplate_default_instance_;
class FutureProofMessage;
struct FutureProofMessageDefaultTypeInternal;
extern FutureProofMessageDefaultTypeInternal _FutureProofMessage_default_instance_;
class GroupInviteMessage;
struct GroupInviteMessageDefaultTypeInternal;
extern GroupInviteMessageDefaultTypeInternal _GroupInviteMessage_default_instance_;
class HSMCurrency;
struct HSMCurrencyDefaultTypeInternal;
extern HSMCurrencyDefaultTypeInternal _HSMCurrency_default_instance_;
class HSMDateTime;
struct HSMDateTimeDefaultTypeInternal;
extern HSMDateTimeDefaultTypeInternal _HSMDateTime_default_instance_;
class HSMDateTimeComponent;
struct HSMDateTimeComponentDefaultTypeInternal;
extern HSMDateTimeComponentDefaultTypeInternal _HSMDateTimeComponent_default_instance_;
class HSMDateTimeUnixEpoch;
struct HSMDateTimeUnixEpochDefaultTypeInternal;
extern HSMDateTimeUnixEpochDefaultTypeInternal _HSMDateTimeUnixEpoch_default_instance_;
class HSMLocalizableParameter;
struct HSMLocalizableParameterDefaultTypeInternal;
extern HSMLocalizableParameterDefaultTypeInternal _HSMLocalizableParameter_default_instance_;
class HighlyStructuredMessage;
struct HighlyStructuredMessageDefaultTypeInternal;
extern HighlyStructuredMessageDefaultTypeInternal _HighlyStructuredMessage_default_instance_;
class HistorySyncNotification;
struct HistorySyncNotificationDefaultTypeInternal;
extern HistorySyncNotificationDefaultTypeInternal _HistorySyncNotification_default_instance_;
class HydratedCallButton;
struct HydratedCallButtonDefaultTypeInternal;
extern HydratedCallButtonDefaultTypeInternal _HydratedCallButton_default_instance_;
class HydratedFourRowTemplate;
struct HydratedFourRowTemplateDefaultTypeInternal;
extern HydratedFourRowTemplateDefaultTypeInternal _HydratedFourRowTemplate_default_instance_;
class HydratedQuickReplyButton;
struct HydratedQuickReplyButtonDefaultTypeInternal;
extern HydratedQuickReplyButtonDefaultTypeInternal _HydratedQuickReplyButton_default_instance_;
class HydratedTemplateButton;
struct HydratedTemplateButtonDefaultTypeInternal;
extern HydratedTemplateButtonDefaultTypeInternal _HydratedTemplateButton_default_instance_;
class HydratedURLButton;
struct HydratedURLButtonDefaultTypeInternal;
extern HydratedURLButtonDefaultTypeInternal _HydratedURLButton_default_instance_;
class ImageMessage;
struct ImageMessageDefaultTypeInternal;
extern ImageMessageDefaultTypeInternal _ImageMessage_default_instance_;
class InitialSecurityNotificationSettingSync;
struct InitialSecurityNotificationSettingSyncDefaultTypeInternal;
extern InitialSecurityNotificationSettingSyncDefaultTypeInternal _InitialSecurityNotificationSettingSync_default_instance_;
class InteractiveAnnotation;
struct InteractiveAnnotationDefaultTypeInternal;
extern InteractiveAnnotationDefaultTypeInternal _InteractiveAnnotation_default_instance_;
class InvoiceMessage;
struct InvoiceMessageDefaultTypeInternal;
extern InvoiceMessageDefaultTypeInternal _InvoiceMessage_default_instance_;
class ListMessage;
struct ListMessageDefaultTypeInternal;
extern ListMessageDefaultTypeInternal _ListMessage_default_instance_;
class ListResponseMessage;
struct ListResponseMessageDefaultTypeInternal;
extern ListResponseMessageDefaultTypeInternal _ListResponseMessage_default_instance_;
class LiveLocationMessage;
struct LiveLocationMessageDefaultTypeInternal;
extern LiveLocationMessageDefaultTypeInternal _LiveLocationMessage_default_instance_;
class Location;
struct LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class LocationMessage;
struct LocationMessageDefaultTypeInternal;
extern LocationMessageDefaultTypeInternal _LocationMessage_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class MessageContextInfo;
struct MessageContextInfoDefaultTypeInternal;
extern MessageContextInfoDefaultTypeInternal _MessageContextInfo_default_instance_;
class MessageKey;
struct MessageKeyDefaultTypeInternal;
extern MessageKeyDefaultTypeInternal _MessageKey_default_instance_;
class NotificationMessageInfo;
struct NotificationMessageInfoDefaultTypeInternal;
extern NotificationMessageInfoDefaultTypeInternal _NotificationMessageInfo_default_instance_;
class OrderMessage;
struct OrderMessageDefaultTypeInternal;
extern OrderMessageDefaultTypeInternal _OrderMessage_default_instance_;
class PaymentInfo;
struct PaymentInfoDefaultTypeInternal;
extern PaymentInfoDefaultTypeInternal _PaymentInfo_default_instance_;
class PaymentMoney;
struct PaymentMoneyDefaultTypeInternal;
extern PaymentMoneyDefaultTypeInternal _PaymentMoney_default_instance_;
class Point;
struct PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class ProductMessage;
struct ProductMessageDefaultTypeInternal;
extern ProductMessageDefaultTypeInternal _ProductMessage_default_instance_;
class ProductSnapshot;
struct ProductSnapshotDefaultTypeInternal;
extern ProductSnapshotDefaultTypeInternal _ProductSnapshot_default_instance_;
class ProtocolMessage;
struct ProtocolMessageDefaultTypeInternal;
extern ProtocolMessageDefaultTypeInternal _ProtocolMessage_default_instance_;
class QuickReplyButton;
struct QuickReplyButtonDefaultTypeInternal;
extern QuickReplyButtonDefaultTypeInternal _QuickReplyButton_default_instance_;
class RequestPaymentMessage;
struct RequestPaymentMessageDefaultTypeInternal;
extern RequestPaymentMessageDefaultTypeInternal _RequestPaymentMessage_default_instance_;
class Row;
struct RowDefaultTypeInternal;
extern RowDefaultTypeInternal _Row_default_instance_;
class Section;
struct SectionDefaultTypeInternal;
extern SectionDefaultTypeInternal _Section_default_instance_;
class SendPaymentMessage;
struct SendPaymentMessageDefaultTypeInternal;
extern SendPaymentMessageDefaultTypeInternal _SendPaymentMessage_default_instance_;
class SenderKeyDistributionMessage;
struct SenderKeyDistributionMessageDefaultTypeInternal;
extern SenderKeyDistributionMessageDefaultTypeInternal _SenderKeyDistributionMessage_default_instance_;
class SingleSelectReply;
struct SingleSelectReplyDefaultTypeInternal;
extern SingleSelectReplyDefaultTypeInternal _SingleSelectReply_default_instance_;
class StickerMessage;
struct StickerMessageDefaultTypeInternal;
extern StickerMessageDefaultTypeInternal _StickerMessage_default_instance_;
class TemplateButton;
struct TemplateButtonDefaultTypeInternal;
extern TemplateButtonDefaultTypeInternal _TemplateButton_default_instance_;
class TemplateButtonReplyMessage;
struct TemplateButtonReplyMessageDefaultTypeInternal;
extern TemplateButtonReplyMessageDefaultTypeInternal _TemplateButtonReplyMessage_default_instance_;
class TemplateMessage;
struct TemplateMessageDefaultTypeInternal;
extern TemplateMessageDefaultTypeInternal _TemplateMessage_default_instance_;
class URLButton;
struct URLButtonDefaultTypeInternal;
extern URLButtonDefaultTypeInternal _URLButton_default_instance_;
class VideoMessage;
struct VideoMessageDefaultTypeInternal;
extern VideoMessageDefaultTypeInternal _VideoMessage_default_instance_;
class WebFeatures;
struct WebFeaturesDefaultTypeInternal;
extern WebFeaturesDefaultTypeInternal _WebFeatures_default_instance_;
class WebMessageInfo;
struct WebMessageInfoDefaultTypeInternal;
extern WebMessageInfoDefaultTypeInternal _WebMessageInfo_default_instance_;
class WebNotificationsInfo;
struct WebNotificationsInfoDefaultTypeInternal;
extern WebNotificationsInfoDefaultTypeInternal _WebNotificationsInfo_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::AdReplyInfo* Arena::CreateMaybeMessage<::proto::AdReplyInfo>(Arena*);
template<> ::proto::AppStateFatalExceptionNotification* Arena::CreateMaybeMessage<::proto::AppStateFatalExceptionNotification>(Arena*);
template<> ::proto::AppStateSyncKey* Arena::CreateMaybeMessage<::proto::AppStateSyncKey>(Arena*);
template<> ::proto::AppStateSyncKeyData* Arena::CreateMaybeMessage<::proto::AppStateSyncKeyData>(Arena*);
template<> ::proto::AppStateSyncKeyFingerprint* Arena::CreateMaybeMessage<::proto::AppStateSyncKeyFingerprint>(Arena*);
template<> ::proto::AppStateSyncKeyId* Arena::CreateMaybeMessage<::proto::AppStateSyncKeyId>(Arena*);
template<> ::proto::AppStateSyncKeyRequest* Arena::CreateMaybeMessage<::proto::AppStateSyncKeyRequest>(Arena*);
template<> ::proto::AppStateSyncKeyShare* Arena::CreateMaybeMessage<::proto::AppStateSyncKeyShare>(Arena*);
template<> ::proto::AudioMessage* Arena::CreateMaybeMessage<::proto::AudioMessage>(Arena*);
template<> ::proto::Button* Arena::CreateMaybeMessage<::proto::Button>(Arena*);
template<> ::proto::ButtonText* Arena::CreateMaybeMessage<::proto::ButtonText>(Arena*);
template<> ::proto::ButtonsMessage* Arena::CreateMaybeMessage<::proto::ButtonsMessage>(Arena*);
template<> ::proto::ButtonsResponseMessage* Arena::CreateMaybeMessage<::proto::ButtonsResponseMessage>(Arena*);
template<> ::proto::Call* Arena::CreateMaybeMessage<::proto::Call>(Arena*);
template<> ::proto::CallButton* Arena::CreateMaybeMessage<::proto::CallButton>(Arena*);
template<> ::proto::CancelPaymentRequestMessage* Arena::CreateMaybeMessage<::proto::CancelPaymentRequestMessage>(Arena*);
template<> ::proto::CatalogSnapshot* Arena::CreateMaybeMessage<::proto::CatalogSnapshot>(Arena*);
template<> ::proto::Chat* Arena::CreateMaybeMessage<::proto::Chat>(Arena*);
template<> ::proto::ContactMessage* Arena::CreateMaybeMessage<::proto::ContactMessage>(Arena*);
template<> ::proto::ContactsArrayMessage* Arena::CreateMaybeMessage<::proto::ContactsArrayMessage>(Arena*);
template<> ::proto::ContextInfo* Arena::CreateMaybeMessage<::proto::ContextInfo>(Arena*);
template<> ::proto::DeclinePaymentRequestMessage* Arena::CreateMaybeMessage<::proto::DeclinePaymentRequestMessage>(Arena*);
template<> ::proto::DeviceListMetadata* Arena::CreateMaybeMessage<::proto::DeviceListMetadata>(Arena*);
template<> ::proto::DeviceSentMessage* Arena::CreateMaybeMessage<::proto::DeviceSentMessage>(Arena*);
template<> ::proto::DocumentMessage* Arena::CreateMaybeMessage<::proto::DocumentMessage>(Arena*);
template<> ::proto::EphemeralSetting* Arena::CreateMaybeMessage<::proto::EphemeralSetting>(Arena*);
template<> ::proto::ExtendedTextMessage* Arena::CreateMaybeMessage<::proto::ExtendedTextMessage>(Arena*);
template<> ::proto::ExternalAdReplyInfo* Arena::CreateMaybeMessage<::proto::ExternalAdReplyInfo>(Arena*);
template<> ::proto::FourRowTemplate* Arena::CreateMaybeMessage<::proto::FourRowTemplate>(Arena*);
template<> ::proto::FutureProofMessage* Arena::CreateMaybeMessage<::proto::FutureProofMessage>(Arena*);
template<> ::proto::GroupInviteMessage* Arena::CreateMaybeMessage<::proto::GroupInviteMessage>(Arena*);
template<> ::proto::HSMCurrency* Arena::CreateMaybeMessage<::proto::HSMCurrency>(Arena*);
template<> ::proto::HSMDateTime* Arena::CreateMaybeMessage<::proto::HSMDateTime>(Arena*);
template<> ::proto::HSMDateTimeComponent* Arena::CreateMaybeMessage<::proto::HSMDateTimeComponent>(Arena*);
template<> ::proto::HSMDateTimeUnixEpoch* Arena::CreateMaybeMessage<::proto::HSMDateTimeUnixEpoch>(Arena*);
template<> ::proto::HSMLocalizableParameter* Arena::CreateMaybeMessage<::proto::HSMLocalizableParameter>(Arena*);
template<> ::proto::HighlyStructuredMessage* Arena::CreateMaybeMessage<::proto::HighlyStructuredMessage>(Arena*);
template<> ::proto::HistorySyncNotification* Arena::CreateMaybeMessage<::proto::HistorySyncNotification>(Arena*);
template<> ::proto::HydratedCallButton* Arena::CreateMaybeMessage<::proto::HydratedCallButton>(Arena*);
template<> ::proto::HydratedFourRowTemplate* Arena::CreateMaybeMessage<::proto::HydratedFourRowTemplate>(Arena*);
template<> ::proto::HydratedQuickReplyButton* Arena::CreateMaybeMessage<::proto::HydratedQuickReplyButton>(Arena*);
template<> ::proto::HydratedTemplateButton* Arena::CreateMaybeMessage<::proto::HydratedTemplateButton>(Arena*);
template<> ::proto::HydratedURLButton* Arena::CreateMaybeMessage<::proto::HydratedURLButton>(Arena*);
template<> ::proto::ImageMessage* Arena::CreateMaybeMessage<::proto::ImageMessage>(Arena*);
template<> ::proto::InitialSecurityNotificationSettingSync* Arena::CreateMaybeMessage<::proto::InitialSecurityNotificationSettingSync>(Arena*);
template<> ::proto::InteractiveAnnotation* Arena::CreateMaybeMessage<::proto::InteractiveAnnotation>(Arena*);
template<> ::proto::InvoiceMessage* Arena::CreateMaybeMessage<::proto::InvoiceMessage>(Arena*);
template<> ::proto::ListMessage* Arena::CreateMaybeMessage<::proto::ListMessage>(Arena*);
template<> ::proto::ListResponseMessage* Arena::CreateMaybeMessage<::proto::ListResponseMessage>(Arena*);
template<> ::proto::LiveLocationMessage* Arena::CreateMaybeMessage<::proto::LiveLocationMessage>(Arena*);
template<> ::proto::Location* Arena::CreateMaybeMessage<::proto::Location>(Arena*);
template<> ::proto::LocationMessage* Arena::CreateMaybeMessage<::proto::LocationMessage>(Arena*);
template<> ::proto::Message* Arena::CreateMaybeMessage<::proto::Message>(Arena*);
template<> ::proto::MessageContextInfo* Arena::CreateMaybeMessage<::proto::MessageContextInfo>(Arena*);
template<> ::proto::MessageKey* Arena::CreateMaybeMessage<::proto::MessageKey>(Arena*);
template<> ::proto::NotificationMessageInfo* Arena::CreateMaybeMessage<::proto::NotificationMessageInfo>(Arena*);
template<> ::proto::OrderMessage* Arena::CreateMaybeMessage<::proto::OrderMessage>(Arena*);
template<> ::proto::PaymentInfo* Arena::CreateMaybeMessage<::proto::PaymentInfo>(Arena*);
template<> ::proto::PaymentMoney* Arena::CreateMaybeMessage<::proto::PaymentMoney>(Arena*);
template<> ::proto::Point* Arena::CreateMaybeMessage<::proto::Point>(Arena*);
template<> ::proto::ProductMessage* Arena::CreateMaybeMessage<::proto::ProductMessage>(Arena*);
template<> ::proto::ProductSnapshot* Arena::CreateMaybeMessage<::proto::ProductSnapshot>(Arena*);
template<> ::proto::ProtocolMessage* Arena::CreateMaybeMessage<::proto::ProtocolMessage>(Arena*);
template<> ::proto::QuickReplyButton* Arena::CreateMaybeMessage<::proto::QuickReplyButton>(Arena*);
template<> ::proto::RequestPaymentMessage* Arena::CreateMaybeMessage<::proto::RequestPaymentMessage>(Arena*);
template<> ::proto::Row* Arena::CreateMaybeMessage<::proto::Row>(Arena*);
template<> ::proto::Section* Arena::CreateMaybeMessage<::proto::Section>(Arena*);
template<> ::proto::SendPaymentMessage* Arena::CreateMaybeMessage<::proto::SendPaymentMessage>(Arena*);
template<> ::proto::SenderKeyDistributionMessage* Arena::CreateMaybeMessage<::proto::SenderKeyDistributionMessage>(Arena*);
template<> ::proto::SingleSelectReply* Arena::CreateMaybeMessage<::proto::SingleSelectReply>(Arena*);
template<> ::proto::StickerMessage* Arena::CreateMaybeMessage<::proto::StickerMessage>(Arena*);
template<> ::proto::TemplateButton* Arena::CreateMaybeMessage<::proto::TemplateButton>(Arena*);
template<> ::proto::TemplateButtonReplyMessage* Arena::CreateMaybeMessage<::proto::TemplateButtonReplyMessage>(Arena*);
template<> ::proto::TemplateMessage* Arena::CreateMaybeMessage<::proto::TemplateMessage>(Arena*);
template<> ::proto::URLButton* Arena::CreateMaybeMessage<::proto::URLButton>(Arena*);
template<> ::proto::VideoMessage* Arena::CreateMaybeMessage<::proto::VideoMessage>(Arena*);
template<> ::proto::WebFeatures* Arena::CreateMaybeMessage<::proto::WebFeatures>(Arena*);
template<> ::proto::WebMessageInfo* Arena::CreateMaybeMessage<::proto::WebMessageInfo>(Arena*);
template<> ::proto::WebNotificationsInfo* Arena::CreateMaybeMessage<::proto::WebNotificationsInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

enum AdReplyInfo_AdReplyInfoMediaType : int {
  AdReplyInfo_AdReplyInfoMediaType_NONE = 0,
  AdReplyInfo_AdReplyInfoMediaType_IMAGE = 1,
  AdReplyInfo_AdReplyInfoMediaType_VIDEO = 2
};
bool AdReplyInfo_AdReplyInfoMediaType_IsValid(int value);
constexpr AdReplyInfo_AdReplyInfoMediaType AdReplyInfo_AdReplyInfoMediaType_AdReplyInfoMediaType_MIN = AdReplyInfo_AdReplyInfoMediaType_NONE;
constexpr AdReplyInfo_AdReplyInfoMediaType AdReplyInfo_AdReplyInfoMediaType_AdReplyInfoMediaType_MAX = AdReplyInfo_AdReplyInfoMediaType_VIDEO;
constexpr int AdReplyInfo_AdReplyInfoMediaType_AdReplyInfoMediaType_ARRAYSIZE = AdReplyInfo_AdReplyInfoMediaType_AdReplyInfoMediaType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AdReplyInfo_AdReplyInfoMediaType_descriptor();
template<typename T>
inline const std::string& AdReplyInfo_AdReplyInfoMediaType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AdReplyInfo_AdReplyInfoMediaType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AdReplyInfo_AdReplyInfoMediaType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AdReplyInfo_AdReplyInfoMediaType_descriptor(), enum_t_value);
}
inline bool AdReplyInfo_AdReplyInfoMediaType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AdReplyInfo_AdReplyInfoMediaType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AdReplyInfo_AdReplyInfoMediaType>(
    AdReplyInfo_AdReplyInfoMediaType_descriptor(), name, value);
}
enum ExternalAdReplyInfo_ExternalAdReplyInfoMediaType : int {
  ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_NONE = 0,
  ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_IMAGE = 1,
  ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_VIDEO = 2
};
bool ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_IsValid(int value);
constexpr ExternalAdReplyInfo_ExternalAdReplyInfoMediaType ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_ExternalAdReplyInfoMediaType_MIN = ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_NONE;
constexpr ExternalAdReplyInfo_ExternalAdReplyInfoMediaType ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_ExternalAdReplyInfoMediaType_MAX = ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_VIDEO;
constexpr int ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_ExternalAdReplyInfoMediaType_ARRAYSIZE = ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_ExternalAdReplyInfoMediaType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_descriptor();
template<typename T>
inline const std::string& ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExternalAdReplyInfo_ExternalAdReplyInfoMediaType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_descriptor(), enum_t_value);
}
inline bool ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExternalAdReplyInfo_ExternalAdReplyInfoMediaType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExternalAdReplyInfo_ExternalAdReplyInfoMediaType>(
    ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_descriptor(), name, value);
}
enum InvoiceMessage_InvoiceMessageAttachmentType : int {
  InvoiceMessage_InvoiceMessageAttachmentType_IMAGE = 0,
  InvoiceMessage_InvoiceMessageAttachmentType_PDF = 1
};
bool InvoiceMessage_InvoiceMessageAttachmentType_IsValid(int value);
constexpr InvoiceMessage_InvoiceMessageAttachmentType InvoiceMessage_InvoiceMessageAttachmentType_InvoiceMessageAttachmentType_MIN = InvoiceMessage_InvoiceMessageAttachmentType_IMAGE;
constexpr InvoiceMessage_InvoiceMessageAttachmentType InvoiceMessage_InvoiceMessageAttachmentType_InvoiceMessageAttachmentType_MAX = InvoiceMessage_InvoiceMessageAttachmentType_PDF;
constexpr int InvoiceMessage_InvoiceMessageAttachmentType_InvoiceMessageAttachmentType_ARRAYSIZE = InvoiceMessage_InvoiceMessageAttachmentType_InvoiceMessageAttachmentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InvoiceMessage_InvoiceMessageAttachmentType_descriptor();
template<typename T>
inline const std::string& InvoiceMessage_InvoiceMessageAttachmentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InvoiceMessage_InvoiceMessageAttachmentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InvoiceMessage_InvoiceMessageAttachmentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InvoiceMessage_InvoiceMessageAttachmentType_descriptor(), enum_t_value);
}
inline bool InvoiceMessage_InvoiceMessageAttachmentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InvoiceMessage_InvoiceMessageAttachmentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InvoiceMessage_InvoiceMessageAttachmentType>(
    InvoiceMessage_InvoiceMessageAttachmentType_descriptor(), name, value);
}
enum ExtendedTextMessage_ExtendedTextMessageFontType : int {
  ExtendedTextMessage_ExtendedTextMessageFontType_SANS_SERIF = 0,
  ExtendedTextMessage_ExtendedTextMessageFontType_SERIF = 1,
  ExtendedTextMessage_ExtendedTextMessageFontType_NORICAN_REGULAR = 2,
  ExtendedTextMessage_ExtendedTextMessageFontType_BRYNDAN_WRITE = 3,
  ExtendedTextMessage_ExtendedTextMessageFontType_BEBASNEUE_REGULAR = 4,
  ExtendedTextMessage_ExtendedTextMessageFontType_OSWALD_HEAVY = 5
};
bool ExtendedTextMessage_ExtendedTextMessageFontType_IsValid(int value);
constexpr ExtendedTextMessage_ExtendedTextMessageFontType ExtendedTextMessage_ExtendedTextMessageFontType_ExtendedTextMessageFontType_MIN = ExtendedTextMessage_ExtendedTextMessageFontType_SANS_SERIF;
constexpr ExtendedTextMessage_ExtendedTextMessageFontType ExtendedTextMessage_ExtendedTextMessageFontType_ExtendedTextMessageFontType_MAX = ExtendedTextMessage_ExtendedTextMessageFontType_OSWALD_HEAVY;
constexpr int ExtendedTextMessage_ExtendedTextMessageFontType_ExtendedTextMessageFontType_ARRAYSIZE = ExtendedTextMessage_ExtendedTextMessageFontType_ExtendedTextMessageFontType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExtendedTextMessage_ExtendedTextMessageFontType_descriptor();
template<typename T>
inline const std::string& ExtendedTextMessage_ExtendedTextMessageFontType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtendedTextMessage_ExtendedTextMessageFontType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtendedTextMessage_ExtendedTextMessageFontType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExtendedTextMessage_ExtendedTextMessageFontType_descriptor(), enum_t_value);
}
inline bool ExtendedTextMessage_ExtendedTextMessageFontType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtendedTextMessage_ExtendedTextMessageFontType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExtendedTextMessage_ExtendedTextMessageFontType>(
    ExtendedTextMessage_ExtendedTextMessageFontType_descriptor(), name, value);
}
enum ExtendedTextMessage_ExtendedTextMessagePreviewType : int {
  ExtendedTextMessage_ExtendedTextMessagePreviewType_NONE = 0,
  ExtendedTextMessage_ExtendedTextMessagePreviewType_VIDEO = 1
};
bool ExtendedTextMessage_ExtendedTextMessagePreviewType_IsValid(int value);
constexpr ExtendedTextMessage_ExtendedTextMessagePreviewType ExtendedTextMessage_ExtendedTextMessagePreviewType_ExtendedTextMessagePreviewType_MIN = ExtendedTextMessage_ExtendedTextMessagePreviewType_NONE;
constexpr ExtendedTextMessage_ExtendedTextMessagePreviewType ExtendedTextMessage_ExtendedTextMessagePreviewType_ExtendedTextMessagePreviewType_MAX = ExtendedTextMessage_ExtendedTextMessagePreviewType_VIDEO;
constexpr int ExtendedTextMessage_ExtendedTextMessagePreviewType_ExtendedTextMessagePreviewType_ARRAYSIZE = ExtendedTextMessage_ExtendedTextMessagePreviewType_ExtendedTextMessagePreviewType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExtendedTextMessage_ExtendedTextMessagePreviewType_descriptor();
template<typename T>
inline const std::string& ExtendedTextMessage_ExtendedTextMessagePreviewType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtendedTextMessage_ExtendedTextMessagePreviewType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtendedTextMessage_ExtendedTextMessagePreviewType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExtendedTextMessage_ExtendedTextMessagePreviewType_descriptor(), enum_t_value);
}
inline bool ExtendedTextMessage_ExtendedTextMessagePreviewType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtendedTextMessage_ExtendedTextMessagePreviewType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExtendedTextMessage_ExtendedTextMessagePreviewType>(
    ExtendedTextMessage_ExtendedTextMessagePreviewType_descriptor(), name, value);
}
enum VideoMessage_VideoMessageAttribution : int {
  VideoMessage_VideoMessageAttribution_NONE = 0,
  VideoMessage_VideoMessageAttribution_GIPHY = 1,
  VideoMessage_VideoMessageAttribution_TENOR = 2
};
bool VideoMessage_VideoMessageAttribution_IsValid(int value);
constexpr VideoMessage_VideoMessageAttribution VideoMessage_VideoMessageAttribution_VideoMessageAttribution_MIN = VideoMessage_VideoMessageAttribution_NONE;
constexpr VideoMessage_VideoMessageAttribution VideoMessage_VideoMessageAttribution_VideoMessageAttribution_MAX = VideoMessage_VideoMessageAttribution_TENOR;
constexpr int VideoMessage_VideoMessageAttribution_VideoMessageAttribution_ARRAYSIZE = VideoMessage_VideoMessageAttribution_VideoMessageAttribution_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VideoMessage_VideoMessageAttribution_descriptor();
template<typename T>
inline const std::string& VideoMessage_VideoMessageAttribution_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoMessage_VideoMessageAttribution>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoMessage_VideoMessageAttribution_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VideoMessage_VideoMessageAttribution_descriptor(), enum_t_value);
}
inline bool VideoMessage_VideoMessageAttribution_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoMessage_VideoMessageAttribution* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VideoMessage_VideoMessageAttribution>(
    VideoMessage_VideoMessageAttribution_descriptor(), name, value);
}
enum ProtocolMessage_ProtocolMessageType : int {
  ProtocolMessage_ProtocolMessageType_REVOKE = 0,
  ProtocolMessage_ProtocolMessageType_EPHEMERAL_SETTING = 3,
  ProtocolMessage_ProtocolMessageType_EPHEMERAL_SYNC_RESPONSE = 4,
  ProtocolMessage_ProtocolMessageType_HISTORY_SYNC_NOTIFICATION = 5,
  ProtocolMessage_ProtocolMessageType_APP_STATE_SYNC_KEY_SHARE = 6,
  ProtocolMessage_ProtocolMessageType_APP_STATE_SYNC_KEY_REQUEST = 7,
  ProtocolMessage_ProtocolMessageType_MSG_FANOUT_BACKFILL_REQUEST = 8,
  ProtocolMessage_ProtocolMessageType_INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC = 9,
  ProtocolMessage_ProtocolMessageType_APP_STATE_FATAL_EXCEPTION_NOTIFICATION = 10
};
bool ProtocolMessage_ProtocolMessageType_IsValid(int value);
constexpr ProtocolMessage_ProtocolMessageType ProtocolMessage_ProtocolMessageType_ProtocolMessageType_MIN = ProtocolMessage_ProtocolMessageType_REVOKE;
constexpr ProtocolMessage_ProtocolMessageType ProtocolMessage_ProtocolMessageType_ProtocolMessageType_MAX = ProtocolMessage_ProtocolMessageType_APP_STATE_FATAL_EXCEPTION_NOTIFICATION;
constexpr int ProtocolMessage_ProtocolMessageType_ProtocolMessageType_ARRAYSIZE = ProtocolMessage_ProtocolMessageType_ProtocolMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProtocolMessage_ProtocolMessageType_descriptor();
template<typename T>
inline const std::string& ProtocolMessage_ProtocolMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProtocolMessage_ProtocolMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProtocolMessage_ProtocolMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProtocolMessage_ProtocolMessageType_descriptor(), enum_t_value);
}
inline bool ProtocolMessage_ProtocolMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProtocolMessage_ProtocolMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProtocolMessage_ProtocolMessageType>(
    ProtocolMessage_ProtocolMessageType_descriptor(), name, value);
}
enum HistorySyncNotification_HistorySyncNotificationHistorySyncType : int {
  HistorySyncNotification_HistorySyncNotificationHistorySyncType_INITIAL_BOOTSTRAP = 0,
  HistorySyncNotification_HistorySyncNotificationHistorySyncType_INITIAL_STATUS_V3 = 1,
  HistorySyncNotification_HistorySyncNotificationHistorySyncType_FULL = 2,
  HistorySyncNotification_HistorySyncNotificationHistorySyncType_RECENT = 3,
  HistorySyncNotification_HistorySyncNotificationHistorySyncType_PUSH_NAME = 4
};
bool HistorySyncNotification_HistorySyncNotificationHistorySyncType_IsValid(int value);
constexpr HistorySyncNotification_HistorySyncNotificationHistorySyncType HistorySyncNotification_HistorySyncNotificationHistorySyncType_HistorySyncNotificationHistorySyncType_MIN = HistorySyncNotification_HistorySyncNotificationHistorySyncType_INITIAL_BOOTSTRAP;
constexpr HistorySyncNotification_HistorySyncNotificationHistorySyncType HistorySyncNotification_HistorySyncNotificationHistorySyncType_HistorySyncNotificationHistorySyncType_MAX = HistorySyncNotification_HistorySyncNotificationHistorySyncType_PUSH_NAME;
constexpr int HistorySyncNotification_HistorySyncNotificationHistorySyncType_HistorySyncNotificationHistorySyncType_ARRAYSIZE = HistorySyncNotification_HistorySyncNotificationHistorySyncType_HistorySyncNotificationHistorySyncType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HistorySyncNotification_HistorySyncNotificationHistorySyncType_descriptor();
template<typename T>
inline const std::string& HistorySyncNotification_HistorySyncNotificationHistorySyncType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HistorySyncNotification_HistorySyncNotificationHistorySyncType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HistorySyncNotification_HistorySyncNotificationHistorySyncType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HistorySyncNotification_HistorySyncNotificationHistorySyncType_descriptor(), enum_t_value);
}
inline bool HistorySyncNotification_HistorySyncNotificationHistorySyncType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HistorySyncNotification_HistorySyncNotificationHistorySyncType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HistorySyncNotification_HistorySyncNotificationHistorySyncType>(
    HistorySyncNotification_HistorySyncNotificationHistorySyncType_descriptor(), name, value);
}
enum HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType : int {
  HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_MONDAY = 1,
  HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_TUESDAY = 2,
  HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_WEDNESDAY = 3,
  HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_THURSDAY = 4,
  HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_FRIDAY = 5,
  HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_SATURDAY = 6,
  HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_SUNDAY = 7
};
bool HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_IsValid(int value);
constexpr HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_HSMDateTimeComponentDayOfWeekType_MIN = HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_MONDAY;
constexpr HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_HSMDateTimeComponentDayOfWeekType_MAX = HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_SUNDAY;
constexpr int HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_HSMDateTimeComponentDayOfWeekType_ARRAYSIZE = HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_HSMDateTimeComponentDayOfWeekType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_descriptor();
template<typename T>
inline const std::string& HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_descriptor(), enum_t_value);
}
inline bool HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType>(
    HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_descriptor(), name, value);
}
enum HSMDateTimeComponent_HSMDateTimeComponentCalendarType : int {
  HSMDateTimeComponent_HSMDateTimeComponentCalendarType_GREGORIAN = 1,
  HSMDateTimeComponent_HSMDateTimeComponentCalendarType_SOLAR_HIJRI = 2
};
bool HSMDateTimeComponent_HSMDateTimeComponentCalendarType_IsValid(int value);
constexpr HSMDateTimeComponent_HSMDateTimeComponentCalendarType HSMDateTimeComponent_HSMDateTimeComponentCalendarType_HSMDateTimeComponentCalendarType_MIN = HSMDateTimeComponent_HSMDateTimeComponentCalendarType_GREGORIAN;
constexpr HSMDateTimeComponent_HSMDateTimeComponentCalendarType HSMDateTimeComponent_HSMDateTimeComponentCalendarType_HSMDateTimeComponentCalendarType_MAX = HSMDateTimeComponent_HSMDateTimeComponentCalendarType_SOLAR_HIJRI;
constexpr int HSMDateTimeComponent_HSMDateTimeComponentCalendarType_HSMDateTimeComponentCalendarType_ARRAYSIZE = HSMDateTimeComponent_HSMDateTimeComponentCalendarType_HSMDateTimeComponentCalendarType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HSMDateTimeComponent_HSMDateTimeComponentCalendarType_descriptor();
template<typename T>
inline const std::string& HSMDateTimeComponent_HSMDateTimeComponentCalendarType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HSMDateTimeComponent_HSMDateTimeComponentCalendarType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HSMDateTimeComponent_HSMDateTimeComponentCalendarType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HSMDateTimeComponent_HSMDateTimeComponentCalendarType_descriptor(), enum_t_value);
}
inline bool HSMDateTimeComponent_HSMDateTimeComponentCalendarType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HSMDateTimeComponent_HSMDateTimeComponentCalendarType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HSMDateTimeComponent_HSMDateTimeComponentCalendarType>(
    HSMDateTimeComponent_HSMDateTimeComponentCalendarType_descriptor(), name, value);
}
enum OrderMessage_OrderMessageOrderStatus : int {
  OrderMessage_OrderMessageOrderStatus_INQUIRY = 1
};
bool OrderMessage_OrderMessageOrderStatus_IsValid(int value);
constexpr OrderMessage_OrderMessageOrderStatus OrderMessage_OrderMessageOrderStatus_OrderMessageOrderStatus_MIN = OrderMessage_OrderMessageOrderStatus_INQUIRY;
constexpr OrderMessage_OrderMessageOrderStatus OrderMessage_OrderMessageOrderStatus_OrderMessageOrderStatus_MAX = OrderMessage_OrderMessageOrderStatus_INQUIRY;
constexpr int OrderMessage_OrderMessageOrderStatus_OrderMessageOrderStatus_ARRAYSIZE = OrderMessage_OrderMessageOrderStatus_OrderMessageOrderStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderMessage_OrderMessageOrderStatus_descriptor();
template<typename T>
inline const std::string& OrderMessage_OrderMessageOrderStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OrderMessage_OrderMessageOrderStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OrderMessage_OrderMessageOrderStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OrderMessage_OrderMessageOrderStatus_descriptor(), enum_t_value);
}
inline bool OrderMessage_OrderMessageOrderStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OrderMessage_OrderMessageOrderStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderMessage_OrderMessageOrderStatus>(
    OrderMessage_OrderMessageOrderStatus_descriptor(), name, value);
}
enum OrderMessage_OrderMessageOrderSurface : int {
  OrderMessage_OrderMessageOrderSurface_CATALOG = 1
};
bool OrderMessage_OrderMessageOrderSurface_IsValid(int value);
constexpr OrderMessage_OrderMessageOrderSurface OrderMessage_OrderMessageOrderSurface_OrderMessageOrderSurface_MIN = OrderMessage_OrderMessageOrderSurface_CATALOG;
constexpr OrderMessage_OrderMessageOrderSurface OrderMessage_OrderMessageOrderSurface_OrderMessageOrderSurface_MAX = OrderMessage_OrderMessageOrderSurface_CATALOG;
constexpr int OrderMessage_OrderMessageOrderSurface_OrderMessageOrderSurface_ARRAYSIZE = OrderMessage_OrderMessageOrderSurface_OrderMessageOrderSurface_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderMessage_OrderMessageOrderSurface_descriptor();
template<typename T>
inline const std::string& OrderMessage_OrderMessageOrderSurface_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OrderMessage_OrderMessageOrderSurface>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OrderMessage_OrderMessageOrderSurface_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OrderMessage_OrderMessageOrderSurface_descriptor(), enum_t_value);
}
inline bool OrderMessage_OrderMessageOrderSurface_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OrderMessage_OrderMessageOrderSurface* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderMessage_OrderMessageOrderSurface>(
    OrderMessage_OrderMessageOrderSurface_descriptor(), name, value);
}
enum ListMessage_ListMessageListType : int {
  ListMessage_ListMessageListType_UNKNOWN = 0,
  ListMessage_ListMessageListType_SINGLE_SELECT = 1
};
bool ListMessage_ListMessageListType_IsValid(int value);
constexpr ListMessage_ListMessageListType ListMessage_ListMessageListType_ListMessageListType_MIN = ListMessage_ListMessageListType_UNKNOWN;
constexpr ListMessage_ListMessageListType ListMessage_ListMessageListType_ListMessageListType_MAX = ListMessage_ListMessageListType_SINGLE_SELECT;
constexpr int ListMessage_ListMessageListType_ListMessageListType_ARRAYSIZE = ListMessage_ListMessageListType_ListMessageListType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ListMessage_ListMessageListType_descriptor();
template<typename T>
inline const std::string& ListMessage_ListMessageListType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ListMessage_ListMessageListType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ListMessage_ListMessageListType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ListMessage_ListMessageListType_descriptor(), enum_t_value);
}
inline bool ListMessage_ListMessageListType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ListMessage_ListMessageListType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ListMessage_ListMessageListType>(
    ListMessage_ListMessageListType_descriptor(), name, value);
}
enum ListResponseMessage_ListResponseMessageListType : int {
  ListResponseMessage_ListResponseMessageListType_UNKNOWN = 0,
  ListResponseMessage_ListResponseMessageListType_SINGLE_SELECT = 1
};
bool ListResponseMessage_ListResponseMessageListType_IsValid(int value);
constexpr ListResponseMessage_ListResponseMessageListType ListResponseMessage_ListResponseMessageListType_ListResponseMessageListType_MIN = ListResponseMessage_ListResponseMessageListType_UNKNOWN;
constexpr ListResponseMessage_ListResponseMessageListType ListResponseMessage_ListResponseMessageListType_ListResponseMessageListType_MAX = ListResponseMessage_ListResponseMessageListType_SINGLE_SELECT;
constexpr int ListResponseMessage_ListResponseMessageListType_ListResponseMessageListType_ARRAYSIZE = ListResponseMessage_ListResponseMessageListType_ListResponseMessageListType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ListResponseMessage_ListResponseMessageListType_descriptor();
template<typename T>
inline const std::string& ListResponseMessage_ListResponseMessageListType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ListResponseMessage_ListResponseMessageListType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ListResponseMessage_ListResponseMessageListType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ListResponseMessage_ListResponseMessageListType_descriptor(), enum_t_value);
}
inline bool ListResponseMessage_ListResponseMessageListType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ListResponseMessage_ListResponseMessageListType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ListResponseMessage_ListResponseMessageListType>(
    ListResponseMessage_ListResponseMessageListType_descriptor(), name, value);
}
enum Button_ButtonType : int {
  Button_ButtonType_UNKNOWN = 0,
  Button_ButtonType_RESPONSE = 1
};
bool Button_ButtonType_IsValid(int value);
constexpr Button_ButtonType Button_ButtonType_ButtonType_MIN = Button_ButtonType_UNKNOWN;
constexpr Button_ButtonType Button_ButtonType_ButtonType_MAX = Button_ButtonType_RESPONSE;
constexpr int Button_ButtonType_ButtonType_ARRAYSIZE = Button_ButtonType_ButtonType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Button_ButtonType_descriptor();
template<typename T>
inline const std::string& Button_ButtonType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Button_ButtonType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Button_ButtonType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Button_ButtonType_descriptor(), enum_t_value);
}
inline bool Button_ButtonType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Button_ButtonType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Button_ButtonType>(
    Button_ButtonType_descriptor(), name, value);
}
enum ButtonsMessage_ButtonsMessageHeaderType : int {
  ButtonsMessage_ButtonsMessageHeaderType_UNKNOWN = 0,
  ButtonsMessage_ButtonsMessageHeaderType_EMPTY = 1,
  ButtonsMessage_ButtonsMessageHeaderType_TEXT = 2,
  ButtonsMessage_ButtonsMessageHeaderType_DOCUMENT = 3,
  ButtonsMessage_ButtonsMessageHeaderType_IMAGE = 4,
  ButtonsMessage_ButtonsMessageHeaderType_VIDEO = 5,
  ButtonsMessage_ButtonsMessageHeaderType_LOCATION = 6
};
bool ButtonsMessage_ButtonsMessageHeaderType_IsValid(int value);
constexpr ButtonsMessage_ButtonsMessageHeaderType ButtonsMessage_ButtonsMessageHeaderType_ButtonsMessageHeaderType_MIN = ButtonsMessage_ButtonsMessageHeaderType_UNKNOWN;
constexpr ButtonsMessage_ButtonsMessageHeaderType ButtonsMessage_ButtonsMessageHeaderType_ButtonsMessageHeaderType_MAX = ButtonsMessage_ButtonsMessageHeaderType_LOCATION;
constexpr int ButtonsMessage_ButtonsMessageHeaderType_ButtonsMessageHeaderType_ARRAYSIZE = ButtonsMessage_ButtonsMessageHeaderType_ButtonsMessageHeaderType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ButtonsMessage_ButtonsMessageHeaderType_descriptor();
template<typename T>
inline const std::string& ButtonsMessage_ButtonsMessageHeaderType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ButtonsMessage_ButtonsMessageHeaderType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ButtonsMessage_ButtonsMessageHeaderType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ButtonsMessage_ButtonsMessageHeaderType_descriptor(), enum_t_value);
}
inline bool ButtonsMessage_ButtonsMessageHeaderType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ButtonsMessage_ButtonsMessageHeaderType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ButtonsMessage_ButtonsMessageHeaderType>(
    ButtonsMessage_ButtonsMessageHeaderType_descriptor(), name, value);
}
enum ButtonsResponseMessage_ButtonsResponseMessageType : int {
  ButtonsResponseMessage_ButtonsResponseMessageType_UNKNOWN = 0,
  ButtonsResponseMessage_ButtonsResponseMessageType_DISPLAY_TEXT = 1
};
bool ButtonsResponseMessage_ButtonsResponseMessageType_IsValid(int value);
constexpr ButtonsResponseMessage_ButtonsResponseMessageType ButtonsResponseMessage_ButtonsResponseMessageType_ButtonsResponseMessageType_MIN = ButtonsResponseMessage_ButtonsResponseMessageType_UNKNOWN;
constexpr ButtonsResponseMessage_ButtonsResponseMessageType ButtonsResponseMessage_ButtonsResponseMessageType_ButtonsResponseMessageType_MAX = ButtonsResponseMessage_ButtonsResponseMessageType_DISPLAY_TEXT;
constexpr int ButtonsResponseMessage_ButtonsResponseMessageType_ButtonsResponseMessageType_ARRAYSIZE = ButtonsResponseMessage_ButtonsResponseMessageType_ButtonsResponseMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ButtonsResponseMessage_ButtonsResponseMessageType_descriptor();
template<typename T>
inline const std::string& ButtonsResponseMessage_ButtonsResponseMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ButtonsResponseMessage_ButtonsResponseMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ButtonsResponseMessage_ButtonsResponseMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ButtonsResponseMessage_ButtonsResponseMessageType_descriptor(), enum_t_value);
}
inline bool ButtonsResponseMessage_ButtonsResponseMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ButtonsResponseMessage_ButtonsResponseMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ButtonsResponseMessage_ButtonsResponseMessageType>(
    ButtonsResponseMessage_ButtonsResponseMessageType_descriptor(), name, value);
}
enum WebFeatures_WebFeaturesFlag : int {
  WebFeatures_WebFeaturesFlag_NOT_STARTED = 0,
  WebFeatures_WebFeaturesFlag_FORCE_UPGRADE = 1,
  WebFeatures_WebFeaturesFlag_DEVELOPMENT = 2,
  WebFeatures_WebFeaturesFlag_PRODUCTION = 3
};
bool WebFeatures_WebFeaturesFlag_IsValid(int value);
constexpr WebFeatures_WebFeaturesFlag WebFeatures_WebFeaturesFlag_WebFeaturesFlag_MIN = WebFeatures_WebFeaturesFlag_NOT_STARTED;
constexpr WebFeatures_WebFeaturesFlag WebFeatures_WebFeaturesFlag_WebFeaturesFlag_MAX = WebFeatures_WebFeaturesFlag_PRODUCTION;
constexpr int WebFeatures_WebFeaturesFlag_WebFeaturesFlag_ARRAYSIZE = WebFeatures_WebFeaturesFlag_WebFeaturesFlag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WebFeatures_WebFeaturesFlag_descriptor();
template<typename T>
inline const std::string& WebFeatures_WebFeaturesFlag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WebFeatures_WebFeaturesFlag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WebFeatures_WebFeaturesFlag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WebFeatures_WebFeaturesFlag_descriptor(), enum_t_value);
}
inline bool WebFeatures_WebFeaturesFlag_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WebFeatures_WebFeaturesFlag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WebFeatures_WebFeaturesFlag>(
    WebFeatures_WebFeaturesFlag_descriptor(), name, value);
}
enum PaymentInfo_PaymentInfoCurrency : int {
  PaymentInfo_PaymentInfoCurrency_UNKNOWN_CURRENCY = 0,
  PaymentInfo_PaymentInfoCurrency_INR = 1
};
bool PaymentInfo_PaymentInfoCurrency_IsValid(int value);
constexpr PaymentInfo_PaymentInfoCurrency PaymentInfo_PaymentInfoCurrency_PaymentInfoCurrency_MIN = PaymentInfo_PaymentInfoCurrency_UNKNOWN_CURRENCY;
constexpr PaymentInfo_PaymentInfoCurrency PaymentInfo_PaymentInfoCurrency_PaymentInfoCurrency_MAX = PaymentInfo_PaymentInfoCurrency_INR;
constexpr int PaymentInfo_PaymentInfoCurrency_PaymentInfoCurrency_ARRAYSIZE = PaymentInfo_PaymentInfoCurrency_PaymentInfoCurrency_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PaymentInfo_PaymentInfoCurrency_descriptor();
template<typename T>
inline const std::string& PaymentInfo_PaymentInfoCurrency_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PaymentInfo_PaymentInfoCurrency>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PaymentInfo_PaymentInfoCurrency_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PaymentInfo_PaymentInfoCurrency_descriptor(), enum_t_value);
}
inline bool PaymentInfo_PaymentInfoCurrency_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PaymentInfo_PaymentInfoCurrency* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PaymentInfo_PaymentInfoCurrency>(
    PaymentInfo_PaymentInfoCurrency_descriptor(), name, value);
}
enum PaymentInfo_PaymentInfoStatus : int {
  PaymentInfo_PaymentInfoStatus_UNKNOWN_STATUS = 0,
  PaymentInfo_PaymentInfoStatus_PROCESSING = 1,
  PaymentInfo_PaymentInfoStatus_SENT = 2,
  PaymentInfo_PaymentInfoStatus_NEED_TO_ACCEPT = 3,
  PaymentInfo_PaymentInfoStatus_COMPLETE = 4,
  PaymentInfo_PaymentInfoStatus_COULD_NOT_COMPLETE = 5,
  PaymentInfo_PaymentInfoStatus_REFUNDED = 6,
  PaymentInfo_PaymentInfoStatus_EXPIRED = 7,
  PaymentInfo_PaymentInfoStatus_REJECTED = 8,
  PaymentInfo_PaymentInfoStatus_CANCELLED = 9,
  PaymentInfo_PaymentInfoStatus_WAITING_FOR_PAYER = 10,
  PaymentInfo_PaymentInfoStatus_WAITING = 11
};
bool PaymentInfo_PaymentInfoStatus_IsValid(int value);
constexpr PaymentInfo_PaymentInfoStatus PaymentInfo_PaymentInfoStatus_PaymentInfoStatus_MIN = PaymentInfo_PaymentInfoStatus_UNKNOWN_STATUS;
constexpr PaymentInfo_PaymentInfoStatus PaymentInfo_PaymentInfoStatus_PaymentInfoStatus_MAX = PaymentInfo_PaymentInfoStatus_WAITING;
constexpr int PaymentInfo_PaymentInfoStatus_PaymentInfoStatus_ARRAYSIZE = PaymentInfo_PaymentInfoStatus_PaymentInfoStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PaymentInfo_PaymentInfoStatus_descriptor();
template<typename T>
inline const std::string& PaymentInfo_PaymentInfoStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PaymentInfo_PaymentInfoStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PaymentInfo_PaymentInfoStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PaymentInfo_PaymentInfoStatus_descriptor(), enum_t_value);
}
inline bool PaymentInfo_PaymentInfoStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PaymentInfo_PaymentInfoStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PaymentInfo_PaymentInfoStatus>(
    PaymentInfo_PaymentInfoStatus_descriptor(), name, value);
}
enum PaymentInfo_PaymentInfoTxnStatus : int {
  PaymentInfo_PaymentInfoTxnStatus_UNKNOWN = 0,
  PaymentInfo_PaymentInfoTxnStatus_PENDING_SETUP = 1,
  PaymentInfo_PaymentInfoTxnStatus_PENDING_RECEIVER_SETUP = 2,
  PaymentInfo_PaymentInfoTxnStatus_INIT = 3,
  PaymentInfo_PaymentInfoTxnStatus_SUCCESS = 4,
  PaymentInfo_PaymentInfoTxnStatus_COMPLETED = 5,
  PaymentInfo_PaymentInfoTxnStatus_FAILED = 6,
  PaymentInfo_PaymentInfoTxnStatus_FAILED_RISK = 7,
  PaymentInfo_PaymentInfoTxnStatus_FAILED_PROCESSING = 8,
  PaymentInfo_PaymentInfoTxnStatus_FAILED_RECEIVER_PROCESSING = 9,
  PaymentInfo_PaymentInfoTxnStatus_FAILED_DA = 10,
  PaymentInfo_PaymentInfoTxnStatus_FAILED_DA_FINAL = 11,
  PaymentInfo_PaymentInfoTxnStatus_REFUNDED_TXN = 12,
  PaymentInfo_PaymentInfoTxnStatus_REFUND_FAILED = 13,
  PaymentInfo_PaymentInfoTxnStatus_REFUND_FAILED_PROCESSING = 14,
  PaymentInfo_PaymentInfoTxnStatus_REFUND_FAILED_DA = 15,
  PaymentInfo_PaymentInfoTxnStatus_EXPIRED_TXN = 16,
  PaymentInfo_PaymentInfoTxnStatus_AUTH_CANCELED = 17,
  PaymentInfo_PaymentInfoTxnStatus_AUTH_CANCEL_FAILED_PROCESSING = 18,
  PaymentInfo_PaymentInfoTxnStatus_AUTH_CANCEL_FAILED = 19,
  PaymentInfo_PaymentInfoTxnStatus_COLLECT_INIT = 20,
  PaymentInfo_PaymentInfoTxnStatus_COLLECT_SUCCESS = 21,
  PaymentInfo_PaymentInfoTxnStatus_COLLECT_FAILED = 22,
  PaymentInfo_PaymentInfoTxnStatus_COLLECT_FAILED_RISK = 23,
  PaymentInfo_PaymentInfoTxnStatus_COLLECT_REJECTED = 24,
  PaymentInfo_PaymentInfoTxnStatus_COLLECT_EXPIRED = 25,
  PaymentInfo_PaymentInfoTxnStatus_COLLECT_CANCELED = 26,
  PaymentInfo_PaymentInfoTxnStatus_COLLECT_CANCELLING = 27
};
bool PaymentInfo_PaymentInfoTxnStatus_IsValid(int value);
constexpr PaymentInfo_PaymentInfoTxnStatus PaymentInfo_PaymentInfoTxnStatus_PaymentInfoTxnStatus_MIN = PaymentInfo_PaymentInfoTxnStatus_UNKNOWN;
constexpr PaymentInfo_PaymentInfoTxnStatus PaymentInfo_PaymentInfoTxnStatus_PaymentInfoTxnStatus_MAX = PaymentInfo_PaymentInfoTxnStatus_COLLECT_CANCELLING;
constexpr int PaymentInfo_PaymentInfoTxnStatus_PaymentInfoTxnStatus_ARRAYSIZE = PaymentInfo_PaymentInfoTxnStatus_PaymentInfoTxnStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PaymentInfo_PaymentInfoTxnStatus_descriptor();
template<typename T>
inline const std::string& PaymentInfo_PaymentInfoTxnStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PaymentInfo_PaymentInfoTxnStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PaymentInfo_PaymentInfoTxnStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PaymentInfo_PaymentInfoTxnStatus_descriptor(), enum_t_value);
}
inline bool PaymentInfo_PaymentInfoTxnStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PaymentInfo_PaymentInfoTxnStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PaymentInfo_PaymentInfoTxnStatus>(
    PaymentInfo_PaymentInfoTxnStatus_descriptor(), name, value);
}
enum WebMessageInfo_WebMessageInfoStatus : int {
  WebMessageInfo_WebMessageInfoStatus_ERROR = 0,
  WebMessageInfo_WebMessageInfoStatus_PENDING = 1,
  WebMessageInfo_WebMessageInfoStatus_SERVER_ACK = 2,
  WebMessageInfo_WebMessageInfoStatus_DELIVERY_ACK = 3,
  WebMessageInfo_WebMessageInfoStatus_READ = 4,
  WebMessageInfo_WebMessageInfoStatus_PLAYED = 5
};
bool WebMessageInfo_WebMessageInfoStatus_IsValid(int value);
constexpr WebMessageInfo_WebMessageInfoStatus WebMessageInfo_WebMessageInfoStatus_WebMessageInfoStatus_MIN = WebMessageInfo_WebMessageInfoStatus_ERROR;
constexpr WebMessageInfo_WebMessageInfoStatus WebMessageInfo_WebMessageInfoStatus_WebMessageInfoStatus_MAX = WebMessageInfo_WebMessageInfoStatus_PLAYED;
constexpr int WebMessageInfo_WebMessageInfoStatus_WebMessageInfoStatus_ARRAYSIZE = WebMessageInfo_WebMessageInfoStatus_WebMessageInfoStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WebMessageInfo_WebMessageInfoStatus_descriptor();
template<typename T>
inline const std::string& WebMessageInfo_WebMessageInfoStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WebMessageInfo_WebMessageInfoStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WebMessageInfo_WebMessageInfoStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WebMessageInfo_WebMessageInfoStatus_descriptor(), enum_t_value);
}
inline bool WebMessageInfo_WebMessageInfoStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WebMessageInfo_WebMessageInfoStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WebMessageInfo_WebMessageInfoStatus>(
    WebMessageInfo_WebMessageInfoStatus_descriptor(), name, value);
}
enum WebMessageInfo_WebMessageInfoStubType : int {
  WebMessageInfo_WebMessageInfoStubType_UNKNOWN = 0,
  WebMessageInfo_WebMessageInfoStubType_REVOKE = 1,
  WebMessageInfo_WebMessageInfoStubType_CIPHERTEXT = 2,
  WebMessageInfo_WebMessageInfoStubType_FUTUREPROOF = 3,
  WebMessageInfo_WebMessageInfoStubType_NON_VERIFIED_TRANSITION = 4,
  WebMessageInfo_WebMessageInfoStubType_UNVERIFIED_TRANSITION = 5,
  WebMessageInfo_WebMessageInfoStubType_VERIFIED_TRANSITION = 6,
  WebMessageInfo_WebMessageInfoStubType_VERIFIED_LOW_UNKNOWN = 7,
  WebMessageInfo_WebMessageInfoStubType_VERIFIED_HIGH = 8,
  WebMessageInfo_WebMessageInfoStubType_VERIFIED_INITIAL_UNKNOWN = 9,
  WebMessageInfo_WebMessageInfoStubType_VERIFIED_INITIAL_LOW = 10,
  WebMessageInfo_WebMessageInfoStubType_VERIFIED_INITIAL_HIGH = 11,
  WebMessageInfo_WebMessageInfoStubType_VERIFIED_TRANSITION_ANY_TO_NONE = 12,
  WebMessageInfo_WebMessageInfoStubType_VERIFIED_TRANSITION_ANY_TO_HIGH = 13,
  WebMessageInfo_WebMessageInfoStubType_VERIFIED_TRANSITION_HIGH_TO_LOW = 14,
  WebMessageInfo_WebMessageInfoStubType_VERIFIED_TRANSITION_HIGH_TO_UNKNOWN = 15,
  WebMessageInfo_WebMessageInfoStubType_VERIFIED_TRANSITION_UNKNOWN_TO_LOW = 16,
  WebMessageInfo_WebMessageInfoStubType_VERIFIED_TRANSITION_LOW_TO_UNKNOWN = 17,
  WebMessageInfo_WebMessageInfoStubType_VERIFIED_TRANSITION_NONE_TO_LOW = 18,
  WebMessageInfo_WebMessageInfoStubType_VERIFIED_TRANSITION_NONE_TO_UNKNOWN = 19,
  WebMessageInfo_WebMessageInfoStubType_GROUP_CREATE = 20,
  WebMessageInfo_WebMessageInfoStubType_GROUP_CHANGE_SUBJECT = 21,
  WebMessageInfo_WebMessageInfoStubType_GROUP_CHANGE_ICON = 22,
  WebMessageInfo_WebMessageInfoStubType_GROUP_CHANGE_INVITE_LINK = 23,
  WebMessageInfo_WebMessageInfoStubType_GROUP_CHANGE_DESCRIPTION = 24,
  WebMessageInfo_WebMessageInfoStubType_GROUP_CHANGE_RESTRICT = 25,
  WebMessageInfo_WebMessageInfoStubType_GROUP_CHANGE_ANNOUNCE = 26,
  WebMessageInfo_WebMessageInfoStubType_GROUP_PARTICIPANT_ADD = 27,
  WebMessageInfo_WebMessageInfoStubType_GROUP_PARTICIPANT_REMOVE = 28,
  WebMessageInfo_WebMessageInfoStubType_GROUP_PARTICIPANT_PROMOTE = 29,
  WebMessageInfo_WebMessageInfoStubType_GROUP_PARTICIPANT_DEMOTE = 30,
  WebMessageInfo_WebMessageInfoStubType_GROUP_PARTICIPANT_INVITE = 31,
  WebMessageInfo_WebMessageInfoStubType_GROUP_PARTICIPANT_LEAVE = 32,
  WebMessageInfo_WebMessageInfoStubType_GROUP_PARTICIPANT_CHANGE_NUMBER = 33,
  WebMessageInfo_WebMessageInfoStubType_BROADCAST_CREATE = 34,
  WebMessageInfo_WebMessageInfoStubType_BROADCAST_ADD = 35,
  WebMessageInfo_WebMessageInfoStubType_BROADCAST_REMOVE = 36,
  WebMessageInfo_WebMessageInfoStubType_GENERIC_NOTIFICATION = 37,
  WebMessageInfo_WebMessageInfoStubType_E2E_IDENTITY_CHANGED = 38,
  WebMessageInfo_WebMessageInfoStubType_E2E_ENCRYPTED = 39,
  WebMessageInfo_WebMessageInfoStubType_CALL_MISSED_VOICE = 40,
  WebMessageInfo_WebMessageInfoStubType_CALL_MISSED_VIDEO = 41,
  WebMessageInfo_WebMessageInfoStubType_INDIVIDUAL_CHANGE_NUMBER = 42,
  WebMessageInfo_WebMessageInfoStubType_GROUP_DELETE = 43,
  WebMessageInfo_WebMessageInfoStubType_GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE = 44,
  WebMessageInfo_WebMessageInfoStubType_CALL_MISSED_GROUP_VOICE = 45,
  WebMessageInfo_WebMessageInfoStubType_CALL_MISSED_GROUP_VIDEO = 46,
  WebMessageInfo_WebMessageInfoStubType_PAYMENT_CIPHERTEXT = 47,
  WebMessageInfo_WebMessageInfoStubType_PAYMENT_FUTUREPROOF = 48,
  WebMessageInfo_WebMessageInfoStubType_PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED = 49,
  WebMessageInfo_WebMessageInfoStubType_PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED = 50,
  WebMessageInfo_WebMessageInfoStubType_PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED = 51,
  WebMessageInfo_WebMessageInfoStubType_PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP = 52,
  WebMessageInfo_WebMessageInfoStubType_PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP = 53,
  WebMessageInfo_WebMessageInfoStubType_PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER = 54,
  WebMessageInfo_WebMessageInfoStubType_PAYMENT_ACTION_SEND_PAYMENT_REMINDER = 55,
  WebMessageInfo_WebMessageInfoStubType_PAYMENT_ACTION_SEND_PAYMENT_INVITATION = 56,
  WebMessageInfo_WebMessageInfoStubType_PAYMENT_ACTION_REQUEST_DECLINED = 57,
  WebMessageInfo_WebMessageInfoStubType_PAYMENT_ACTION_REQUEST_EXPIRED = 58,
  WebMessageInfo_WebMessageInfoStubType_PAYMENT_ACTION_REQUEST_CANCELLED = 59,
  WebMessageInfo_WebMessageInfoStubType_BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM = 60,
  WebMessageInfo_WebMessageInfoStubType_BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP = 61,
  WebMessageInfo_WebMessageInfoStubType_BIZ_INTRO_TOP = 62,
  WebMessageInfo_WebMessageInfoStubType_BIZ_INTRO_BOTTOM = 63,
  WebMessageInfo_WebMessageInfoStubType_BIZ_NAME_CHANGE = 64,
  WebMessageInfo_WebMessageInfoStubType_BIZ_MOVE_TO_CONSUMER_APP = 65,
  WebMessageInfo_WebMessageInfoStubType_BIZ_TWO_TIER_MIGRATION_TOP = 66,
  WebMessageInfo_WebMessageInfoStubType_BIZ_TWO_TIER_MIGRATION_BOTTOM = 67,
  WebMessageInfo_WebMessageInfoStubType_OVERSIZED = 68,
  WebMessageInfo_WebMessageInfoStubType_GROUP_CHANGE_NO_FREQUENTLY_FORWARDED = 69,
  WebMessageInfo_WebMessageInfoStubType_GROUP_V4_ADD_INVITE_SENT = 70,
  WebMessageInfo_WebMessageInfoStubType_GROUP_PARTICIPANT_ADD_REQUEST_JOIN = 71,
  WebMessageInfo_WebMessageInfoStubType_CHANGE_EPHEMERAL_SETTING = 72,
  WebMessageInfo_WebMessageInfoStubType_E2E_DEVICE_CHANGED = 73,
  WebMessageInfo_WebMessageInfoStubType_VIEWED_ONCE = 74,
  WebMessageInfo_WebMessageInfoStubType_E2E_ENCRYPTED_NOW = 75,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_TO_BSP_PREMISE = 76,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_TO_SELF_FB = 77,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_TO_SELF_PREMISE = 78,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_UNVERIFIED = 79,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED = 80,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_VERIFIED = 81,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED = 82,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE = 83,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_PREMISE_UNVERIFIED = 84,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED = 85,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_PREMISE_VERIFIED = 86,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED = 87,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED = 88,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED = 89,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED = 90,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED = 91,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_FB_TO_BSP_PREMISE = 92,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_FB_TO_SELF_PREMISE = 93,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_FB_UNVERIFIED = 94,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED = 95,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_FB_VERIFIED = 96,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED = 97,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_PREMISE_TO_BSP_PREMISE = 98,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_PREMISE_UNVERIFIED = 99,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_PREMISE_VERIFIED = 100,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_TO_BSP_FB = 101,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_TO_CONSUMER = 102,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_TO_SELF_FB = 103,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED = 104,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED = 105,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED = 106,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_UNVERIFIED_TO_VERIFIED = 107,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED = 108,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED = 109,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED = 110,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_VERIFIED_TO_UNVERIFIED = 111,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED = 112,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED = 113,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED = 114,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED = 115,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED = 116,
  WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED = 117,
  WebMessageInfo_WebMessageInfoStubType_E2E_IDENTITY_UNAVAILABLE = 118
};
bool WebMessageInfo_WebMessageInfoStubType_IsValid(int value);
constexpr WebMessageInfo_WebMessageInfoStubType WebMessageInfo_WebMessageInfoStubType_WebMessageInfoStubType_MIN = WebMessageInfo_WebMessageInfoStubType_UNKNOWN;
constexpr WebMessageInfo_WebMessageInfoStubType WebMessageInfo_WebMessageInfoStubType_WebMessageInfoStubType_MAX = WebMessageInfo_WebMessageInfoStubType_E2E_IDENTITY_UNAVAILABLE;
constexpr int WebMessageInfo_WebMessageInfoStubType_WebMessageInfoStubType_ARRAYSIZE = WebMessageInfo_WebMessageInfoStubType_WebMessageInfoStubType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WebMessageInfo_WebMessageInfoStubType_descriptor();
template<typename T>
inline const std::string& WebMessageInfo_WebMessageInfoStubType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WebMessageInfo_WebMessageInfoStubType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WebMessageInfo_WebMessageInfoStubType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WebMessageInfo_WebMessageInfoStubType_descriptor(), enum_t_value);
}
inline bool WebMessageInfo_WebMessageInfoStubType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WebMessageInfo_WebMessageInfoStubType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WebMessageInfo_WebMessageInfoStubType>(
    WebMessageInfo_WebMessageInfoStubType_descriptor(), name, value);
}
enum WebMessageInfo_WebMessageInfoBizPrivacyStatus : int {
  WebMessageInfo_WebMessageInfoBizPrivacyStatus_E2EE = 0,
  WebMessageInfo_WebMessageInfoBizPrivacyStatus_FB = 2,
  WebMessageInfo_WebMessageInfoBizPrivacyStatus_BSP = 1,
  WebMessageInfo_WebMessageInfoBizPrivacyStatus_BSP_AND_FB = 3
};
bool WebMessageInfo_WebMessageInfoBizPrivacyStatus_IsValid(int value);
constexpr WebMessageInfo_WebMessageInfoBizPrivacyStatus WebMessageInfo_WebMessageInfoBizPrivacyStatus_WebMessageInfoBizPrivacyStatus_MIN = WebMessageInfo_WebMessageInfoBizPrivacyStatus_E2EE;
constexpr WebMessageInfo_WebMessageInfoBizPrivacyStatus WebMessageInfo_WebMessageInfoBizPrivacyStatus_WebMessageInfoBizPrivacyStatus_MAX = WebMessageInfo_WebMessageInfoBizPrivacyStatus_BSP_AND_FB;
constexpr int WebMessageInfo_WebMessageInfoBizPrivacyStatus_WebMessageInfoBizPrivacyStatus_ARRAYSIZE = WebMessageInfo_WebMessageInfoBizPrivacyStatus_WebMessageInfoBizPrivacyStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WebMessageInfo_WebMessageInfoBizPrivacyStatus_descriptor();
template<typename T>
inline const std::string& WebMessageInfo_WebMessageInfoBizPrivacyStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WebMessageInfo_WebMessageInfoBizPrivacyStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WebMessageInfo_WebMessageInfoBizPrivacyStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WebMessageInfo_WebMessageInfoBizPrivacyStatus_descriptor(), enum_t_value);
}
inline bool WebMessageInfo_WebMessageInfoBizPrivacyStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WebMessageInfo_WebMessageInfoBizPrivacyStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WebMessageInfo_WebMessageInfoBizPrivacyStatus>(
    WebMessageInfo_WebMessageInfoBizPrivacyStatus_descriptor(), name, value);
}
// ===================================================================

class PaymentMoney final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.PaymentMoney) */ {
 public:
  inline PaymentMoney() : PaymentMoney(nullptr) {}
  ~PaymentMoney() override;
  explicit PROTOBUF_CONSTEXPR PaymentMoney(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaymentMoney(const PaymentMoney& from);
  PaymentMoney(PaymentMoney&& from) noexcept
    : PaymentMoney() {
    *this = ::std::move(from);
  }

  inline PaymentMoney& operator=(const PaymentMoney& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentMoney& operator=(PaymentMoney&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaymentMoney& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaymentMoney* internal_default_instance() {
    return reinterpret_cast<const PaymentMoney*>(
               &_PaymentMoney_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PaymentMoney& a, PaymentMoney& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentMoney* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaymentMoney* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PaymentMoney* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PaymentMoney>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaymentMoney& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PaymentMoney& from) {
    PaymentMoney::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentMoney* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.PaymentMoney";
  }
  protected:
  explicit PaymentMoney(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrencyCodeFieldNumber = 3,
    kValueFieldNumber = 1,
    kOffsetFieldNumber = 2,
  };
  // optional string currencyCode = 3;
  bool has_currencycode() const;
  private:
  bool _internal_has_currencycode() const;
  public:
  void clear_currencycode();
  const std::string& currencycode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currencycode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currencycode();
  PROTOBUF_NODISCARD std::string* release_currencycode();
  void set_allocated_currencycode(std::string* currencycode);
  private:
  const std::string& _internal_currencycode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currencycode(const std::string& value);
  std::string* _internal_mutable_currencycode();
  public:

  // optional int64 value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  int64_t value() const;
  void set_value(int64_t value);
  private:
  int64_t _internal_value() const;
  void _internal_set_value(int64_t value);
  public:

  // optional uint32 offset = 2;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  uint32_t offset() const;
  void set_offset(uint32_t value);
  private:
  uint32_t _internal_offset() const;
  void _internal_set_offset(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.PaymentMoney)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currencycode_;
    int64_t value_;
    uint32_t offset_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class HydratedQuickReplyButton final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.HydratedQuickReplyButton) */ {
 public:
  inline HydratedQuickReplyButton() : HydratedQuickReplyButton(nullptr) {}
  ~HydratedQuickReplyButton() override;
  explicit PROTOBUF_CONSTEXPR HydratedQuickReplyButton(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HydratedQuickReplyButton(const HydratedQuickReplyButton& from);
  HydratedQuickReplyButton(HydratedQuickReplyButton&& from) noexcept
    : HydratedQuickReplyButton() {
    *this = ::std::move(from);
  }

  inline HydratedQuickReplyButton& operator=(const HydratedQuickReplyButton& from) {
    CopyFrom(from);
    return *this;
  }
  inline HydratedQuickReplyButton& operator=(HydratedQuickReplyButton&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HydratedQuickReplyButton& default_instance() {
    return *internal_default_instance();
  }
  static inline const HydratedQuickReplyButton* internal_default_instance() {
    return reinterpret_cast<const HydratedQuickReplyButton*>(
               &_HydratedQuickReplyButton_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HydratedQuickReplyButton& a, HydratedQuickReplyButton& b) {
    a.Swap(&b);
  }
  inline void Swap(HydratedQuickReplyButton* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HydratedQuickReplyButton* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HydratedQuickReplyButton* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HydratedQuickReplyButton>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HydratedQuickReplyButton& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HydratedQuickReplyButton& from) {
    HydratedQuickReplyButton::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HydratedQuickReplyButton* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HydratedQuickReplyButton";
  }
  protected:
  explicit HydratedQuickReplyButton(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayTextFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // optional string displayText = 1;
  bool has_displaytext() const;
  private:
  bool _internal_has_displaytext() const;
  public:
  void clear_displaytext();
  const std::string& displaytext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_displaytext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_displaytext();
  PROTOBUF_NODISCARD std::string* release_displaytext();
  void set_allocated_displaytext(std::string* displaytext);
  private:
  const std::string& _internal_displaytext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_displaytext(const std::string& value);
  std::string* _internal_mutable_displaytext();
  public:

  // optional string id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:proto.HydratedQuickReplyButton)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr displaytext_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class HydratedURLButton final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.HydratedURLButton) */ {
 public:
  inline HydratedURLButton() : HydratedURLButton(nullptr) {}
  ~HydratedURLButton() override;
  explicit PROTOBUF_CONSTEXPR HydratedURLButton(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HydratedURLButton(const HydratedURLButton& from);
  HydratedURLButton(HydratedURLButton&& from) noexcept
    : HydratedURLButton() {
    *this = ::std::move(from);
  }

  inline HydratedURLButton& operator=(const HydratedURLButton& from) {
    CopyFrom(from);
    return *this;
  }
  inline HydratedURLButton& operator=(HydratedURLButton&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HydratedURLButton& default_instance() {
    return *internal_default_instance();
  }
  static inline const HydratedURLButton* internal_default_instance() {
    return reinterpret_cast<const HydratedURLButton*>(
               &_HydratedURLButton_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HydratedURLButton& a, HydratedURLButton& b) {
    a.Swap(&b);
  }
  inline void Swap(HydratedURLButton* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HydratedURLButton* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HydratedURLButton* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HydratedURLButton>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HydratedURLButton& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HydratedURLButton& from) {
    HydratedURLButton::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HydratedURLButton* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HydratedURLButton";
  }
  protected:
  explicit HydratedURLButton(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayTextFieldNumber = 1,
    kUrlFieldNumber = 2,
  };
  // optional string displayText = 1;
  bool has_displaytext() const;
  private:
  bool _internal_has_displaytext() const;
  public:
  void clear_displaytext();
  const std::string& displaytext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_displaytext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_displaytext();
  PROTOBUF_NODISCARD std::string* release_displaytext();
  void set_allocated_displaytext(std::string* displaytext);
  private:
  const std::string& _internal_displaytext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_displaytext(const std::string& value);
  std::string* _internal_mutable_displaytext();
  public:

  // optional string url = 2;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:proto.HydratedURLButton)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr displaytext_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class HydratedCallButton final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.HydratedCallButton) */ {
 public:
  inline HydratedCallButton() : HydratedCallButton(nullptr) {}
  ~HydratedCallButton() override;
  explicit PROTOBUF_CONSTEXPR HydratedCallButton(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HydratedCallButton(const HydratedCallButton& from);
  HydratedCallButton(HydratedCallButton&& from) noexcept
    : HydratedCallButton() {
    *this = ::std::move(from);
  }

  inline HydratedCallButton& operator=(const HydratedCallButton& from) {
    CopyFrom(from);
    return *this;
  }
  inline HydratedCallButton& operator=(HydratedCallButton&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HydratedCallButton& default_instance() {
    return *internal_default_instance();
  }
  static inline const HydratedCallButton* internal_default_instance() {
    return reinterpret_cast<const HydratedCallButton*>(
               &_HydratedCallButton_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HydratedCallButton& a, HydratedCallButton& b) {
    a.Swap(&b);
  }
  inline void Swap(HydratedCallButton* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HydratedCallButton* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HydratedCallButton* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HydratedCallButton>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HydratedCallButton& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HydratedCallButton& from) {
    HydratedCallButton::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HydratedCallButton* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HydratedCallButton";
  }
  protected:
  explicit HydratedCallButton(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayTextFieldNumber = 1,
    kPhoneNumberFieldNumber = 2,
  };
  // optional string displayText = 1;
  bool has_displaytext() const;
  private:
  bool _internal_has_displaytext() const;
  public:
  void clear_displaytext();
  const std::string& displaytext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_displaytext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_displaytext();
  PROTOBUF_NODISCARD std::string* release_displaytext();
  void set_allocated_displaytext(std::string* displaytext);
  private:
  const std::string& _internal_displaytext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_displaytext(const std::string& value);
  std::string* _internal_mutable_displaytext();
  public:

  // optional string phoneNumber = 2;
  bool has_phonenumber() const;
  private:
  bool _internal_has_phonenumber() const;
  public:
  void clear_phonenumber();
  const std::string& phonenumber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phonenumber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phonenumber();
  PROTOBUF_NODISCARD std::string* release_phonenumber();
  void set_allocated_phonenumber(std::string* phonenumber);
  private:
  const std::string& _internal_phonenumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phonenumber(const std::string& value);
  std::string* _internal_mutable_phonenumber();
  public:

  // @@protoc_insertion_point(class_scope:proto.HydratedCallButton)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr displaytext_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phonenumber_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class HydratedTemplateButton final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.HydratedTemplateButton) */ {
 public:
  inline HydratedTemplateButton() : HydratedTemplateButton(nullptr) {}
  ~HydratedTemplateButton() override;
  explicit PROTOBUF_CONSTEXPR HydratedTemplateButton(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HydratedTemplateButton(const HydratedTemplateButton& from);
  HydratedTemplateButton(HydratedTemplateButton&& from) noexcept
    : HydratedTemplateButton() {
    *this = ::std::move(from);
  }

  inline HydratedTemplateButton& operator=(const HydratedTemplateButton& from) {
    CopyFrom(from);
    return *this;
  }
  inline HydratedTemplateButton& operator=(HydratedTemplateButton&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HydratedTemplateButton& default_instance() {
    return *internal_default_instance();
  }
  enum HydratedButtonCase {
    kQuickReplyButton = 1,
    kUrlButton = 2,
    kCallButton = 3,
    HYDRATEDBUTTON_NOT_SET = 0,
  };

  static inline const HydratedTemplateButton* internal_default_instance() {
    return reinterpret_cast<const HydratedTemplateButton*>(
               &_HydratedTemplateButton_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(HydratedTemplateButton& a, HydratedTemplateButton& b) {
    a.Swap(&b);
  }
  inline void Swap(HydratedTemplateButton* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HydratedTemplateButton* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HydratedTemplateButton* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HydratedTemplateButton>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HydratedTemplateButton& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HydratedTemplateButton& from) {
    HydratedTemplateButton::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HydratedTemplateButton* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HydratedTemplateButton";
  }
  protected:
  explicit HydratedTemplateButton(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 4,
    kQuickReplyButtonFieldNumber = 1,
    kUrlButtonFieldNumber = 2,
    kCallButtonFieldNumber = 3,
  };
  // optional uint32 index = 4;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // .proto.HydratedQuickReplyButton quickReplyButton = 1;
  bool has_quickreplybutton() const;
  private:
  bool _internal_has_quickreplybutton() const;
  public:
  void clear_quickreplybutton();
  const ::proto::HydratedQuickReplyButton& quickreplybutton() const;
  PROTOBUF_NODISCARD ::proto::HydratedQuickReplyButton* release_quickreplybutton();
  ::proto::HydratedQuickReplyButton* mutable_quickreplybutton();
  void set_allocated_quickreplybutton(::proto::HydratedQuickReplyButton* quickreplybutton);
  private:
  const ::proto::HydratedQuickReplyButton& _internal_quickreplybutton() const;
  ::proto::HydratedQuickReplyButton* _internal_mutable_quickreplybutton();
  public:
  void unsafe_arena_set_allocated_quickreplybutton(
      ::proto::HydratedQuickReplyButton* quickreplybutton);
  ::proto::HydratedQuickReplyButton* unsafe_arena_release_quickreplybutton();

  // .proto.HydratedURLButton urlButton = 2;
  bool has_urlbutton() const;
  private:
  bool _internal_has_urlbutton() const;
  public:
  void clear_urlbutton();
  const ::proto::HydratedURLButton& urlbutton() const;
  PROTOBUF_NODISCARD ::proto::HydratedURLButton* release_urlbutton();
  ::proto::HydratedURLButton* mutable_urlbutton();
  void set_allocated_urlbutton(::proto::HydratedURLButton* urlbutton);
  private:
  const ::proto::HydratedURLButton& _internal_urlbutton() const;
  ::proto::HydratedURLButton* _internal_mutable_urlbutton();
  public:
  void unsafe_arena_set_allocated_urlbutton(
      ::proto::HydratedURLButton* urlbutton);
  ::proto::HydratedURLButton* unsafe_arena_release_urlbutton();

  // .proto.HydratedCallButton callButton = 3;
  bool has_callbutton() const;
  private:
  bool _internal_has_callbutton() const;
  public:
  void clear_callbutton();
  const ::proto::HydratedCallButton& callbutton() const;
  PROTOBUF_NODISCARD ::proto::HydratedCallButton* release_callbutton();
  ::proto::HydratedCallButton* mutable_callbutton();
  void set_allocated_callbutton(::proto::HydratedCallButton* callbutton);
  private:
  const ::proto::HydratedCallButton& _internal_callbutton() const;
  ::proto::HydratedCallButton* _internal_mutable_callbutton();
  public:
  void unsafe_arena_set_allocated_callbutton(
      ::proto::HydratedCallButton* callbutton);
  ::proto::HydratedCallButton* unsafe_arena_release_callbutton();

  void clear_hydratedButton();
  HydratedButtonCase hydratedButton_case() const;
  // @@protoc_insertion_point(class_scope:proto.HydratedTemplateButton)
 private:
  class _Internal;
  void set_has_quickreplybutton();
  void set_has_urlbutton();
  void set_has_callbutton();

  inline bool has_hydratedButton() const;
  inline void clear_has_hydratedButton();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t index_;
    union HydratedButtonUnion {
      constexpr HydratedButtonUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::proto::HydratedQuickReplyButton* quickreplybutton_;
      ::proto::HydratedURLButton* urlbutton_;
      ::proto::HydratedCallButton* callbutton_;
    } hydratedButton_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class QuickReplyButton final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.QuickReplyButton) */ {
 public:
  inline QuickReplyButton() : QuickReplyButton(nullptr) {}
  ~QuickReplyButton() override;
  explicit PROTOBUF_CONSTEXPR QuickReplyButton(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuickReplyButton(const QuickReplyButton& from);
  QuickReplyButton(QuickReplyButton&& from) noexcept
    : QuickReplyButton() {
    *this = ::std::move(from);
  }

  inline QuickReplyButton& operator=(const QuickReplyButton& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuickReplyButton& operator=(QuickReplyButton&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuickReplyButton& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuickReplyButton* internal_default_instance() {
    return reinterpret_cast<const QuickReplyButton*>(
               &_QuickReplyButton_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(QuickReplyButton& a, QuickReplyButton& b) {
    a.Swap(&b);
  }
  inline void Swap(QuickReplyButton* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuickReplyButton* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuickReplyButton* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuickReplyButton>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuickReplyButton& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuickReplyButton& from) {
    QuickReplyButton::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuickReplyButton* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.QuickReplyButton";
  }
  protected:
  explicit QuickReplyButton(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kDisplayTextFieldNumber = 1,
  };
  // optional string id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional .proto.HighlyStructuredMessage displayText = 1;
  bool has_displaytext() const;
  private:
  bool _internal_has_displaytext() const;
  public:
  void clear_displaytext();
  const ::proto::HighlyStructuredMessage& displaytext() const;
  PROTOBUF_NODISCARD ::proto::HighlyStructuredMessage* release_displaytext();
  ::proto::HighlyStructuredMessage* mutable_displaytext();
  void set_allocated_displaytext(::proto::HighlyStructuredMessage* displaytext);
  private:
  const ::proto::HighlyStructuredMessage& _internal_displaytext() const;
  ::proto::HighlyStructuredMessage* _internal_mutable_displaytext();
  public:
  void unsafe_arena_set_allocated_displaytext(
      ::proto::HighlyStructuredMessage* displaytext);
  ::proto::HighlyStructuredMessage* unsafe_arena_release_displaytext();

  // @@protoc_insertion_point(class_scope:proto.QuickReplyButton)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::proto::HighlyStructuredMessage* displaytext_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class URLButton final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.URLButton) */ {
 public:
  inline URLButton() : URLButton(nullptr) {}
  ~URLButton() override;
  explicit PROTOBUF_CONSTEXPR URLButton(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  URLButton(const URLButton& from);
  URLButton(URLButton&& from) noexcept
    : URLButton() {
    *this = ::std::move(from);
  }

  inline URLButton& operator=(const URLButton& from) {
    CopyFrom(from);
    return *this;
  }
  inline URLButton& operator=(URLButton&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const URLButton& default_instance() {
    return *internal_default_instance();
  }
  static inline const URLButton* internal_default_instance() {
    return reinterpret_cast<const URLButton*>(
               &_URLButton_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(URLButton& a, URLButton& b) {
    a.Swap(&b);
  }
  inline void Swap(URLButton* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(URLButton* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  URLButton* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<URLButton>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const URLButton& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const URLButton& from) {
    URLButton::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(URLButton* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.URLButton";
  }
  protected:
  explicit URLButton(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayTextFieldNumber = 1,
    kUrlFieldNumber = 2,
  };
  // optional .proto.HighlyStructuredMessage displayText = 1;
  bool has_displaytext() const;
  private:
  bool _internal_has_displaytext() const;
  public:
  void clear_displaytext();
  const ::proto::HighlyStructuredMessage& displaytext() const;
  PROTOBUF_NODISCARD ::proto::HighlyStructuredMessage* release_displaytext();
  ::proto::HighlyStructuredMessage* mutable_displaytext();
  void set_allocated_displaytext(::proto::HighlyStructuredMessage* displaytext);
  private:
  const ::proto::HighlyStructuredMessage& _internal_displaytext() const;
  ::proto::HighlyStructuredMessage* _internal_mutable_displaytext();
  public:
  void unsafe_arena_set_allocated_displaytext(
      ::proto::HighlyStructuredMessage* displaytext);
  ::proto::HighlyStructuredMessage* unsafe_arena_release_displaytext();

  // optional .proto.HighlyStructuredMessage url = 2;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const ::proto::HighlyStructuredMessage& url() const;
  PROTOBUF_NODISCARD ::proto::HighlyStructuredMessage* release_url();
  ::proto::HighlyStructuredMessage* mutable_url();
  void set_allocated_url(::proto::HighlyStructuredMessage* url);
  private:
  const ::proto::HighlyStructuredMessage& _internal_url() const;
  ::proto::HighlyStructuredMessage* _internal_mutable_url();
  public:
  void unsafe_arena_set_allocated_url(
      ::proto::HighlyStructuredMessage* url);
  ::proto::HighlyStructuredMessage* unsafe_arena_release_url();

  // @@protoc_insertion_point(class_scope:proto.URLButton)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::proto::HighlyStructuredMessage* displaytext_;
    ::proto::HighlyStructuredMessage* url_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class CallButton final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.CallButton) */ {
 public:
  inline CallButton() : CallButton(nullptr) {}
  ~CallButton() override;
  explicit PROTOBUF_CONSTEXPR CallButton(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallButton(const CallButton& from);
  CallButton(CallButton&& from) noexcept
    : CallButton() {
    *this = ::std::move(from);
  }

  inline CallButton& operator=(const CallButton& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallButton& operator=(CallButton&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallButton& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallButton* internal_default_instance() {
    return reinterpret_cast<const CallButton*>(
               &_CallButton_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CallButton& a, CallButton& b) {
    a.Swap(&b);
  }
  inline void Swap(CallButton* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallButton* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallButton* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallButton>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallButton& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallButton& from) {
    CallButton::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallButton* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.CallButton";
  }
  protected:
  explicit CallButton(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayTextFieldNumber = 1,
    kPhoneNumberFieldNumber = 2,
  };
  // optional .proto.HighlyStructuredMessage displayText = 1;
  bool has_displaytext() const;
  private:
  bool _internal_has_displaytext() const;
  public:
  void clear_displaytext();
  const ::proto::HighlyStructuredMessage& displaytext() const;
  PROTOBUF_NODISCARD ::proto::HighlyStructuredMessage* release_displaytext();
  ::proto::HighlyStructuredMessage* mutable_displaytext();
  void set_allocated_displaytext(::proto::HighlyStructuredMessage* displaytext);
  private:
  const ::proto::HighlyStructuredMessage& _internal_displaytext() const;
  ::proto::HighlyStructuredMessage* _internal_mutable_displaytext();
  public:
  void unsafe_arena_set_allocated_displaytext(
      ::proto::HighlyStructuredMessage* displaytext);
  ::proto::HighlyStructuredMessage* unsafe_arena_release_displaytext();

  // optional .proto.HighlyStructuredMessage phoneNumber = 2;
  bool has_phonenumber() const;
  private:
  bool _internal_has_phonenumber() const;
  public:
  void clear_phonenumber();
  const ::proto::HighlyStructuredMessage& phonenumber() const;
  PROTOBUF_NODISCARD ::proto::HighlyStructuredMessage* release_phonenumber();
  ::proto::HighlyStructuredMessage* mutable_phonenumber();
  void set_allocated_phonenumber(::proto::HighlyStructuredMessage* phonenumber);
  private:
  const ::proto::HighlyStructuredMessage& _internal_phonenumber() const;
  ::proto::HighlyStructuredMessage* _internal_mutable_phonenumber();
  public:
  void unsafe_arena_set_allocated_phonenumber(
      ::proto::HighlyStructuredMessage* phonenumber);
  ::proto::HighlyStructuredMessage* unsafe_arena_release_phonenumber();

  // @@protoc_insertion_point(class_scope:proto.CallButton)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::proto::HighlyStructuredMessage* displaytext_;
    ::proto::HighlyStructuredMessage* phonenumber_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class TemplateButton final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.TemplateButton) */ {
 public:
  inline TemplateButton() : TemplateButton(nullptr) {}
  ~TemplateButton() override;
  explicit PROTOBUF_CONSTEXPR TemplateButton(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TemplateButton(const TemplateButton& from);
  TemplateButton(TemplateButton&& from) noexcept
    : TemplateButton() {
    *this = ::std::move(from);
  }

  inline TemplateButton& operator=(const TemplateButton& from) {
    CopyFrom(from);
    return *this;
  }
  inline TemplateButton& operator=(TemplateButton&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TemplateButton& default_instance() {
    return *internal_default_instance();
  }
  enum ButtonCase {
    kQuickReplyButton = 1,
    kUrlButton = 2,
    kCallButton = 3,
    BUTTON_NOT_SET = 0,
  };

  static inline const TemplateButton* internal_default_instance() {
    return reinterpret_cast<const TemplateButton*>(
               &_TemplateButton_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TemplateButton& a, TemplateButton& b) {
    a.Swap(&b);
  }
  inline void Swap(TemplateButton* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TemplateButton* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TemplateButton* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TemplateButton>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TemplateButton& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TemplateButton& from) {
    TemplateButton::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TemplateButton* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.TemplateButton";
  }
  protected:
  explicit TemplateButton(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 4,
    kQuickReplyButtonFieldNumber = 1,
    kUrlButtonFieldNumber = 2,
    kCallButtonFieldNumber = 3,
  };
  // optional uint32 index = 4;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // .proto.QuickReplyButton quickReplyButton = 1;
  bool has_quickreplybutton() const;
  private:
  bool _internal_has_quickreplybutton() const;
  public:
  void clear_quickreplybutton();
  const ::proto::QuickReplyButton& quickreplybutton() const;
  PROTOBUF_NODISCARD ::proto::QuickReplyButton* release_quickreplybutton();
  ::proto::QuickReplyButton* mutable_quickreplybutton();
  void set_allocated_quickreplybutton(::proto::QuickReplyButton* quickreplybutton);
  private:
  const ::proto::QuickReplyButton& _internal_quickreplybutton() const;
  ::proto::QuickReplyButton* _internal_mutable_quickreplybutton();
  public:
  void unsafe_arena_set_allocated_quickreplybutton(
      ::proto::QuickReplyButton* quickreplybutton);
  ::proto::QuickReplyButton* unsafe_arena_release_quickreplybutton();

  // .proto.URLButton urlButton = 2;
  bool has_urlbutton() const;
  private:
  bool _internal_has_urlbutton() const;
  public:
  void clear_urlbutton();
  const ::proto::URLButton& urlbutton() const;
  PROTOBUF_NODISCARD ::proto::URLButton* release_urlbutton();
  ::proto::URLButton* mutable_urlbutton();
  void set_allocated_urlbutton(::proto::URLButton* urlbutton);
  private:
  const ::proto::URLButton& _internal_urlbutton() const;
  ::proto::URLButton* _internal_mutable_urlbutton();
  public:
  void unsafe_arena_set_allocated_urlbutton(
      ::proto::URLButton* urlbutton);
  ::proto::URLButton* unsafe_arena_release_urlbutton();

  // .proto.CallButton callButton = 3;
  bool has_callbutton() const;
  private:
  bool _internal_has_callbutton() const;
  public:
  void clear_callbutton();
  const ::proto::CallButton& callbutton() const;
  PROTOBUF_NODISCARD ::proto::CallButton* release_callbutton();
  ::proto::CallButton* mutable_callbutton();
  void set_allocated_callbutton(::proto::CallButton* callbutton);
  private:
  const ::proto::CallButton& _internal_callbutton() const;
  ::proto::CallButton* _internal_mutable_callbutton();
  public:
  void unsafe_arena_set_allocated_callbutton(
      ::proto::CallButton* callbutton);
  ::proto::CallButton* unsafe_arena_release_callbutton();

  void clear_button();
  ButtonCase button_case() const;
  // @@protoc_insertion_point(class_scope:proto.TemplateButton)
 private:
  class _Internal;
  void set_has_quickreplybutton();
  void set_has_urlbutton();
  void set_has_callbutton();

  inline bool has_button() const;
  inline void clear_has_button();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t index_;
    union ButtonUnion {
      constexpr ButtonUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::proto::QuickReplyButton* quickreplybutton_;
      ::proto::URLButton* urlbutton_;
      ::proto::CallButton* callbutton_;
    } button_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class Location final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  ~Location() override;
  explicit PROTOBUF_CONSTEXPR Location(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Location(const Location& from);
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Location* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Location& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Location& from) {
    Location::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Location";
  }
  protected:
  explicit Location(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kDegreesLatitudeFieldNumber = 1,
    kDegreesLongitudeFieldNumber = 2,
  };
  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional double degreesLatitude = 1;
  bool has_degreeslatitude() const;
  private:
  bool _internal_has_degreeslatitude() const;
  public:
  void clear_degreeslatitude();
  double degreeslatitude() const;
  void set_degreeslatitude(double value);
  private:
  double _internal_degreeslatitude() const;
  void _internal_set_degreeslatitude(double value);
  public:

  // optional double degreesLongitude = 2;
  bool has_degreeslongitude() const;
  private:
  bool _internal_has_degreeslongitude() const;
  public:
  void clear_degreeslongitude();
  double degreeslongitude() const;
  void set_degreeslongitude(double value);
  private:
  double _internal_degreeslongitude() const;
  void _internal_set_degreeslongitude(double value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Location)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    double degreeslatitude_;
    double degreeslongitude_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class Point final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Point) */ {
 public:
  inline Point() : Point(nullptr) {}
  ~Point() override;
  explicit PROTOBUF_CONSTEXPR Point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Point& from) {
    Point::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Point";
  }
  protected:
  explicit Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXDeprecatedFieldNumber = 1,
    kYDeprecatedFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
  };
  // optional int32 xDeprecated = 1;
  bool has_xdeprecated() const;
  private:
  bool _internal_has_xdeprecated() const;
  public:
  void clear_xdeprecated();
  int32_t xdeprecated() const;
  void set_xdeprecated(int32_t value);
  private:
  int32_t _internal_xdeprecated() const;
  void _internal_set_xdeprecated(int32_t value);
  public:

  // optional int32 yDeprecated = 2;
  bool has_ydeprecated() const;
  private:
  bool _internal_has_ydeprecated() const;
  public:
  void clear_ydeprecated();
  int32_t ydeprecated() const;
  void set_ydeprecated(int32_t value);
  private:
  int32_t _internal_ydeprecated() const;
  void _internal_set_ydeprecated(int32_t value);
  public:

  // optional double x = 3;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // optional double y = 4;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t xdeprecated_;
    int32_t ydeprecated_;
    double x_;
    double y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class InteractiveAnnotation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.InteractiveAnnotation) */ {
 public:
  inline InteractiveAnnotation() : InteractiveAnnotation(nullptr) {}
  ~InteractiveAnnotation() override;
  explicit PROTOBUF_CONSTEXPR InteractiveAnnotation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InteractiveAnnotation(const InteractiveAnnotation& from);
  InteractiveAnnotation(InteractiveAnnotation&& from) noexcept
    : InteractiveAnnotation() {
    *this = ::std::move(from);
  }

  inline InteractiveAnnotation& operator=(const InteractiveAnnotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline InteractiveAnnotation& operator=(InteractiveAnnotation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InteractiveAnnotation& default_instance() {
    return *internal_default_instance();
  }
  enum ActionCase {
    kLocation = 2,
    ACTION_NOT_SET = 0,
  };

  static inline const InteractiveAnnotation* internal_default_instance() {
    return reinterpret_cast<const InteractiveAnnotation*>(
               &_InteractiveAnnotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(InteractiveAnnotation& a, InteractiveAnnotation& b) {
    a.Swap(&b);
  }
  inline void Swap(InteractiveAnnotation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InteractiveAnnotation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InteractiveAnnotation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InteractiveAnnotation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InteractiveAnnotation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InteractiveAnnotation& from) {
    InteractiveAnnotation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InteractiveAnnotation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.InteractiveAnnotation";
  }
  protected:
  explicit InteractiveAnnotation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolygonVerticesFieldNumber = 1,
    kLocationFieldNumber = 2,
  };
  // repeated .proto.Point polygonVertices = 1;
  int polygonvertices_size() const;
  private:
  int _internal_polygonvertices_size() const;
  public:
  void clear_polygonvertices();
  ::proto::Point* mutable_polygonvertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Point >*
      mutable_polygonvertices();
  private:
  const ::proto::Point& _internal_polygonvertices(int index) const;
  ::proto::Point* _internal_add_polygonvertices();
  public:
  const ::proto::Point& polygonvertices(int index) const;
  ::proto::Point* add_polygonvertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Point >&
      polygonvertices() const;

  // .proto.Location location = 2;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::proto::Location& location() const;
  PROTOBUF_NODISCARD ::proto::Location* release_location();
  ::proto::Location* mutable_location();
  void set_allocated_location(::proto::Location* location);
  private:
  const ::proto::Location& _internal_location() const;
  ::proto::Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::proto::Location* location);
  ::proto::Location* unsafe_arena_release_location();

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:proto.InteractiveAnnotation)
 private:
  class _Internal;
  void set_has_location();

  inline bool has_action() const;
  inline void clear_has_action();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Point > polygonvertices_;
    union ActionUnion {
      constexpr ActionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::proto::Location* location_;
    } action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class DeviceListMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.DeviceListMetadata) */ {
 public:
  inline DeviceListMetadata() : DeviceListMetadata(nullptr) {}
  ~DeviceListMetadata() override;
  explicit PROTOBUF_CONSTEXPR DeviceListMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceListMetadata(const DeviceListMetadata& from);
  DeviceListMetadata(DeviceListMetadata&& from) noexcept
    : DeviceListMetadata() {
    *this = ::std::move(from);
  }

  inline DeviceListMetadata& operator=(const DeviceListMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceListMetadata& operator=(DeviceListMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceListMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceListMetadata* internal_default_instance() {
    return reinterpret_cast<const DeviceListMetadata*>(
               &_DeviceListMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeviceListMetadata& a, DeviceListMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceListMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceListMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceListMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceListMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceListMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceListMetadata& from) {
    DeviceListMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceListMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.DeviceListMetadata";
  }
  protected:
  explicit DeviceListMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderKeyHashFieldNumber = 1,
    kRecipientKeyHashFieldNumber = 8,
    kSenderTimestampFieldNumber = 2,
    kRecipientTimestampFieldNumber = 9,
  };
  // optional bytes senderKeyHash = 1;
  bool has_senderkeyhash() const;
  private:
  bool _internal_has_senderkeyhash() const;
  public:
  void clear_senderkeyhash();
  const std::string& senderkeyhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_senderkeyhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_senderkeyhash();
  PROTOBUF_NODISCARD std::string* release_senderkeyhash();
  void set_allocated_senderkeyhash(std::string* senderkeyhash);
  private:
  const std::string& _internal_senderkeyhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_senderkeyhash(const std::string& value);
  std::string* _internal_mutable_senderkeyhash();
  public:

  // optional bytes recipientKeyHash = 8;
  bool has_recipientkeyhash() const;
  private:
  bool _internal_has_recipientkeyhash() const;
  public:
  void clear_recipientkeyhash();
  const std::string& recipientkeyhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recipientkeyhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recipientkeyhash();
  PROTOBUF_NODISCARD std::string* release_recipientkeyhash();
  void set_allocated_recipientkeyhash(std::string* recipientkeyhash);
  private:
  const std::string& _internal_recipientkeyhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipientkeyhash(const std::string& value);
  std::string* _internal_mutable_recipientkeyhash();
  public:

  // optional uint64 senderTimestamp = 2;
  bool has_sendertimestamp() const;
  private:
  bool _internal_has_sendertimestamp() const;
  public:
  void clear_sendertimestamp();
  uint64_t sendertimestamp() const;
  void set_sendertimestamp(uint64_t value);
  private:
  uint64_t _internal_sendertimestamp() const;
  void _internal_set_sendertimestamp(uint64_t value);
  public:

  // optional uint64 recipientTimestamp = 9;
  bool has_recipienttimestamp() const;
  private:
  bool _internal_has_recipienttimestamp() const;
  public:
  void clear_recipienttimestamp();
  uint64_t recipienttimestamp() const;
  void set_recipienttimestamp(uint64_t value);
  private:
  uint64_t _internal_recipienttimestamp() const;
  void _internal_set_recipienttimestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.DeviceListMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr senderkeyhash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipientkeyhash_;
    uint64_t sendertimestamp_;
    uint64_t recipienttimestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class MessageContextInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.MessageContextInfo) */ {
 public:
  inline MessageContextInfo() : MessageContextInfo(nullptr) {}
  ~MessageContextInfo() override;
  explicit PROTOBUF_CONSTEXPR MessageContextInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageContextInfo(const MessageContextInfo& from);
  MessageContextInfo(MessageContextInfo&& from) noexcept
    : MessageContextInfo() {
    *this = ::std::move(from);
  }

  inline MessageContextInfo& operator=(const MessageContextInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageContextInfo& operator=(MessageContextInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageContextInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageContextInfo* internal_default_instance() {
    return reinterpret_cast<const MessageContextInfo*>(
               &_MessageContextInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MessageContextInfo& a, MessageContextInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageContextInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageContextInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageContextInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageContextInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageContextInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageContextInfo& from) {
    MessageContextInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageContextInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.MessageContextInfo";
  }
  protected:
  explicit MessageContextInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceListMetadataFieldNumber = 1,
  };
  // optional .proto.DeviceListMetadata deviceListMetadata = 1;
  bool has_devicelistmetadata() const;
  private:
  bool _internal_has_devicelistmetadata() const;
  public:
  void clear_devicelistmetadata();
  const ::proto::DeviceListMetadata& devicelistmetadata() const;
  PROTOBUF_NODISCARD ::proto::DeviceListMetadata* release_devicelistmetadata();
  ::proto::DeviceListMetadata* mutable_devicelistmetadata();
  void set_allocated_devicelistmetadata(::proto::DeviceListMetadata* devicelistmetadata);
  private:
  const ::proto::DeviceListMetadata& _internal_devicelistmetadata() const;
  ::proto::DeviceListMetadata* _internal_mutable_devicelistmetadata();
  public:
  void unsafe_arena_set_allocated_devicelistmetadata(
      ::proto::DeviceListMetadata* devicelistmetadata);
  ::proto::DeviceListMetadata* unsafe_arena_release_devicelistmetadata();

  // @@protoc_insertion_point(class_scope:proto.MessageContextInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::proto::DeviceListMetadata* devicelistmetadata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class AdReplyInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.AdReplyInfo) */ {
 public:
  inline AdReplyInfo() : AdReplyInfo(nullptr) {}
  ~AdReplyInfo() override;
  explicit PROTOBUF_CONSTEXPR AdReplyInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdReplyInfo(const AdReplyInfo& from);
  AdReplyInfo(AdReplyInfo&& from) noexcept
    : AdReplyInfo() {
    *this = ::std::move(from);
  }

  inline AdReplyInfo& operator=(const AdReplyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdReplyInfo& operator=(AdReplyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdReplyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdReplyInfo* internal_default_instance() {
    return reinterpret_cast<const AdReplyInfo*>(
               &_AdReplyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AdReplyInfo& a, AdReplyInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AdReplyInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdReplyInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdReplyInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdReplyInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdReplyInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdReplyInfo& from) {
    AdReplyInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdReplyInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.AdReplyInfo";
  }
  protected:
  explicit AdReplyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AdReplyInfo_AdReplyInfoMediaType AdReplyInfoMediaType;
  static constexpr AdReplyInfoMediaType NONE =
    AdReplyInfo_AdReplyInfoMediaType_NONE;
  static constexpr AdReplyInfoMediaType IMAGE =
    AdReplyInfo_AdReplyInfoMediaType_IMAGE;
  static constexpr AdReplyInfoMediaType VIDEO =
    AdReplyInfo_AdReplyInfoMediaType_VIDEO;
  static inline bool AdReplyInfoMediaType_IsValid(int value) {
    return AdReplyInfo_AdReplyInfoMediaType_IsValid(value);
  }
  static constexpr AdReplyInfoMediaType AdReplyInfoMediaType_MIN =
    AdReplyInfo_AdReplyInfoMediaType_AdReplyInfoMediaType_MIN;
  static constexpr AdReplyInfoMediaType AdReplyInfoMediaType_MAX =
    AdReplyInfo_AdReplyInfoMediaType_AdReplyInfoMediaType_MAX;
  static constexpr int AdReplyInfoMediaType_ARRAYSIZE =
    AdReplyInfo_AdReplyInfoMediaType_AdReplyInfoMediaType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AdReplyInfoMediaType_descriptor() {
    return AdReplyInfo_AdReplyInfoMediaType_descriptor();
  }
  template<typename T>
  static inline const std::string& AdReplyInfoMediaType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AdReplyInfoMediaType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AdReplyInfoMediaType_Name.");
    return AdReplyInfo_AdReplyInfoMediaType_Name(enum_t_value);
  }
  static inline bool AdReplyInfoMediaType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AdReplyInfoMediaType* value) {
    return AdReplyInfo_AdReplyInfoMediaType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAdvertiserNameFieldNumber = 1,
    kJpegThumbnailFieldNumber = 16,
    kCaptionFieldNumber = 17,
    kMediaTypeFieldNumber = 2,
  };
  // optional string advertiserName = 1;
  bool has_advertisername() const;
  private:
  bool _internal_has_advertisername() const;
  public:
  void clear_advertisername();
  const std::string& advertisername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_advertisername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_advertisername();
  PROTOBUF_NODISCARD std::string* release_advertisername();
  void set_allocated_advertisername(std::string* advertisername);
  private:
  const std::string& _internal_advertisername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_advertisername(const std::string& value);
  std::string* _internal_mutable_advertisername();
  public:

  // optional bytes jpegThumbnail = 16;
  bool has_jpegthumbnail() const;
  private:
  bool _internal_has_jpegthumbnail() const;
  public:
  void clear_jpegthumbnail();
  const std::string& jpegthumbnail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jpegthumbnail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jpegthumbnail();
  PROTOBUF_NODISCARD std::string* release_jpegthumbnail();
  void set_allocated_jpegthumbnail(std::string* jpegthumbnail);
  private:
  const std::string& _internal_jpegthumbnail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jpegthumbnail(const std::string& value);
  std::string* _internal_mutable_jpegthumbnail();
  public:

  // optional string caption = 17;
  bool has_caption() const;
  private:
  bool _internal_has_caption() const;
  public:
  void clear_caption();
  const std::string& caption() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caption(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caption();
  PROTOBUF_NODISCARD std::string* release_caption();
  void set_allocated_caption(std::string* caption);
  private:
  const std::string& _internal_caption() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caption(const std::string& value);
  std::string* _internal_mutable_caption();
  public:

  // optional .proto.AdReplyInfo.AdReplyInfoMediaType mediaType = 2;
  bool has_mediatype() const;
  private:
  bool _internal_has_mediatype() const;
  public:
  void clear_mediatype();
  ::proto::AdReplyInfo_AdReplyInfoMediaType mediatype() const;
  void set_mediatype(::proto::AdReplyInfo_AdReplyInfoMediaType value);
  private:
  ::proto::AdReplyInfo_AdReplyInfoMediaType _internal_mediatype() const;
  void _internal_set_mediatype(::proto::AdReplyInfo_AdReplyInfoMediaType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.AdReplyInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr advertisername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jpegthumbnail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caption_;
    int mediatype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class ExternalAdReplyInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ExternalAdReplyInfo) */ {
 public:
  inline ExternalAdReplyInfo() : ExternalAdReplyInfo(nullptr) {}
  ~ExternalAdReplyInfo() override;
  explicit PROTOBUF_CONSTEXPR ExternalAdReplyInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExternalAdReplyInfo(const ExternalAdReplyInfo& from);
  ExternalAdReplyInfo(ExternalAdReplyInfo&& from) noexcept
    : ExternalAdReplyInfo() {
    *this = ::std::move(from);
  }

  inline ExternalAdReplyInfo& operator=(const ExternalAdReplyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalAdReplyInfo& operator=(ExternalAdReplyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExternalAdReplyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternalAdReplyInfo* internal_default_instance() {
    return reinterpret_cast<const ExternalAdReplyInfo*>(
               &_ExternalAdReplyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ExternalAdReplyInfo& a, ExternalAdReplyInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ExternalAdReplyInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalAdReplyInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExternalAdReplyInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExternalAdReplyInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExternalAdReplyInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExternalAdReplyInfo& from) {
    ExternalAdReplyInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExternalAdReplyInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ExternalAdReplyInfo";
  }
  protected:
  explicit ExternalAdReplyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ExternalAdReplyInfo_ExternalAdReplyInfoMediaType ExternalAdReplyInfoMediaType;
  static constexpr ExternalAdReplyInfoMediaType NONE =
    ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_NONE;
  static constexpr ExternalAdReplyInfoMediaType IMAGE =
    ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_IMAGE;
  static constexpr ExternalAdReplyInfoMediaType VIDEO =
    ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_VIDEO;
  static inline bool ExternalAdReplyInfoMediaType_IsValid(int value) {
    return ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_IsValid(value);
  }
  static constexpr ExternalAdReplyInfoMediaType ExternalAdReplyInfoMediaType_MIN =
    ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_ExternalAdReplyInfoMediaType_MIN;
  static constexpr ExternalAdReplyInfoMediaType ExternalAdReplyInfoMediaType_MAX =
    ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_ExternalAdReplyInfoMediaType_MAX;
  static constexpr int ExternalAdReplyInfoMediaType_ARRAYSIZE =
    ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_ExternalAdReplyInfoMediaType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ExternalAdReplyInfoMediaType_descriptor() {
    return ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_descriptor();
  }
  template<typename T>
  static inline const std::string& ExternalAdReplyInfoMediaType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ExternalAdReplyInfoMediaType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ExternalAdReplyInfoMediaType_Name.");
    return ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_Name(enum_t_value);
  }
  static inline bool ExternalAdReplyInfoMediaType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ExternalAdReplyInfoMediaType* value) {
    return ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kBodyFieldNumber = 2,
    kThumbnailUrlFieldNumber = 4,
    kMediaUrlFieldNumber = 5,
    kThumbnailFieldNumber = 6,
    kSourceTypeFieldNumber = 7,
    kSourceIdFieldNumber = 8,
    kSourceUrlFieldNumber = 9,
    kMediaTypeFieldNumber = 3,
  };
  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string body = 2;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // optional string thumbnailUrl = 4;
  bool has_thumbnailurl() const;
  private:
  bool _internal_has_thumbnailurl() const;
  public:
  void clear_thumbnailurl();
  const std::string& thumbnailurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnailurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnailurl();
  PROTOBUF_NODISCARD std::string* release_thumbnailurl();
  void set_allocated_thumbnailurl(std::string* thumbnailurl);
  private:
  const std::string& _internal_thumbnailurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnailurl(const std::string& value);
  std::string* _internal_mutable_thumbnailurl();
  public:

  // optional string mediaUrl = 5;
  bool has_mediaurl() const;
  private:
  bool _internal_has_mediaurl() const;
  public:
  void clear_mediaurl();
  const std::string& mediaurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mediaurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mediaurl();
  PROTOBUF_NODISCARD std::string* release_mediaurl();
  void set_allocated_mediaurl(std::string* mediaurl);
  private:
  const std::string& _internal_mediaurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mediaurl(const std::string& value);
  std::string* _internal_mutable_mediaurl();
  public:

  // optional bytes thumbnail = 6;
  bool has_thumbnail() const;
  private:
  bool _internal_has_thumbnail() const;
  public:
  void clear_thumbnail();
  const std::string& thumbnail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnail();
  PROTOBUF_NODISCARD std::string* release_thumbnail();
  void set_allocated_thumbnail(std::string* thumbnail);
  private:
  const std::string& _internal_thumbnail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnail(const std::string& value);
  std::string* _internal_mutable_thumbnail();
  public:

  // optional string sourceType = 7;
  bool has_sourcetype() const;
  private:
  bool _internal_has_sourcetype() const;
  public:
  void clear_sourcetype();
  const std::string& sourcetype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcetype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcetype();
  PROTOBUF_NODISCARD std::string* release_sourcetype();
  void set_allocated_sourcetype(std::string* sourcetype);
  private:
  const std::string& _internal_sourcetype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcetype(const std::string& value);
  std::string* _internal_mutable_sourcetype();
  public:

  // optional string sourceId = 8;
  bool has_sourceid() const;
  private:
  bool _internal_has_sourceid() const;
  public:
  void clear_sourceid();
  const std::string& sourceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourceid();
  PROTOBUF_NODISCARD std::string* release_sourceid();
  void set_allocated_sourceid(std::string* sourceid);
  private:
  const std::string& _internal_sourceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourceid(const std::string& value);
  std::string* _internal_mutable_sourceid();
  public:

  // optional string sourceUrl = 9;
  bool has_sourceurl() const;
  private:
  bool _internal_has_sourceurl() const;
  public:
  void clear_sourceurl();
  const std::string& sourceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourceurl();
  PROTOBUF_NODISCARD std::string* release_sourceurl();
  void set_allocated_sourceurl(std::string* sourceurl);
  private:
  const std::string& _internal_sourceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourceurl(const std::string& value);
  std::string* _internal_mutable_sourceurl();
  public:

  // optional .proto.ExternalAdReplyInfo.ExternalAdReplyInfoMediaType mediaType = 3;
  bool has_mediatype() const;
  private:
  bool _internal_has_mediatype() const;
  public:
  void clear_mediatype();
  ::proto::ExternalAdReplyInfo_ExternalAdReplyInfoMediaType mediatype() const;
  void set_mediatype(::proto::ExternalAdReplyInfo_ExternalAdReplyInfoMediaType value);
  private:
  ::proto::ExternalAdReplyInfo_ExternalAdReplyInfoMediaType _internal_mediatype() const;
  void _internal_set_mediatype(::proto::ExternalAdReplyInfo_ExternalAdReplyInfoMediaType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ExternalAdReplyInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnailurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mediaurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcetype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceurl_;
    int mediatype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class ContextInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ContextInfo) */ {
 public:
  inline ContextInfo() : ContextInfo(nullptr) {}
  ~ContextInfo() override;
  explicit PROTOBUF_CONSTEXPR ContextInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContextInfo(const ContextInfo& from);
  ContextInfo(ContextInfo&& from) noexcept
    : ContextInfo() {
    *this = ::std::move(from);
  }

  inline ContextInfo& operator=(const ContextInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContextInfo& operator=(ContextInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContextInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContextInfo* internal_default_instance() {
    return reinterpret_cast<const ContextInfo*>(
               &_ContextInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ContextInfo& a, ContextInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ContextInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContextInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContextInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContextInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContextInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContextInfo& from) {
    ContextInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContextInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ContextInfo";
  }
  protected:
  explicit ContextInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMentionedJidFieldNumber = 15,
    kStanzaIdFieldNumber = 1,
    kParticipantFieldNumber = 2,
    kRemoteJidFieldNumber = 4,
    kConversionSourceFieldNumber = 18,
    kConversionDataFieldNumber = 19,
    kEphemeralSharedSecretFieldNumber = 27,
    kQuotedMessageFieldNumber = 3,
    kQuotedAdFieldNumber = 23,
    kPlaceholderKeyFieldNumber = 24,
    kExternalAdReplyFieldNumber = 28,
    kConversionDelaySecondsFieldNumber = 20,
    kForwardingScoreFieldNumber = 21,
    kIsForwardedFieldNumber = 22,
    kExpirationFieldNumber = 25,
    kEphemeralSettingTimestampFieldNumber = 26,
  };
  // repeated string mentionedJid = 15;
  int mentionedjid_size() const;
  private:
  int _internal_mentionedjid_size() const;
  public:
  void clear_mentionedjid();
  const std::string& mentionedjid(int index) const;
  std::string* mutable_mentionedjid(int index);
  void set_mentionedjid(int index, const std::string& value);
  void set_mentionedjid(int index, std::string&& value);
  void set_mentionedjid(int index, const char* value);
  void set_mentionedjid(int index, const char* value, size_t size);
  std::string* add_mentionedjid();
  void add_mentionedjid(const std::string& value);
  void add_mentionedjid(std::string&& value);
  void add_mentionedjid(const char* value);
  void add_mentionedjid(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& mentionedjid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_mentionedjid();
  private:
  const std::string& _internal_mentionedjid(int index) const;
  std::string* _internal_add_mentionedjid();
  public:

  // optional string stanzaId = 1;
  bool has_stanzaid() const;
  private:
  bool _internal_has_stanzaid() const;
  public:
  void clear_stanzaid();
  const std::string& stanzaid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stanzaid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stanzaid();
  PROTOBUF_NODISCARD std::string* release_stanzaid();
  void set_allocated_stanzaid(std::string* stanzaid);
  private:
  const std::string& _internal_stanzaid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stanzaid(const std::string& value);
  std::string* _internal_mutable_stanzaid();
  public:

  // optional string participant = 2;
  bool has_participant() const;
  private:
  bool _internal_has_participant() const;
  public:
  void clear_participant();
  const std::string& participant() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant();
  PROTOBUF_NODISCARD std::string* release_participant();
  void set_allocated_participant(std::string* participant);
  private:
  const std::string& _internal_participant() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant(const std::string& value);
  std::string* _internal_mutable_participant();
  public:

  // optional string remoteJid = 4;
  bool has_remotejid() const;
  private:
  bool _internal_has_remotejid() const;
  public:
  void clear_remotejid();
  const std::string& remotejid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remotejid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remotejid();
  PROTOBUF_NODISCARD std::string* release_remotejid();
  void set_allocated_remotejid(std::string* remotejid);
  private:
  const std::string& _internal_remotejid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remotejid(const std::string& value);
  std::string* _internal_mutable_remotejid();
  public:

  // optional string conversionSource = 18;
  bool has_conversionsource() const;
  private:
  bool _internal_has_conversionsource() const;
  public:
  void clear_conversionsource();
  const std::string& conversionsource() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversionsource(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversionsource();
  PROTOBUF_NODISCARD std::string* release_conversionsource();
  void set_allocated_conversionsource(std::string* conversionsource);
  private:
  const std::string& _internal_conversionsource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversionsource(const std::string& value);
  std::string* _internal_mutable_conversionsource();
  public:

  // optional bytes conversionData = 19;
  bool has_conversiondata() const;
  private:
  bool _internal_has_conversiondata() const;
  public:
  void clear_conversiondata();
  const std::string& conversiondata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversiondata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversiondata();
  PROTOBUF_NODISCARD std::string* release_conversiondata();
  void set_allocated_conversiondata(std::string* conversiondata);
  private:
  const std::string& _internal_conversiondata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversiondata(const std::string& value);
  std::string* _internal_mutable_conversiondata();
  public:

  // optional bytes ephemeralSharedSecret = 27;
  bool has_ephemeralsharedsecret() const;
  private:
  bool _internal_has_ephemeralsharedsecret() const;
  public:
  void clear_ephemeralsharedsecret();
  const std::string& ephemeralsharedsecret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ephemeralsharedsecret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ephemeralsharedsecret();
  PROTOBUF_NODISCARD std::string* release_ephemeralsharedsecret();
  void set_allocated_ephemeralsharedsecret(std::string* ephemeralsharedsecret);
  private:
  const std::string& _internal_ephemeralsharedsecret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ephemeralsharedsecret(const std::string& value);
  std::string* _internal_mutable_ephemeralsharedsecret();
  public:

  // optional .proto.Message quotedMessage = 3;
  bool has_quotedmessage() const;
  private:
  bool _internal_has_quotedmessage() const;
  public:
  void clear_quotedmessage();
  const ::proto::Message& quotedmessage() const;
  PROTOBUF_NODISCARD ::proto::Message* release_quotedmessage();
  ::proto::Message* mutable_quotedmessage();
  void set_allocated_quotedmessage(::proto::Message* quotedmessage);
  private:
  const ::proto::Message& _internal_quotedmessage() const;
  ::proto::Message* _internal_mutable_quotedmessage();
  public:
  void unsafe_arena_set_allocated_quotedmessage(
      ::proto::Message* quotedmessage);
  ::proto::Message* unsafe_arena_release_quotedmessage();

  // optional .proto.AdReplyInfo quotedAd = 23;
  bool has_quotedad() const;
  private:
  bool _internal_has_quotedad() const;
  public:
  void clear_quotedad();
  const ::proto::AdReplyInfo& quotedad() const;
  PROTOBUF_NODISCARD ::proto::AdReplyInfo* release_quotedad();
  ::proto::AdReplyInfo* mutable_quotedad();
  void set_allocated_quotedad(::proto::AdReplyInfo* quotedad);
  private:
  const ::proto::AdReplyInfo& _internal_quotedad() const;
  ::proto::AdReplyInfo* _internal_mutable_quotedad();
  public:
  void unsafe_arena_set_allocated_quotedad(
      ::proto::AdReplyInfo* quotedad);
  ::proto::AdReplyInfo* unsafe_arena_release_quotedad();

  // optional .proto.MessageKey placeholderKey = 24;
  bool has_placeholderkey() const;
  private:
  bool _internal_has_placeholderkey() const;
  public:
  void clear_placeholderkey();
  const ::proto::MessageKey& placeholderkey() const;
  PROTOBUF_NODISCARD ::proto::MessageKey* release_placeholderkey();
  ::proto::MessageKey* mutable_placeholderkey();
  void set_allocated_placeholderkey(::proto::MessageKey* placeholderkey);
  private:
  const ::proto::MessageKey& _internal_placeholderkey() const;
  ::proto::MessageKey* _internal_mutable_placeholderkey();
  public:
  void unsafe_arena_set_allocated_placeholderkey(
      ::proto::MessageKey* placeholderkey);
  ::proto::MessageKey* unsafe_arena_release_placeholderkey();

  // optional .proto.ExternalAdReplyInfo externalAdReply = 28;
  bool has_externaladreply() const;
  private:
  bool _internal_has_externaladreply() const;
  public:
  void clear_externaladreply();
  const ::proto::ExternalAdReplyInfo& externaladreply() const;
  PROTOBUF_NODISCARD ::proto::ExternalAdReplyInfo* release_externaladreply();
  ::proto::ExternalAdReplyInfo* mutable_externaladreply();
  void set_allocated_externaladreply(::proto::ExternalAdReplyInfo* externaladreply);
  private:
  const ::proto::ExternalAdReplyInfo& _internal_externaladreply() const;
  ::proto::ExternalAdReplyInfo* _internal_mutable_externaladreply();
  public:
  void unsafe_arena_set_allocated_externaladreply(
      ::proto::ExternalAdReplyInfo* externaladreply);
  ::proto::ExternalAdReplyInfo* unsafe_arena_release_externaladreply();

  // optional uint32 conversionDelaySeconds = 20;
  bool has_conversiondelayseconds() const;
  private:
  bool _internal_has_conversiondelayseconds() const;
  public:
  void clear_conversiondelayseconds();
  uint32_t conversiondelayseconds() const;
  void set_conversiondelayseconds(uint32_t value);
  private:
  uint32_t _internal_conversiondelayseconds() const;
  void _internal_set_conversiondelayseconds(uint32_t value);
  public:

  // optional uint32 forwardingScore = 21;
  bool has_forwardingscore() const;
  private:
  bool _internal_has_forwardingscore() const;
  public:
  void clear_forwardingscore();
  uint32_t forwardingscore() const;
  void set_forwardingscore(uint32_t value);
  private:
  uint32_t _internal_forwardingscore() const;
  void _internal_set_forwardingscore(uint32_t value);
  public:

  // optional bool isForwarded = 22;
  bool has_isforwarded() const;
  private:
  bool _internal_has_isforwarded() const;
  public:
  void clear_isforwarded();
  bool isforwarded() const;
  void set_isforwarded(bool value);
  private:
  bool _internal_isforwarded() const;
  void _internal_set_isforwarded(bool value);
  public:

  // optional uint32 expiration = 25;
  bool has_expiration() const;
  private:
  bool _internal_has_expiration() const;
  public:
  void clear_expiration();
  uint32_t expiration() const;
  void set_expiration(uint32_t value);
  private:
  uint32_t _internal_expiration() const;
  void _internal_set_expiration(uint32_t value);
  public:

  // optional int64 ephemeralSettingTimestamp = 26;
  bool has_ephemeralsettingtimestamp() const;
  private:
  bool _internal_has_ephemeralsettingtimestamp() const;
  public:
  void clear_ephemeralsettingtimestamp();
  int64_t ephemeralsettingtimestamp() const;
  void set_ephemeralsettingtimestamp(int64_t value);
  private:
  int64_t _internal_ephemeralsettingtimestamp() const;
  void _internal_set_ephemeralsettingtimestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ContextInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> mentionedjid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stanzaid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remotejid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversionsource_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversiondata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ephemeralsharedsecret_;
    ::proto::Message* quotedmessage_;
    ::proto::AdReplyInfo* quotedad_;
    ::proto::MessageKey* placeholderkey_;
    ::proto::ExternalAdReplyInfo* externaladreply_;
    uint32_t conversiondelayseconds_;
    uint32_t forwardingscore_;
    bool isforwarded_;
    uint32_t expiration_;
    int64_t ephemeralsettingtimestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class SenderKeyDistributionMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.SenderKeyDistributionMessage) */ {
 public:
  inline SenderKeyDistributionMessage() : SenderKeyDistributionMessage(nullptr) {}
  ~SenderKeyDistributionMessage() override;
  explicit PROTOBUF_CONSTEXPR SenderKeyDistributionMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SenderKeyDistributionMessage(const SenderKeyDistributionMessage& from);
  SenderKeyDistributionMessage(SenderKeyDistributionMessage&& from) noexcept
    : SenderKeyDistributionMessage() {
    *this = ::std::move(from);
  }

  inline SenderKeyDistributionMessage& operator=(const SenderKeyDistributionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SenderKeyDistributionMessage& operator=(SenderKeyDistributionMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SenderKeyDistributionMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SenderKeyDistributionMessage* internal_default_instance() {
    return reinterpret_cast<const SenderKeyDistributionMessage*>(
               &_SenderKeyDistributionMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SenderKeyDistributionMessage& a, SenderKeyDistributionMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SenderKeyDistributionMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SenderKeyDistributionMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SenderKeyDistributionMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SenderKeyDistributionMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SenderKeyDistributionMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SenderKeyDistributionMessage& from) {
    SenderKeyDistributionMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SenderKeyDistributionMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SenderKeyDistributionMessage";
  }
  protected:
  explicit SenderKeyDistributionMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupIdFieldNumber = 1,
    kAxolotlSenderKeyDistributionMessageFieldNumber = 2,
  };
  // optional string groupId = 1;
  bool has_groupid() const;
  private:
  bool _internal_has_groupid() const;
  public:
  void clear_groupid();
  const std::string& groupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* groupid);
  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(const std::string& value);
  std::string* _internal_mutable_groupid();
  public:

  // optional bytes axolotlSenderKeyDistributionMessage = 2;
  bool has_axolotlsenderkeydistributionmessage() const;
  private:
  bool _internal_has_axolotlsenderkeydistributionmessage() const;
  public:
  void clear_axolotlsenderkeydistributionmessage();
  const std::string& axolotlsenderkeydistributionmessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_axolotlsenderkeydistributionmessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_axolotlsenderkeydistributionmessage();
  PROTOBUF_NODISCARD std::string* release_axolotlsenderkeydistributionmessage();
  void set_allocated_axolotlsenderkeydistributionmessage(std::string* axolotlsenderkeydistributionmessage);
  private:
  const std::string& _internal_axolotlsenderkeydistributionmessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_axolotlsenderkeydistributionmessage(const std::string& value);
  std::string* _internal_mutable_axolotlsenderkeydistributionmessage();
  public:

  // @@protoc_insertion_point(class_scope:proto.SenderKeyDistributionMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr axolotlsenderkeydistributionmessage_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class ImageMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ImageMessage) */ {
 public:
  inline ImageMessage() : ImageMessage(nullptr) {}
  ~ImageMessage() override;
  explicit PROTOBUF_CONSTEXPR ImageMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageMessage(const ImageMessage& from);
  ImageMessage(ImageMessage&& from) noexcept
    : ImageMessage() {
    *this = ::std::move(from);
  }

  inline ImageMessage& operator=(const ImageMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageMessage& operator=(ImageMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageMessage* internal_default_instance() {
    return reinterpret_cast<const ImageMessage*>(
               &_ImageMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ImageMessage& a, ImageMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageMessage& from) {
    ImageMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ImageMessage";
  }
  protected:
  explicit ImageMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInteractiveAnnotationsFieldNumber = 10,
    kScanLengthsFieldNumber = 22,
    kUrlFieldNumber = 1,
    kMimetypeFieldNumber = 2,
    kCaptionFieldNumber = 3,
    kFileSha256FieldNumber = 4,
    kMediaKeyFieldNumber = 8,
    kFileEncSha256FieldNumber = 9,
    kDirectPathFieldNumber = 11,
    kJpegThumbnailFieldNumber = 16,
    kFirstScanSidecarFieldNumber = 18,
    kScansSidecarFieldNumber = 21,
    kMidQualityFileSha256FieldNumber = 23,
    kMidQualityFileEncSha256FieldNumber = 24,
    kThumbnailDirectPathFieldNumber = 26,
    kThumbnailSha256FieldNumber = 27,
    kThumbnailEncSha256FieldNumber = 28,
    kContextInfoFieldNumber = 17,
    kFileLengthFieldNumber = 5,
    kHeightFieldNumber = 6,
    kWidthFieldNumber = 7,
    kMediaKeyTimestampFieldNumber = 12,
    kFirstScanLengthFieldNumber = 19,
    kExperimentGroupIdFieldNumber = 20,
    kViewOnceFieldNumber = 25,
  };
  // repeated .proto.InteractiveAnnotation interactiveAnnotations = 10;
  int interactiveannotations_size() const;
  private:
  int _internal_interactiveannotations_size() const;
  public:
  void clear_interactiveannotations();
  ::proto::InteractiveAnnotation* mutable_interactiveannotations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::InteractiveAnnotation >*
      mutable_interactiveannotations();
  private:
  const ::proto::InteractiveAnnotation& _internal_interactiveannotations(int index) const;
  ::proto::InteractiveAnnotation* _internal_add_interactiveannotations();
  public:
  const ::proto::InteractiveAnnotation& interactiveannotations(int index) const;
  ::proto::InteractiveAnnotation* add_interactiveannotations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::InteractiveAnnotation >&
      interactiveannotations() const;

  // repeated uint32 scanLengths = 22;
  int scanlengths_size() const;
  private:
  int _internal_scanlengths_size() const;
  public:
  void clear_scanlengths();
  private:
  uint32_t _internal_scanlengths(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_scanlengths() const;
  void _internal_add_scanlengths(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_scanlengths();
  public:
  uint32_t scanlengths(int index) const;
  void set_scanlengths(int index, uint32_t value);
  void add_scanlengths(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      scanlengths() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_scanlengths();

  // optional string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string mimetype = 2;
  bool has_mimetype() const;
  private:
  bool _internal_has_mimetype() const;
  public:
  void clear_mimetype();
  const std::string& mimetype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mimetype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mimetype();
  PROTOBUF_NODISCARD std::string* release_mimetype();
  void set_allocated_mimetype(std::string* mimetype);
  private:
  const std::string& _internal_mimetype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mimetype(const std::string& value);
  std::string* _internal_mutable_mimetype();
  public:

  // optional string caption = 3;
  bool has_caption() const;
  private:
  bool _internal_has_caption() const;
  public:
  void clear_caption();
  const std::string& caption() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caption(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caption();
  PROTOBUF_NODISCARD std::string* release_caption();
  void set_allocated_caption(std::string* caption);
  private:
  const std::string& _internal_caption() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caption(const std::string& value);
  std::string* _internal_mutable_caption();
  public:

  // optional bytes fileSha256 = 4;
  bool has_filesha256() const;
  private:
  bool _internal_has_filesha256() const;
  public:
  void clear_filesha256();
  const std::string& filesha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filesha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filesha256();
  PROTOBUF_NODISCARD std::string* release_filesha256();
  void set_allocated_filesha256(std::string* filesha256);
  private:
  const std::string& _internal_filesha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filesha256(const std::string& value);
  std::string* _internal_mutable_filesha256();
  public:

  // optional bytes mediaKey = 8;
  bool has_mediakey() const;
  private:
  bool _internal_has_mediakey() const;
  public:
  void clear_mediakey();
  const std::string& mediakey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mediakey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mediakey();
  PROTOBUF_NODISCARD std::string* release_mediakey();
  void set_allocated_mediakey(std::string* mediakey);
  private:
  const std::string& _internal_mediakey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mediakey(const std::string& value);
  std::string* _internal_mutable_mediakey();
  public:

  // optional bytes fileEncSha256 = 9;
  bool has_fileencsha256() const;
  private:
  bool _internal_has_fileencsha256() const;
  public:
  void clear_fileencsha256();
  const std::string& fileencsha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fileencsha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fileencsha256();
  PROTOBUF_NODISCARD std::string* release_fileencsha256();
  void set_allocated_fileencsha256(std::string* fileencsha256);
  private:
  const std::string& _internal_fileencsha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fileencsha256(const std::string& value);
  std::string* _internal_mutable_fileencsha256();
  public:

  // optional string directPath = 11;
  bool has_directpath() const;
  private:
  bool _internal_has_directpath() const;
  public:
  void clear_directpath();
  const std::string& directpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_directpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_directpath();
  PROTOBUF_NODISCARD std::string* release_directpath();
  void set_allocated_directpath(std::string* directpath);
  private:
  const std::string& _internal_directpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_directpath(const std::string& value);
  std::string* _internal_mutable_directpath();
  public:

  // optional bytes jpegThumbnail = 16;
  bool has_jpegthumbnail() const;
  private:
  bool _internal_has_jpegthumbnail() const;
  public:
  void clear_jpegthumbnail();
  const std::string& jpegthumbnail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jpegthumbnail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jpegthumbnail();
  PROTOBUF_NODISCARD std::string* release_jpegthumbnail();
  void set_allocated_jpegthumbnail(std::string* jpegthumbnail);
  private:
  const std::string& _internal_jpegthumbnail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jpegthumbnail(const std::string& value);
  std::string* _internal_mutable_jpegthumbnail();
  public:

  // optional bytes firstScanSidecar = 18;
  bool has_firstscansidecar() const;
  private:
  bool _internal_has_firstscansidecar() const;
  public:
  void clear_firstscansidecar();
  const std::string& firstscansidecar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_firstscansidecar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_firstscansidecar();
  PROTOBUF_NODISCARD std::string* release_firstscansidecar();
  void set_allocated_firstscansidecar(std::string* firstscansidecar);
  private:
  const std::string& _internal_firstscansidecar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_firstscansidecar(const std::string& value);
  std::string* _internal_mutable_firstscansidecar();
  public:

  // optional bytes scansSidecar = 21;
  bool has_scanssidecar() const;
  private:
  bool _internal_has_scanssidecar() const;
  public:
  void clear_scanssidecar();
  const std::string& scanssidecar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scanssidecar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scanssidecar();
  PROTOBUF_NODISCARD std::string* release_scanssidecar();
  void set_allocated_scanssidecar(std::string* scanssidecar);
  private:
  const std::string& _internal_scanssidecar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scanssidecar(const std::string& value);
  std::string* _internal_mutable_scanssidecar();
  public:

  // optional bytes midQualityFileSha256 = 23;
  bool has_midqualityfilesha256() const;
  private:
  bool _internal_has_midqualityfilesha256() const;
  public:
  void clear_midqualityfilesha256();
  const std::string& midqualityfilesha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_midqualityfilesha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_midqualityfilesha256();
  PROTOBUF_NODISCARD std::string* release_midqualityfilesha256();
  void set_allocated_midqualityfilesha256(std::string* midqualityfilesha256);
  private:
  const std::string& _internal_midqualityfilesha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_midqualityfilesha256(const std::string& value);
  std::string* _internal_mutable_midqualityfilesha256();
  public:

  // optional bytes midQualityFileEncSha256 = 24;
  bool has_midqualityfileencsha256() const;
  private:
  bool _internal_has_midqualityfileencsha256() const;
  public:
  void clear_midqualityfileencsha256();
  const std::string& midqualityfileencsha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_midqualityfileencsha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_midqualityfileencsha256();
  PROTOBUF_NODISCARD std::string* release_midqualityfileencsha256();
  void set_allocated_midqualityfileencsha256(std::string* midqualityfileencsha256);
  private:
  const std::string& _internal_midqualityfileencsha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_midqualityfileencsha256(const std::string& value);
  std::string* _internal_mutable_midqualityfileencsha256();
  public:

  // optional string thumbnailDirectPath = 26;
  bool has_thumbnaildirectpath() const;
  private:
  bool _internal_has_thumbnaildirectpath() const;
  public:
  void clear_thumbnaildirectpath();
  const std::string& thumbnaildirectpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnaildirectpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnaildirectpath();
  PROTOBUF_NODISCARD std::string* release_thumbnaildirectpath();
  void set_allocated_thumbnaildirectpath(std::string* thumbnaildirectpath);
  private:
  const std::string& _internal_thumbnaildirectpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnaildirectpath(const std::string& value);
  std::string* _internal_mutable_thumbnaildirectpath();
  public:

  // optional bytes thumbnailSha256 = 27;
  bool has_thumbnailsha256() const;
  private:
  bool _internal_has_thumbnailsha256() const;
  public:
  void clear_thumbnailsha256();
  const std::string& thumbnailsha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnailsha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnailsha256();
  PROTOBUF_NODISCARD std::string* release_thumbnailsha256();
  void set_allocated_thumbnailsha256(std::string* thumbnailsha256);
  private:
  const std::string& _internal_thumbnailsha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnailsha256(const std::string& value);
  std::string* _internal_mutable_thumbnailsha256();
  public:

  // optional bytes thumbnailEncSha256 = 28;
  bool has_thumbnailencsha256() const;
  private:
  bool _internal_has_thumbnailencsha256() const;
  public:
  void clear_thumbnailencsha256();
  const std::string& thumbnailencsha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnailencsha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnailencsha256();
  PROTOBUF_NODISCARD std::string* release_thumbnailencsha256();
  void set_allocated_thumbnailencsha256(std::string* thumbnailencsha256);
  private:
  const std::string& _internal_thumbnailencsha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnailencsha256(const std::string& value);
  std::string* _internal_mutable_thumbnailencsha256();
  public:

  // optional .proto.ContextInfo contextInfo = 17;
  bool has_contextinfo() const;
  private:
  bool _internal_has_contextinfo() const;
  public:
  void clear_contextinfo();
  const ::proto::ContextInfo& contextinfo() const;
  PROTOBUF_NODISCARD ::proto::ContextInfo* release_contextinfo();
  ::proto::ContextInfo* mutable_contextinfo();
  void set_allocated_contextinfo(::proto::ContextInfo* contextinfo);
  private:
  const ::proto::ContextInfo& _internal_contextinfo() const;
  ::proto::ContextInfo* _internal_mutable_contextinfo();
  public:
  void unsafe_arena_set_allocated_contextinfo(
      ::proto::ContextInfo* contextinfo);
  ::proto::ContextInfo* unsafe_arena_release_contextinfo();

  // optional uint64 fileLength = 5;
  bool has_filelength() const;
  private:
  bool _internal_has_filelength() const;
  public:
  void clear_filelength();
  uint64_t filelength() const;
  void set_filelength(uint64_t value);
  private:
  uint64_t _internal_filelength() const;
  void _internal_set_filelength(uint64_t value);
  public:

  // optional uint32 height = 6;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // optional uint32 width = 7;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // optional int64 mediaKeyTimestamp = 12;
  bool has_mediakeytimestamp() const;
  private:
  bool _internal_has_mediakeytimestamp() const;
  public:
  void clear_mediakeytimestamp();
  int64_t mediakeytimestamp() const;
  void set_mediakeytimestamp(int64_t value);
  private:
  int64_t _internal_mediakeytimestamp() const;
  void _internal_set_mediakeytimestamp(int64_t value);
  public:

  // optional uint32 firstScanLength = 19;
  bool has_firstscanlength() const;
  private:
  bool _internal_has_firstscanlength() const;
  public:
  void clear_firstscanlength();
  uint32_t firstscanlength() const;
  void set_firstscanlength(uint32_t value);
  private:
  uint32_t _internal_firstscanlength() const;
  void _internal_set_firstscanlength(uint32_t value);
  public:

  // optional uint32 experimentGroupId = 20;
  bool has_experimentgroupid() const;
  private:
  bool _internal_has_experimentgroupid() const;
  public:
  void clear_experimentgroupid();
  uint32_t experimentgroupid() const;
  void set_experimentgroupid(uint32_t value);
  private:
  uint32_t _internal_experimentgroupid() const;
  void _internal_set_experimentgroupid(uint32_t value);
  public:

  // optional bool viewOnce = 25;
  bool has_viewonce() const;
  private:
  bool _internal_has_viewonce() const;
  public:
  void clear_viewonce();
  bool viewonce() const;
  void set_viewonce(bool value);
  private:
  bool _internal_viewonce() const;
  void _internal_set_viewonce(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ImageMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::InteractiveAnnotation > interactiveannotations_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > scanlengths_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mimetype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caption_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filesha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mediakey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fileencsha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directpath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jpegthumbnail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr firstscansidecar_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scanssidecar_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr midqualityfilesha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr midqualityfileencsha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnaildirectpath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnailsha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnailencsha256_;
    ::proto::ContextInfo* contextinfo_;
    uint64_t filelength_;
    uint32_t height_;
    uint32_t width_;
    int64_t mediakeytimestamp_;
    uint32_t firstscanlength_;
    uint32_t experimentgroupid_;
    bool viewonce_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class InvoiceMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.InvoiceMessage) */ {
 public:
  inline InvoiceMessage() : InvoiceMessage(nullptr) {}
  ~InvoiceMessage() override;
  explicit PROTOBUF_CONSTEXPR InvoiceMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvoiceMessage(const InvoiceMessage& from);
  InvoiceMessage(InvoiceMessage&& from) noexcept
    : InvoiceMessage() {
    *this = ::std::move(from);
  }

  inline InvoiceMessage& operator=(const InvoiceMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvoiceMessage& operator=(InvoiceMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvoiceMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvoiceMessage* internal_default_instance() {
    return reinterpret_cast<const InvoiceMessage*>(
               &_InvoiceMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(InvoiceMessage& a, InvoiceMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(InvoiceMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvoiceMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvoiceMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvoiceMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvoiceMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvoiceMessage& from) {
    InvoiceMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvoiceMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.InvoiceMessage";
  }
  protected:
  explicit InvoiceMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef InvoiceMessage_InvoiceMessageAttachmentType InvoiceMessageAttachmentType;
  static constexpr InvoiceMessageAttachmentType IMAGE =
    InvoiceMessage_InvoiceMessageAttachmentType_IMAGE;
  static constexpr InvoiceMessageAttachmentType PDF =
    InvoiceMessage_InvoiceMessageAttachmentType_PDF;
  static inline bool InvoiceMessageAttachmentType_IsValid(int value) {
    return InvoiceMessage_InvoiceMessageAttachmentType_IsValid(value);
  }
  static constexpr InvoiceMessageAttachmentType InvoiceMessageAttachmentType_MIN =
    InvoiceMessage_InvoiceMessageAttachmentType_InvoiceMessageAttachmentType_MIN;
  static constexpr InvoiceMessageAttachmentType InvoiceMessageAttachmentType_MAX =
    InvoiceMessage_InvoiceMessageAttachmentType_InvoiceMessageAttachmentType_MAX;
  static constexpr int InvoiceMessageAttachmentType_ARRAYSIZE =
    InvoiceMessage_InvoiceMessageAttachmentType_InvoiceMessageAttachmentType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InvoiceMessageAttachmentType_descriptor() {
    return InvoiceMessage_InvoiceMessageAttachmentType_descriptor();
  }
  template<typename T>
  static inline const std::string& InvoiceMessageAttachmentType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InvoiceMessageAttachmentType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InvoiceMessageAttachmentType_Name.");
    return InvoiceMessage_InvoiceMessageAttachmentType_Name(enum_t_value);
  }
  static inline bool InvoiceMessageAttachmentType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InvoiceMessageAttachmentType* value) {
    return InvoiceMessage_InvoiceMessageAttachmentType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNoteFieldNumber = 1,
    kTokenFieldNumber = 2,
    kAttachmentMimetypeFieldNumber = 4,
    kAttachmentMediaKeyFieldNumber = 5,
    kAttachmentFileSha256FieldNumber = 7,
    kAttachmentFileEncSha256FieldNumber = 8,
    kAttachmentDirectPathFieldNumber = 9,
    kAttachmentJpegThumbnailFieldNumber = 10,
    kAttachmentMediaKeyTimestampFieldNumber = 6,
    kAttachmentTypeFieldNumber = 3,
  };
  // optional string note = 1;
  bool has_note() const;
  private:
  bool _internal_has_note() const;
  public:
  void clear_note();
  const std::string& note() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_note(ArgT0&& arg0, ArgT... args);
  std::string* mutable_note();
  PROTOBUF_NODISCARD std::string* release_note();
  void set_allocated_note(std::string* note);
  private:
  const std::string& _internal_note() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_note(const std::string& value);
  std::string* _internal_mutable_note();
  public:

  // optional string token = 2;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // optional string attachmentMimetype = 4;
  bool has_attachmentmimetype() const;
  private:
  bool _internal_has_attachmentmimetype() const;
  public:
  void clear_attachmentmimetype();
  const std::string& attachmentmimetype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attachmentmimetype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attachmentmimetype();
  PROTOBUF_NODISCARD std::string* release_attachmentmimetype();
  void set_allocated_attachmentmimetype(std::string* attachmentmimetype);
  private:
  const std::string& _internal_attachmentmimetype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attachmentmimetype(const std::string& value);
  std::string* _internal_mutable_attachmentmimetype();
  public:

  // optional bytes attachmentMediaKey = 5;
  bool has_attachmentmediakey() const;
  private:
  bool _internal_has_attachmentmediakey() const;
  public:
  void clear_attachmentmediakey();
  const std::string& attachmentmediakey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attachmentmediakey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attachmentmediakey();
  PROTOBUF_NODISCARD std::string* release_attachmentmediakey();
  void set_allocated_attachmentmediakey(std::string* attachmentmediakey);
  private:
  const std::string& _internal_attachmentmediakey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attachmentmediakey(const std::string& value);
  std::string* _internal_mutable_attachmentmediakey();
  public:

  // optional bytes attachmentFileSha256 = 7;
  bool has_attachmentfilesha256() const;
  private:
  bool _internal_has_attachmentfilesha256() const;
  public:
  void clear_attachmentfilesha256();
  const std::string& attachmentfilesha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attachmentfilesha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attachmentfilesha256();
  PROTOBUF_NODISCARD std::string* release_attachmentfilesha256();
  void set_allocated_attachmentfilesha256(std::string* attachmentfilesha256);
  private:
  const std::string& _internal_attachmentfilesha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attachmentfilesha256(const std::string& value);
  std::string* _internal_mutable_attachmentfilesha256();
  public:

  // optional bytes attachmentFileEncSha256 = 8;
  bool has_attachmentfileencsha256() const;
  private:
  bool _internal_has_attachmentfileencsha256() const;
  public:
  void clear_attachmentfileencsha256();
  const std::string& attachmentfileencsha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attachmentfileencsha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attachmentfileencsha256();
  PROTOBUF_NODISCARD std::string* release_attachmentfileencsha256();
  void set_allocated_attachmentfileencsha256(std::string* attachmentfileencsha256);
  private:
  const std::string& _internal_attachmentfileencsha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attachmentfileencsha256(const std::string& value);
  std::string* _internal_mutable_attachmentfileencsha256();
  public:

  // optional string attachmentDirectPath = 9;
  bool has_attachmentdirectpath() const;
  private:
  bool _internal_has_attachmentdirectpath() const;
  public:
  void clear_attachmentdirectpath();
  const std::string& attachmentdirectpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attachmentdirectpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attachmentdirectpath();
  PROTOBUF_NODISCARD std::string* release_attachmentdirectpath();
  void set_allocated_attachmentdirectpath(std::string* attachmentdirectpath);
  private:
  const std::string& _internal_attachmentdirectpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attachmentdirectpath(const std::string& value);
  std::string* _internal_mutable_attachmentdirectpath();
  public:

  // optional bytes attachmentJpegThumbnail = 10;
  bool has_attachmentjpegthumbnail() const;
  private:
  bool _internal_has_attachmentjpegthumbnail() const;
  public:
  void clear_attachmentjpegthumbnail();
  const std::string& attachmentjpegthumbnail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attachmentjpegthumbnail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attachmentjpegthumbnail();
  PROTOBUF_NODISCARD std::string* release_attachmentjpegthumbnail();
  void set_allocated_attachmentjpegthumbnail(std::string* attachmentjpegthumbnail);
  private:
  const std::string& _internal_attachmentjpegthumbnail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attachmentjpegthumbnail(const std::string& value);
  std::string* _internal_mutable_attachmentjpegthumbnail();
  public:

  // optional int64 attachmentMediaKeyTimestamp = 6;
  bool has_attachmentmediakeytimestamp() const;
  private:
  bool _internal_has_attachmentmediakeytimestamp() const;
  public:
  void clear_attachmentmediakeytimestamp();
  int64_t attachmentmediakeytimestamp() const;
  void set_attachmentmediakeytimestamp(int64_t value);
  private:
  int64_t _internal_attachmentmediakeytimestamp() const;
  void _internal_set_attachmentmediakeytimestamp(int64_t value);
  public:

  // optional .proto.InvoiceMessage.InvoiceMessageAttachmentType attachmentType = 3;
  bool has_attachmenttype() const;
  private:
  bool _internal_has_attachmenttype() const;
  public:
  void clear_attachmenttype();
  ::proto::InvoiceMessage_InvoiceMessageAttachmentType attachmenttype() const;
  void set_attachmenttype(::proto::InvoiceMessage_InvoiceMessageAttachmentType value);
  private:
  ::proto::InvoiceMessage_InvoiceMessageAttachmentType _internal_attachmenttype() const;
  void _internal_set_attachmenttype(::proto::InvoiceMessage_InvoiceMessageAttachmentType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.InvoiceMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr note_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attachmentmimetype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attachmentmediakey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attachmentfilesha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attachmentfileencsha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attachmentdirectpath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attachmentjpegthumbnail_;
    int64_t attachmentmediakeytimestamp_;
    int attachmenttype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class ContactMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ContactMessage) */ {
 public:
  inline ContactMessage() : ContactMessage(nullptr) {}
  ~ContactMessage() override;
  explicit PROTOBUF_CONSTEXPR ContactMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContactMessage(const ContactMessage& from);
  ContactMessage(ContactMessage&& from) noexcept
    : ContactMessage() {
    *this = ::std::move(from);
  }

  inline ContactMessage& operator=(const ContactMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContactMessage& operator=(ContactMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContactMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContactMessage* internal_default_instance() {
    return reinterpret_cast<const ContactMessage*>(
               &_ContactMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ContactMessage& a, ContactMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ContactMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContactMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContactMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContactMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContactMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContactMessage& from) {
    ContactMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContactMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ContactMessage";
  }
  protected:
  explicit ContactMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayNameFieldNumber = 1,
    kVcardFieldNumber = 16,
    kContextInfoFieldNumber = 17,
  };
  // optional string displayName = 1;
  bool has_displayname() const;
  private:
  bool _internal_has_displayname() const;
  public:
  void clear_displayname();
  const std::string& displayname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_displayname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_displayname();
  PROTOBUF_NODISCARD std::string* release_displayname();
  void set_allocated_displayname(std::string* displayname);
  private:
  const std::string& _internal_displayname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_displayname(const std::string& value);
  std::string* _internal_mutable_displayname();
  public:

  // optional string vcard = 16;
  bool has_vcard() const;
  private:
  bool _internal_has_vcard() const;
  public:
  void clear_vcard();
  const std::string& vcard() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vcard(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vcard();
  PROTOBUF_NODISCARD std::string* release_vcard();
  void set_allocated_vcard(std::string* vcard);
  private:
  const std::string& _internal_vcard() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vcard(const std::string& value);
  std::string* _internal_mutable_vcard();
  public:

  // optional .proto.ContextInfo contextInfo = 17;
  bool has_contextinfo() const;
  private:
  bool _internal_has_contextinfo() const;
  public:
  void clear_contextinfo();
  const ::proto::ContextInfo& contextinfo() const;
  PROTOBUF_NODISCARD ::proto::ContextInfo* release_contextinfo();
  ::proto::ContextInfo* mutable_contextinfo();
  void set_allocated_contextinfo(::proto::ContextInfo* contextinfo);
  private:
  const ::proto::ContextInfo& _internal_contextinfo() const;
  ::proto::ContextInfo* _internal_mutable_contextinfo();
  public:
  void unsafe_arena_set_allocated_contextinfo(
      ::proto::ContextInfo* contextinfo);
  ::proto::ContextInfo* unsafe_arena_release_contextinfo();

  // @@protoc_insertion_point(class_scope:proto.ContactMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr displayname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vcard_;
    ::proto::ContextInfo* contextinfo_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class LocationMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.LocationMessage) */ {
 public:
  inline LocationMessage() : LocationMessage(nullptr) {}
  ~LocationMessage() override;
  explicit PROTOBUF_CONSTEXPR LocationMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationMessage(const LocationMessage& from);
  LocationMessage(LocationMessage&& from) noexcept
    : LocationMessage() {
    *this = ::std::move(from);
  }

  inline LocationMessage& operator=(const LocationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationMessage& operator=(LocationMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationMessage* internal_default_instance() {
    return reinterpret_cast<const LocationMessage*>(
               &_LocationMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(LocationMessage& a, LocationMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocationMessage& from) {
    LocationMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.LocationMessage";
  }
  protected:
  explicit LocationMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kAddressFieldNumber = 4,
    kUrlFieldNumber = 5,
    kCommentFieldNumber = 11,
    kJpegThumbnailFieldNumber = 16,
    kContextInfoFieldNumber = 17,
    kDegreesLatitudeFieldNumber = 1,
    kDegreesLongitudeFieldNumber = 2,
    kIsLiveFieldNumber = 6,
    kAccuracyInMetersFieldNumber = 7,
    kSpeedInMpsFieldNumber = 8,
    kDegreesClockwiseFromMagneticNorthFieldNumber = 9,
  };
  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string address = 4;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional string url = 5;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string comment = 11;
  bool has_comment() const;
  private:
  bool _internal_has_comment() const;
  public:
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // optional bytes jpegThumbnail = 16;
  bool has_jpegthumbnail() const;
  private:
  bool _internal_has_jpegthumbnail() const;
  public:
  void clear_jpegthumbnail();
  const std::string& jpegthumbnail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jpegthumbnail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jpegthumbnail();
  PROTOBUF_NODISCARD std::string* release_jpegthumbnail();
  void set_allocated_jpegthumbnail(std::string* jpegthumbnail);
  private:
  const std::string& _internal_jpegthumbnail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jpegthumbnail(const std::string& value);
  std::string* _internal_mutable_jpegthumbnail();
  public:

  // optional .proto.ContextInfo contextInfo = 17;
  bool has_contextinfo() const;
  private:
  bool _internal_has_contextinfo() const;
  public:
  void clear_contextinfo();
  const ::proto::ContextInfo& contextinfo() const;
  PROTOBUF_NODISCARD ::proto::ContextInfo* release_contextinfo();
  ::proto::ContextInfo* mutable_contextinfo();
  void set_allocated_contextinfo(::proto::ContextInfo* contextinfo);
  private:
  const ::proto::ContextInfo& _internal_contextinfo() const;
  ::proto::ContextInfo* _internal_mutable_contextinfo();
  public:
  void unsafe_arena_set_allocated_contextinfo(
      ::proto::ContextInfo* contextinfo);
  ::proto::ContextInfo* unsafe_arena_release_contextinfo();

  // optional double degreesLatitude = 1;
  bool has_degreeslatitude() const;
  private:
  bool _internal_has_degreeslatitude() const;
  public:
  void clear_degreeslatitude();
  double degreeslatitude() const;
  void set_degreeslatitude(double value);
  private:
  double _internal_degreeslatitude() const;
  void _internal_set_degreeslatitude(double value);
  public:

  // optional double degreesLongitude = 2;
  bool has_degreeslongitude() const;
  private:
  bool _internal_has_degreeslongitude() const;
  public:
  void clear_degreeslongitude();
  double degreeslongitude() const;
  void set_degreeslongitude(double value);
  private:
  double _internal_degreeslongitude() const;
  void _internal_set_degreeslongitude(double value);
  public:

  // optional bool isLive = 6;
  bool has_islive() const;
  private:
  bool _internal_has_islive() const;
  public:
  void clear_islive();
  bool islive() const;
  void set_islive(bool value);
  private:
  bool _internal_islive() const;
  void _internal_set_islive(bool value);
  public:

  // optional uint32 accuracyInMeters = 7;
  bool has_accuracyinmeters() const;
  private:
  bool _internal_has_accuracyinmeters() const;
  public:
  void clear_accuracyinmeters();
  uint32_t accuracyinmeters() const;
  void set_accuracyinmeters(uint32_t value);
  private:
  uint32_t _internal_accuracyinmeters() const;
  void _internal_set_accuracyinmeters(uint32_t value);
  public:

  // optional float speedInMps = 8;
  bool has_speedinmps() const;
  private:
  bool _internal_has_speedinmps() const;
  public:
  void clear_speedinmps();
  float speedinmps() const;
  void set_speedinmps(float value);
  private:
  float _internal_speedinmps() const;
  void _internal_set_speedinmps(float value);
  public:

  // optional uint32 degreesClockwiseFromMagneticNorth = 9;
  bool has_degreesclockwisefrommagneticnorth() const;
  private:
  bool _internal_has_degreesclockwisefrommagneticnorth() const;
  public:
  void clear_degreesclockwisefrommagneticnorth();
  uint32_t degreesclockwisefrommagneticnorth() const;
  void set_degreesclockwisefrommagneticnorth(uint32_t value);
  private:
  uint32_t _internal_degreesclockwisefrommagneticnorth() const;
  void _internal_set_degreesclockwisefrommagneticnorth(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.LocationMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jpegthumbnail_;
    ::proto::ContextInfo* contextinfo_;
    double degreeslatitude_;
    double degreeslongitude_;
    bool islive_;
    uint32_t accuracyinmeters_;
    float speedinmps_;
    uint32_t degreesclockwisefrommagneticnorth_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class ExtendedTextMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ExtendedTextMessage) */ {
 public:
  inline ExtendedTextMessage() : ExtendedTextMessage(nullptr) {}
  ~ExtendedTextMessage() override;
  explicit PROTOBUF_CONSTEXPR ExtendedTextMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExtendedTextMessage(const ExtendedTextMessage& from);
  ExtendedTextMessage(ExtendedTextMessage&& from) noexcept
    : ExtendedTextMessage() {
    *this = ::std::move(from);
  }

  inline ExtendedTextMessage& operator=(const ExtendedTextMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtendedTextMessage& operator=(ExtendedTextMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExtendedTextMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtendedTextMessage* internal_default_instance() {
    return reinterpret_cast<const ExtendedTextMessage*>(
               &_ExtendedTextMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ExtendedTextMessage& a, ExtendedTextMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtendedTextMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtendedTextMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtendedTextMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExtendedTextMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExtendedTextMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExtendedTextMessage& from) {
    ExtendedTextMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExtendedTextMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ExtendedTextMessage";
  }
  protected:
  explicit ExtendedTextMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ExtendedTextMessage_ExtendedTextMessageFontType ExtendedTextMessageFontType;
  static constexpr ExtendedTextMessageFontType SANS_SERIF =
    ExtendedTextMessage_ExtendedTextMessageFontType_SANS_SERIF;
  static constexpr ExtendedTextMessageFontType SERIF =
    ExtendedTextMessage_ExtendedTextMessageFontType_SERIF;
  static constexpr ExtendedTextMessageFontType NORICAN_REGULAR =
    ExtendedTextMessage_ExtendedTextMessageFontType_NORICAN_REGULAR;
  static constexpr ExtendedTextMessageFontType BRYNDAN_WRITE =
    ExtendedTextMessage_ExtendedTextMessageFontType_BRYNDAN_WRITE;
  static constexpr ExtendedTextMessageFontType BEBASNEUE_REGULAR =
    ExtendedTextMessage_ExtendedTextMessageFontType_BEBASNEUE_REGULAR;
  static constexpr ExtendedTextMessageFontType OSWALD_HEAVY =
    ExtendedTextMessage_ExtendedTextMessageFontType_OSWALD_HEAVY;
  static inline bool ExtendedTextMessageFontType_IsValid(int value) {
    return ExtendedTextMessage_ExtendedTextMessageFontType_IsValid(value);
  }
  static constexpr ExtendedTextMessageFontType ExtendedTextMessageFontType_MIN =
    ExtendedTextMessage_ExtendedTextMessageFontType_ExtendedTextMessageFontType_MIN;
  static constexpr ExtendedTextMessageFontType ExtendedTextMessageFontType_MAX =
    ExtendedTextMessage_ExtendedTextMessageFontType_ExtendedTextMessageFontType_MAX;
  static constexpr int ExtendedTextMessageFontType_ARRAYSIZE =
    ExtendedTextMessage_ExtendedTextMessageFontType_ExtendedTextMessageFontType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ExtendedTextMessageFontType_descriptor() {
    return ExtendedTextMessage_ExtendedTextMessageFontType_descriptor();
  }
  template<typename T>
  static inline const std::string& ExtendedTextMessageFontType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ExtendedTextMessageFontType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ExtendedTextMessageFontType_Name.");
    return ExtendedTextMessage_ExtendedTextMessageFontType_Name(enum_t_value);
  }
  static inline bool ExtendedTextMessageFontType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ExtendedTextMessageFontType* value) {
    return ExtendedTextMessage_ExtendedTextMessageFontType_Parse(name, value);
  }

  typedef ExtendedTextMessage_ExtendedTextMessagePreviewType ExtendedTextMessagePreviewType;
  static constexpr ExtendedTextMessagePreviewType NONE =
    ExtendedTextMessage_ExtendedTextMessagePreviewType_NONE;
  static constexpr ExtendedTextMessagePreviewType VIDEO =
    ExtendedTextMessage_ExtendedTextMessagePreviewType_VIDEO;
  static inline bool ExtendedTextMessagePreviewType_IsValid(int value) {
    return ExtendedTextMessage_ExtendedTextMessagePreviewType_IsValid(value);
  }
  static constexpr ExtendedTextMessagePreviewType ExtendedTextMessagePreviewType_MIN =
    ExtendedTextMessage_ExtendedTextMessagePreviewType_ExtendedTextMessagePreviewType_MIN;
  static constexpr ExtendedTextMessagePreviewType ExtendedTextMessagePreviewType_MAX =
    ExtendedTextMessage_ExtendedTextMessagePreviewType_ExtendedTextMessagePreviewType_MAX;
  static constexpr int ExtendedTextMessagePreviewType_ARRAYSIZE =
    ExtendedTextMessage_ExtendedTextMessagePreviewType_ExtendedTextMessagePreviewType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ExtendedTextMessagePreviewType_descriptor() {
    return ExtendedTextMessage_ExtendedTextMessagePreviewType_descriptor();
  }
  template<typename T>
  static inline const std::string& ExtendedTextMessagePreviewType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ExtendedTextMessagePreviewType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ExtendedTextMessagePreviewType_Name.");
    return ExtendedTextMessage_ExtendedTextMessagePreviewType_Name(enum_t_value);
  }
  static inline bool ExtendedTextMessagePreviewType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ExtendedTextMessagePreviewType* value) {
    return ExtendedTextMessage_ExtendedTextMessagePreviewType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kMatchedTextFieldNumber = 2,
    kCanonicalUrlFieldNumber = 4,
    kDescriptionFieldNumber = 5,
    kTitleFieldNumber = 6,
    kJpegThumbnailFieldNumber = 16,
    kContextInfoFieldNumber = 17,
    kTextArgbFieldNumber = 7,
    kBackgroundArgbFieldNumber = 8,
    kFontFieldNumber = 9,
    kPreviewTypeFieldNumber = 10,
    kDoNotPlayInlineFieldNumber = 18,
  };
  // optional string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional string matchedText = 2;
  bool has_matchedtext() const;
  private:
  bool _internal_has_matchedtext() const;
  public:
  void clear_matchedtext();
  const std::string& matchedtext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_matchedtext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_matchedtext();
  PROTOBUF_NODISCARD std::string* release_matchedtext();
  void set_allocated_matchedtext(std::string* matchedtext);
  private:
  const std::string& _internal_matchedtext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_matchedtext(const std::string& value);
  std::string* _internal_mutable_matchedtext();
  public:

  // optional string canonicalUrl = 4;
  bool has_canonicalurl() const;
  private:
  bool _internal_has_canonicalurl() const;
  public:
  void clear_canonicalurl();
  const std::string& canonicalurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_canonicalurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_canonicalurl();
  PROTOBUF_NODISCARD std::string* release_canonicalurl();
  void set_allocated_canonicalurl(std::string* canonicalurl);
  private:
  const std::string& _internal_canonicalurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_canonicalurl(const std::string& value);
  std::string* _internal_mutable_canonicalurl();
  public:

  // optional string description = 5;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string title = 6;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional bytes jpegThumbnail = 16;
  bool has_jpegthumbnail() const;
  private:
  bool _internal_has_jpegthumbnail() const;
  public:
  void clear_jpegthumbnail();
  const std::string& jpegthumbnail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jpegthumbnail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jpegthumbnail();
  PROTOBUF_NODISCARD std::string* release_jpegthumbnail();
  void set_allocated_jpegthumbnail(std::string* jpegthumbnail);
  private:
  const std::string& _internal_jpegthumbnail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jpegthumbnail(const std::string& value);
  std::string* _internal_mutable_jpegthumbnail();
  public:

  // optional .proto.ContextInfo contextInfo = 17;
  bool has_contextinfo() const;
  private:
  bool _internal_has_contextinfo() const;
  public:
  void clear_contextinfo();
  const ::proto::ContextInfo& contextinfo() const;
  PROTOBUF_NODISCARD ::proto::ContextInfo* release_contextinfo();
  ::proto::ContextInfo* mutable_contextinfo();
  void set_allocated_contextinfo(::proto::ContextInfo* contextinfo);
  private:
  const ::proto::ContextInfo& _internal_contextinfo() const;
  ::proto::ContextInfo* _internal_mutable_contextinfo();
  public:
  void unsafe_arena_set_allocated_contextinfo(
      ::proto::ContextInfo* contextinfo);
  ::proto::ContextInfo* unsafe_arena_release_contextinfo();

  // optional fixed32 textArgb = 7;
  bool has_textargb() const;
  private:
  bool _internal_has_textargb() const;
  public:
  void clear_textargb();
  uint32_t textargb() const;
  void set_textargb(uint32_t value);
  private:
  uint32_t _internal_textargb() const;
  void _internal_set_textargb(uint32_t value);
  public:

  // optional fixed32 backgroundArgb = 8;
  bool has_backgroundargb() const;
  private:
  bool _internal_has_backgroundargb() const;
  public:
  void clear_backgroundargb();
  uint32_t backgroundargb() const;
  void set_backgroundargb(uint32_t value);
  private:
  uint32_t _internal_backgroundargb() const;
  void _internal_set_backgroundargb(uint32_t value);
  public:

  // optional .proto.ExtendedTextMessage.ExtendedTextMessageFontType font = 9;
  bool has_font() const;
  private:
  bool _internal_has_font() const;
  public:
  void clear_font();
  ::proto::ExtendedTextMessage_ExtendedTextMessageFontType font() const;
  void set_font(::proto::ExtendedTextMessage_ExtendedTextMessageFontType value);
  private:
  ::proto::ExtendedTextMessage_ExtendedTextMessageFontType _internal_font() const;
  void _internal_set_font(::proto::ExtendedTextMessage_ExtendedTextMessageFontType value);
  public:

  // optional .proto.ExtendedTextMessage.ExtendedTextMessagePreviewType previewType = 10;
  bool has_previewtype() const;
  private:
  bool _internal_has_previewtype() const;
  public:
  void clear_previewtype();
  ::proto::ExtendedTextMessage_ExtendedTextMessagePreviewType previewtype() const;
  void set_previewtype(::proto::ExtendedTextMessage_ExtendedTextMessagePreviewType value);
  private:
  ::proto::ExtendedTextMessage_ExtendedTextMessagePreviewType _internal_previewtype() const;
  void _internal_set_previewtype(::proto::ExtendedTextMessage_ExtendedTextMessagePreviewType value);
  public:

  // optional bool doNotPlayInline = 18;
  bool has_donotplayinline() const;
  private:
  bool _internal_has_donotplayinline() const;
  public:
  void clear_donotplayinline();
  bool donotplayinline() const;
  void set_donotplayinline(bool value);
  private:
  bool _internal_donotplayinline() const;
  void _internal_set_donotplayinline(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ExtendedTextMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr matchedtext_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr canonicalurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jpegthumbnail_;
    ::proto::ContextInfo* contextinfo_;
    uint32_t textargb_;
    uint32_t backgroundargb_;
    int font_;
    int previewtype_;
    bool donotplayinline_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class DocumentMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.DocumentMessage) */ {
 public:
  inline DocumentMessage() : DocumentMessage(nullptr) {}
  ~DocumentMessage() override;
  explicit PROTOBUF_CONSTEXPR DocumentMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentMessage(const DocumentMessage& from);
  DocumentMessage(DocumentMessage&& from) noexcept
    : DocumentMessage() {
    *this = ::std::move(from);
  }

  inline DocumentMessage& operator=(const DocumentMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentMessage& operator=(DocumentMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentMessage* internal_default_instance() {
    return reinterpret_cast<const DocumentMessage*>(
               &_DocumentMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(DocumentMessage& a, DocumentMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DocumentMessage& from) {
    DocumentMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.DocumentMessage";
  }
  protected:
  explicit DocumentMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kMimetypeFieldNumber = 2,
    kTitleFieldNumber = 3,
    kFileSha256FieldNumber = 4,
    kMediaKeyFieldNumber = 7,
    kFileNameFieldNumber = 8,
    kFileEncSha256FieldNumber = 9,
    kDirectPathFieldNumber = 10,
    kThumbnailDirectPathFieldNumber = 13,
    kThumbnailSha256FieldNumber = 14,
    kThumbnailEncSha256FieldNumber = 15,
    kJpegThumbnailFieldNumber = 16,
    kContextInfoFieldNumber = 17,
    kFileLengthFieldNumber = 5,
    kPageCountFieldNumber = 6,
    kContactVcardFieldNumber = 12,
    kMediaKeyTimestampFieldNumber = 11,
    kThumbnailHeightFieldNumber = 18,
    kThumbnailWidthFieldNumber = 19,
  };
  // optional string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string mimetype = 2;
  bool has_mimetype() const;
  private:
  bool _internal_has_mimetype() const;
  public:
  void clear_mimetype();
  const std::string& mimetype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mimetype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mimetype();
  PROTOBUF_NODISCARD std::string* release_mimetype();
  void set_allocated_mimetype(std::string* mimetype);
  private:
  const std::string& _internal_mimetype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mimetype(const std::string& value);
  std::string* _internal_mutable_mimetype();
  public:

  // optional string title = 3;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional bytes fileSha256 = 4;
  bool has_filesha256() const;
  private:
  bool _internal_has_filesha256() const;
  public:
  void clear_filesha256();
  const std::string& filesha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filesha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filesha256();
  PROTOBUF_NODISCARD std::string* release_filesha256();
  void set_allocated_filesha256(std::string* filesha256);
  private:
  const std::string& _internal_filesha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filesha256(const std::string& value);
  std::string* _internal_mutable_filesha256();
  public:

  // optional bytes mediaKey = 7;
  bool has_mediakey() const;
  private:
  bool _internal_has_mediakey() const;
  public:
  void clear_mediakey();
  const std::string& mediakey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mediakey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mediakey();
  PROTOBUF_NODISCARD std::string* release_mediakey();
  void set_allocated_mediakey(std::string* mediakey);
  private:
  const std::string& _internal_mediakey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mediakey(const std::string& value);
  std::string* _internal_mutable_mediakey();
  public:

  // optional string fileName = 8;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional bytes fileEncSha256 = 9;
  bool has_fileencsha256() const;
  private:
  bool _internal_has_fileencsha256() const;
  public:
  void clear_fileencsha256();
  const std::string& fileencsha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fileencsha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fileencsha256();
  PROTOBUF_NODISCARD std::string* release_fileencsha256();
  void set_allocated_fileencsha256(std::string* fileencsha256);
  private:
  const std::string& _internal_fileencsha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fileencsha256(const std::string& value);
  std::string* _internal_mutable_fileencsha256();
  public:

  // optional string directPath = 10;
  bool has_directpath() const;
  private:
  bool _internal_has_directpath() const;
  public:
  void clear_directpath();
  const std::string& directpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_directpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_directpath();
  PROTOBUF_NODISCARD std::string* release_directpath();
  void set_allocated_directpath(std::string* directpath);
  private:
  const std::string& _internal_directpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_directpath(const std::string& value);
  std::string* _internal_mutable_directpath();
  public:

  // optional string thumbnailDirectPath = 13;
  bool has_thumbnaildirectpath() const;
  private:
  bool _internal_has_thumbnaildirectpath() const;
  public:
  void clear_thumbnaildirectpath();
  const std::string& thumbnaildirectpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnaildirectpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnaildirectpath();
  PROTOBUF_NODISCARD std::string* release_thumbnaildirectpath();
  void set_allocated_thumbnaildirectpath(std::string* thumbnaildirectpath);
  private:
  const std::string& _internal_thumbnaildirectpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnaildirectpath(const std::string& value);
  std::string* _internal_mutable_thumbnaildirectpath();
  public:

  // optional bytes thumbnailSha256 = 14;
  bool has_thumbnailsha256() const;
  private:
  bool _internal_has_thumbnailsha256() const;
  public:
  void clear_thumbnailsha256();
  const std::string& thumbnailsha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnailsha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnailsha256();
  PROTOBUF_NODISCARD std::string* release_thumbnailsha256();
  void set_allocated_thumbnailsha256(std::string* thumbnailsha256);
  private:
  const std::string& _internal_thumbnailsha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnailsha256(const std::string& value);
  std::string* _internal_mutable_thumbnailsha256();
  public:

  // optional bytes thumbnailEncSha256 = 15;
  bool has_thumbnailencsha256() const;
  private:
  bool _internal_has_thumbnailencsha256() const;
  public:
  void clear_thumbnailencsha256();
  const std::string& thumbnailencsha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnailencsha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnailencsha256();
  PROTOBUF_NODISCARD std::string* release_thumbnailencsha256();
  void set_allocated_thumbnailencsha256(std::string* thumbnailencsha256);
  private:
  const std::string& _internal_thumbnailencsha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnailencsha256(const std::string& value);
  std::string* _internal_mutable_thumbnailencsha256();
  public:

  // optional bytes jpegThumbnail = 16;
  bool has_jpegthumbnail() const;
  private:
  bool _internal_has_jpegthumbnail() const;
  public:
  void clear_jpegthumbnail();
  const std::string& jpegthumbnail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jpegthumbnail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jpegthumbnail();
  PROTOBUF_NODISCARD std::string* release_jpegthumbnail();
  void set_allocated_jpegthumbnail(std::string* jpegthumbnail);
  private:
  const std::string& _internal_jpegthumbnail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jpegthumbnail(const std::string& value);
  std::string* _internal_mutable_jpegthumbnail();
  public:

  // optional .proto.ContextInfo contextInfo = 17;
  bool has_contextinfo() const;
  private:
  bool _internal_has_contextinfo() const;
  public:
  void clear_contextinfo();
  const ::proto::ContextInfo& contextinfo() const;
  PROTOBUF_NODISCARD ::proto::ContextInfo* release_contextinfo();
  ::proto::ContextInfo* mutable_contextinfo();
  void set_allocated_contextinfo(::proto::ContextInfo* contextinfo);
  private:
  const ::proto::ContextInfo& _internal_contextinfo() const;
  ::proto::ContextInfo* _internal_mutable_contextinfo();
  public:
  void unsafe_arena_set_allocated_contextinfo(
      ::proto::ContextInfo* contextinfo);
  ::proto::ContextInfo* unsafe_arena_release_contextinfo();

  // optional uint64 fileLength = 5;
  bool has_filelength() const;
  private:
  bool _internal_has_filelength() const;
  public:
  void clear_filelength();
  uint64_t filelength() const;
  void set_filelength(uint64_t value);
  private:
  uint64_t _internal_filelength() const;
  void _internal_set_filelength(uint64_t value);
  public:

  // optional uint32 pageCount = 6;
  bool has_pagecount() const;
  private:
  bool _internal_has_pagecount() const;
  public:
  void clear_pagecount();
  uint32_t pagecount() const;
  void set_pagecount(uint32_t value);
  private:
  uint32_t _internal_pagecount() const;
  void _internal_set_pagecount(uint32_t value);
  public:

  // optional bool contactVcard = 12;
  bool has_contactvcard() const;
  private:
  bool _internal_has_contactvcard() const;
  public:
  void clear_contactvcard();
  bool contactvcard() const;
  void set_contactvcard(bool value);
  private:
  bool _internal_contactvcard() const;
  void _internal_set_contactvcard(bool value);
  public:

  // optional int64 mediaKeyTimestamp = 11;
  bool has_mediakeytimestamp() const;
  private:
  bool _internal_has_mediakeytimestamp() const;
  public:
  void clear_mediakeytimestamp();
  int64_t mediakeytimestamp() const;
  void set_mediakeytimestamp(int64_t value);
  private:
  int64_t _internal_mediakeytimestamp() const;
  void _internal_set_mediakeytimestamp(int64_t value);
  public:

  // optional uint32 thumbnailHeight = 18;
  bool has_thumbnailheight() const;
  private:
  bool _internal_has_thumbnailheight() const;
  public:
  void clear_thumbnailheight();
  uint32_t thumbnailheight() const;
  void set_thumbnailheight(uint32_t value);
  private:
  uint32_t _internal_thumbnailheight() const;
  void _internal_set_thumbnailheight(uint32_t value);
  public:

  // optional uint32 thumbnailWidth = 19;
  bool has_thumbnailwidth() const;
  private:
  bool _internal_has_thumbnailwidth() const;
  public:
  void clear_thumbnailwidth();
  uint32_t thumbnailwidth() const;
  void set_thumbnailwidth(uint32_t value);
  private:
  uint32_t _internal_thumbnailwidth() const;
  void _internal_set_thumbnailwidth(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.DocumentMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mimetype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filesha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mediakey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fileencsha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directpath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnaildirectpath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnailsha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnailencsha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jpegthumbnail_;
    ::proto::ContextInfo* contextinfo_;
    uint64_t filelength_;
    uint32_t pagecount_;
    bool contactvcard_;
    int64_t mediakeytimestamp_;
    uint32_t thumbnailheight_;
    uint32_t thumbnailwidth_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class AudioMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.AudioMessage) */ {
 public:
  inline AudioMessage() : AudioMessage(nullptr) {}
  ~AudioMessage() override;
  explicit PROTOBUF_CONSTEXPR AudioMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioMessage(const AudioMessage& from);
  AudioMessage(AudioMessage&& from) noexcept
    : AudioMessage() {
    *this = ::std::move(from);
  }

  inline AudioMessage& operator=(const AudioMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioMessage& operator=(AudioMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioMessage* internal_default_instance() {
    return reinterpret_cast<const AudioMessage*>(
               &_AudioMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(AudioMessage& a, AudioMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioMessage& from) {
    AudioMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.AudioMessage";
  }
  protected:
  explicit AudioMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kMimetypeFieldNumber = 2,
    kFileSha256FieldNumber = 3,
    kMediaKeyFieldNumber = 7,
    kFileEncSha256FieldNumber = 8,
    kDirectPathFieldNumber = 9,
    kStreamingSidecarFieldNumber = 18,
    kContextInfoFieldNumber = 17,
    kFileLengthFieldNumber = 4,
    kSecondsFieldNumber = 5,
    kPttFieldNumber = 6,
    kMediaKeyTimestampFieldNumber = 10,
  };
  // optional string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string mimetype = 2;
  bool has_mimetype() const;
  private:
  bool _internal_has_mimetype() const;
  public:
  void clear_mimetype();
  const std::string& mimetype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mimetype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mimetype();
  PROTOBUF_NODISCARD std::string* release_mimetype();
  void set_allocated_mimetype(std::string* mimetype);
  private:
  const std::string& _internal_mimetype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mimetype(const std::string& value);
  std::string* _internal_mutable_mimetype();
  public:

  // optional bytes fileSha256 = 3;
  bool has_filesha256() const;
  private:
  bool _internal_has_filesha256() const;
  public:
  void clear_filesha256();
  const std::string& filesha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filesha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filesha256();
  PROTOBUF_NODISCARD std::string* release_filesha256();
  void set_allocated_filesha256(std::string* filesha256);
  private:
  const std::string& _internal_filesha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filesha256(const std::string& value);
  std::string* _internal_mutable_filesha256();
  public:

  // optional bytes mediaKey = 7;
  bool has_mediakey() const;
  private:
  bool _internal_has_mediakey() const;
  public:
  void clear_mediakey();
  const std::string& mediakey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mediakey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mediakey();
  PROTOBUF_NODISCARD std::string* release_mediakey();
  void set_allocated_mediakey(std::string* mediakey);
  private:
  const std::string& _internal_mediakey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mediakey(const std::string& value);
  std::string* _internal_mutable_mediakey();
  public:

  // optional bytes fileEncSha256 = 8;
  bool has_fileencsha256() const;
  private:
  bool _internal_has_fileencsha256() const;
  public:
  void clear_fileencsha256();
  const std::string& fileencsha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fileencsha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fileencsha256();
  PROTOBUF_NODISCARD std::string* release_fileencsha256();
  void set_allocated_fileencsha256(std::string* fileencsha256);
  private:
  const std::string& _internal_fileencsha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fileencsha256(const std::string& value);
  std::string* _internal_mutable_fileencsha256();
  public:

  // optional string directPath = 9;
  bool has_directpath() const;
  private:
  bool _internal_has_directpath() const;
  public:
  void clear_directpath();
  const std::string& directpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_directpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_directpath();
  PROTOBUF_NODISCARD std::string* release_directpath();
  void set_allocated_directpath(std::string* directpath);
  private:
  const std::string& _internal_directpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_directpath(const std::string& value);
  std::string* _internal_mutable_directpath();
  public:

  // optional bytes streamingSidecar = 18;
  bool has_streamingsidecar() const;
  private:
  bool _internal_has_streamingsidecar() const;
  public:
  void clear_streamingsidecar();
  const std::string& streamingsidecar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_streamingsidecar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_streamingsidecar();
  PROTOBUF_NODISCARD std::string* release_streamingsidecar();
  void set_allocated_streamingsidecar(std::string* streamingsidecar);
  private:
  const std::string& _internal_streamingsidecar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_streamingsidecar(const std::string& value);
  std::string* _internal_mutable_streamingsidecar();
  public:

  // optional .proto.ContextInfo contextInfo = 17;
  bool has_contextinfo() const;
  private:
  bool _internal_has_contextinfo() const;
  public:
  void clear_contextinfo();
  const ::proto::ContextInfo& contextinfo() const;
  PROTOBUF_NODISCARD ::proto::ContextInfo* release_contextinfo();
  ::proto::ContextInfo* mutable_contextinfo();
  void set_allocated_contextinfo(::proto::ContextInfo* contextinfo);
  private:
  const ::proto::ContextInfo& _internal_contextinfo() const;
  ::proto::ContextInfo* _internal_mutable_contextinfo();
  public:
  void unsafe_arena_set_allocated_contextinfo(
      ::proto::ContextInfo* contextinfo);
  ::proto::ContextInfo* unsafe_arena_release_contextinfo();

  // optional uint64 fileLength = 4;
  bool has_filelength() const;
  private:
  bool _internal_has_filelength() const;
  public:
  void clear_filelength();
  uint64_t filelength() const;
  void set_filelength(uint64_t value);
  private:
  uint64_t _internal_filelength() const;
  void _internal_set_filelength(uint64_t value);
  public:

  // optional uint32 seconds = 5;
  bool has_seconds() const;
  private:
  bool _internal_has_seconds() const;
  public:
  void clear_seconds();
  uint32_t seconds() const;
  void set_seconds(uint32_t value);
  private:
  uint32_t _internal_seconds() const;
  void _internal_set_seconds(uint32_t value);
  public:

  // optional bool ptt = 6;
  bool has_ptt() const;
  private:
  bool _internal_has_ptt() const;
  public:
  void clear_ptt();
  bool ptt() const;
  void set_ptt(bool value);
  private:
  bool _internal_ptt() const;
  void _internal_set_ptt(bool value);
  public:

  // optional int64 mediaKeyTimestamp = 10;
  bool has_mediakeytimestamp() const;
  private:
  bool _internal_has_mediakeytimestamp() const;
  public:
  void clear_mediakeytimestamp();
  int64_t mediakeytimestamp() const;
  void set_mediakeytimestamp(int64_t value);
  private:
  int64_t _internal_mediakeytimestamp() const;
  void _internal_set_mediakeytimestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.AudioMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mimetype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filesha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mediakey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fileencsha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directpath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr streamingsidecar_;
    ::proto::ContextInfo* contextinfo_;
    uint64_t filelength_;
    uint32_t seconds_;
    bool ptt_;
    int64_t mediakeytimestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class VideoMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.VideoMessage) */ {
 public:
  inline VideoMessage() : VideoMessage(nullptr) {}
  ~VideoMessage() override;
  explicit PROTOBUF_CONSTEXPR VideoMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoMessage(const VideoMessage& from);
  VideoMessage(VideoMessage&& from) noexcept
    : VideoMessage() {
    *this = ::std::move(from);
  }

  inline VideoMessage& operator=(const VideoMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoMessage& operator=(VideoMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoMessage* internal_default_instance() {
    return reinterpret_cast<const VideoMessage*>(
               &_VideoMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(VideoMessage& a, VideoMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoMessage& from) {
    VideoMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.VideoMessage";
  }
  protected:
  explicit VideoMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VideoMessage_VideoMessageAttribution VideoMessageAttribution;
  static constexpr VideoMessageAttribution NONE =
    VideoMessage_VideoMessageAttribution_NONE;
  static constexpr VideoMessageAttribution GIPHY =
    VideoMessage_VideoMessageAttribution_GIPHY;
  static constexpr VideoMessageAttribution TENOR =
    VideoMessage_VideoMessageAttribution_TENOR;
  static inline bool VideoMessageAttribution_IsValid(int value) {
    return VideoMessage_VideoMessageAttribution_IsValid(value);
  }
  static constexpr VideoMessageAttribution VideoMessageAttribution_MIN =
    VideoMessage_VideoMessageAttribution_VideoMessageAttribution_MIN;
  static constexpr VideoMessageAttribution VideoMessageAttribution_MAX =
    VideoMessage_VideoMessageAttribution_VideoMessageAttribution_MAX;
  static constexpr int VideoMessageAttribution_ARRAYSIZE =
    VideoMessage_VideoMessageAttribution_VideoMessageAttribution_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VideoMessageAttribution_descriptor() {
    return VideoMessage_VideoMessageAttribution_descriptor();
  }
  template<typename T>
  static inline const std::string& VideoMessageAttribution_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VideoMessageAttribution>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VideoMessageAttribution_Name.");
    return VideoMessage_VideoMessageAttribution_Name(enum_t_value);
  }
  static inline bool VideoMessageAttribution_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      VideoMessageAttribution* value) {
    return VideoMessage_VideoMessageAttribution_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInteractiveAnnotationsFieldNumber = 12,
    kUrlFieldNumber = 1,
    kMimetypeFieldNumber = 2,
    kFileSha256FieldNumber = 3,
    kMediaKeyFieldNumber = 6,
    kCaptionFieldNumber = 7,
    kFileEncSha256FieldNumber = 11,
    kDirectPathFieldNumber = 13,
    kJpegThumbnailFieldNumber = 16,
    kStreamingSidecarFieldNumber = 18,
    kThumbnailDirectPathFieldNumber = 21,
    kThumbnailSha256FieldNumber = 22,
    kThumbnailEncSha256FieldNumber = 23,
    kContextInfoFieldNumber = 17,
    kFileLengthFieldNumber = 4,
    kSecondsFieldNumber = 5,
    kHeightFieldNumber = 9,
    kWidthFieldNumber = 10,
    kGifPlaybackFieldNumber = 8,
    kViewOnceFieldNumber = 20,
    kMediaKeyTimestampFieldNumber = 14,
    kGifAttributionFieldNumber = 19,
  };
  // repeated .proto.InteractiveAnnotation interactiveAnnotations = 12;
  int interactiveannotations_size() const;
  private:
  int _internal_interactiveannotations_size() const;
  public:
  void clear_interactiveannotations();
  ::proto::InteractiveAnnotation* mutable_interactiveannotations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::InteractiveAnnotation >*
      mutable_interactiveannotations();
  private:
  const ::proto::InteractiveAnnotation& _internal_interactiveannotations(int index) const;
  ::proto::InteractiveAnnotation* _internal_add_interactiveannotations();
  public:
  const ::proto::InteractiveAnnotation& interactiveannotations(int index) const;
  ::proto::InteractiveAnnotation* add_interactiveannotations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::InteractiveAnnotation >&
      interactiveannotations() const;

  // optional string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string mimetype = 2;
  bool has_mimetype() const;
  private:
  bool _internal_has_mimetype() const;
  public:
  void clear_mimetype();
  const std::string& mimetype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mimetype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mimetype();
  PROTOBUF_NODISCARD std::string* release_mimetype();
  void set_allocated_mimetype(std::string* mimetype);
  private:
  const std::string& _internal_mimetype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mimetype(const std::string& value);
  std::string* _internal_mutable_mimetype();
  public:

  // optional bytes fileSha256 = 3;
  bool has_filesha256() const;
  private:
  bool _internal_has_filesha256() const;
  public:
  void clear_filesha256();
  const std::string& filesha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filesha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filesha256();
  PROTOBUF_NODISCARD std::string* release_filesha256();
  void set_allocated_filesha256(std::string* filesha256);
  private:
  const std::string& _internal_filesha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filesha256(const std::string& value);
  std::string* _internal_mutable_filesha256();
  public:

  // optional bytes mediaKey = 6;
  bool has_mediakey() const;
  private:
  bool _internal_has_mediakey() const;
  public:
  void clear_mediakey();
  const std::string& mediakey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mediakey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mediakey();
  PROTOBUF_NODISCARD std::string* release_mediakey();
  void set_allocated_mediakey(std::string* mediakey);
  private:
  const std::string& _internal_mediakey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mediakey(const std::string& value);
  std::string* _internal_mutable_mediakey();
  public:

  // optional string caption = 7;
  bool has_caption() const;
  private:
  bool _internal_has_caption() const;
  public:
  void clear_caption();
  const std::string& caption() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caption(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caption();
  PROTOBUF_NODISCARD std::string* release_caption();
  void set_allocated_caption(std::string* caption);
  private:
  const std::string& _internal_caption() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caption(const std::string& value);
  std::string* _internal_mutable_caption();
  public:

  // optional bytes fileEncSha256 = 11;
  bool has_fileencsha256() const;
  private:
  bool _internal_has_fileencsha256() const;
  public:
  void clear_fileencsha256();
  const std::string& fileencsha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fileencsha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fileencsha256();
  PROTOBUF_NODISCARD std::string* release_fileencsha256();
  void set_allocated_fileencsha256(std::string* fileencsha256);
  private:
  const std::string& _internal_fileencsha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fileencsha256(const std::string& value);
  std::string* _internal_mutable_fileencsha256();
  public:

  // optional string directPath = 13;
  bool has_directpath() const;
  private:
  bool _internal_has_directpath() const;
  public:
  void clear_directpath();
  const std::string& directpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_directpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_directpath();
  PROTOBUF_NODISCARD std::string* release_directpath();
  void set_allocated_directpath(std::string* directpath);
  private:
  const std::string& _internal_directpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_directpath(const std::string& value);
  std::string* _internal_mutable_directpath();
  public:

  // optional bytes jpegThumbnail = 16;
  bool has_jpegthumbnail() const;
  private:
  bool _internal_has_jpegthumbnail() const;
  public:
  void clear_jpegthumbnail();
  const std::string& jpegthumbnail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jpegthumbnail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jpegthumbnail();
  PROTOBUF_NODISCARD std::string* release_jpegthumbnail();
  void set_allocated_jpegthumbnail(std::string* jpegthumbnail);
  private:
  const std::string& _internal_jpegthumbnail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jpegthumbnail(const std::string& value);
  std::string* _internal_mutable_jpegthumbnail();
  public:

  // optional bytes streamingSidecar = 18;
  bool has_streamingsidecar() const;
  private:
  bool _internal_has_streamingsidecar() const;
  public:
  void clear_streamingsidecar();
  const std::string& streamingsidecar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_streamingsidecar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_streamingsidecar();
  PROTOBUF_NODISCARD std::string* release_streamingsidecar();
  void set_allocated_streamingsidecar(std::string* streamingsidecar);
  private:
  const std::string& _internal_streamingsidecar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_streamingsidecar(const std::string& value);
  std::string* _internal_mutable_streamingsidecar();
  public:

  // optional string thumbnailDirectPath = 21;
  bool has_thumbnaildirectpath() const;
  private:
  bool _internal_has_thumbnaildirectpath() const;
  public:
  void clear_thumbnaildirectpath();
  const std::string& thumbnaildirectpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnaildirectpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnaildirectpath();
  PROTOBUF_NODISCARD std::string* release_thumbnaildirectpath();
  void set_allocated_thumbnaildirectpath(std::string* thumbnaildirectpath);
  private:
  const std::string& _internal_thumbnaildirectpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnaildirectpath(const std::string& value);
  std::string* _internal_mutable_thumbnaildirectpath();
  public:

  // optional bytes thumbnailSha256 = 22;
  bool has_thumbnailsha256() const;
  private:
  bool _internal_has_thumbnailsha256() const;
  public:
  void clear_thumbnailsha256();
  const std::string& thumbnailsha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnailsha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnailsha256();
  PROTOBUF_NODISCARD std::string* release_thumbnailsha256();
  void set_allocated_thumbnailsha256(std::string* thumbnailsha256);
  private:
  const std::string& _internal_thumbnailsha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnailsha256(const std::string& value);
  std::string* _internal_mutable_thumbnailsha256();
  public:

  // optional bytes thumbnailEncSha256 = 23;
  bool has_thumbnailencsha256() const;
  private:
  bool _internal_has_thumbnailencsha256() const;
  public:
  void clear_thumbnailencsha256();
  const std::string& thumbnailencsha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnailencsha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnailencsha256();
  PROTOBUF_NODISCARD std::string* release_thumbnailencsha256();
  void set_allocated_thumbnailencsha256(std::string* thumbnailencsha256);
  private:
  const std::string& _internal_thumbnailencsha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnailencsha256(const std::string& value);
  std::string* _internal_mutable_thumbnailencsha256();
  public:

  // optional .proto.ContextInfo contextInfo = 17;
  bool has_contextinfo() const;
  private:
  bool _internal_has_contextinfo() const;
  public:
  void clear_contextinfo();
  const ::proto::ContextInfo& contextinfo() const;
  PROTOBUF_NODISCARD ::proto::ContextInfo* release_contextinfo();
  ::proto::ContextInfo* mutable_contextinfo();
  void set_allocated_contextinfo(::proto::ContextInfo* contextinfo);
  private:
  const ::proto::ContextInfo& _internal_contextinfo() const;
  ::proto::ContextInfo* _internal_mutable_contextinfo();
  public:
  void unsafe_arena_set_allocated_contextinfo(
      ::proto::ContextInfo* contextinfo);
  ::proto::ContextInfo* unsafe_arena_release_contextinfo();

  // optional uint64 fileLength = 4;
  bool has_filelength() const;
  private:
  bool _internal_has_filelength() const;
  public:
  void clear_filelength();
  uint64_t filelength() const;
  void set_filelength(uint64_t value);
  private:
  uint64_t _internal_filelength() const;
  void _internal_set_filelength(uint64_t value);
  public:

  // optional uint32 seconds = 5;
  bool has_seconds() const;
  private:
  bool _internal_has_seconds() const;
  public:
  void clear_seconds();
  uint32_t seconds() const;
  void set_seconds(uint32_t value);
  private:
  uint32_t _internal_seconds() const;
  void _internal_set_seconds(uint32_t value);
  public:

  // optional uint32 height = 9;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // optional uint32 width = 10;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // optional bool gifPlayback = 8;
  bool has_gifplayback() const;
  private:
  bool _internal_has_gifplayback() const;
  public:
  void clear_gifplayback();
  bool gifplayback() const;
  void set_gifplayback(bool value);
  private:
  bool _internal_gifplayback() const;
  void _internal_set_gifplayback(bool value);
  public:

  // optional bool viewOnce = 20;
  bool has_viewonce() const;
  private:
  bool _internal_has_viewonce() const;
  public:
  void clear_viewonce();
  bool viewonce() const;
  void set_viewonce(bool value);
  private:
  bool _internal_viewonce() const;
  void _internal_set_viewonce(bool value);
  public:

  // optional int64 mediaKeyTimestamp = 14;
  bool has_mediakeytimestamp() const;
  private:
  bool _internal_has_mediakeytimestamp() const;
  public:
  void clear_mediakeytimestamp();
  int64_t mediakeytimestamp() const;
  void set_mediakeytimestamp(int64_t value);
  private:
  int64_t _internal_mediakeytimestamp() const;
  void _internal_set_mediakeytimestamp(int64_t value);
  public:

  // optional .proto.VideoMessage.VideoMessageAttribution gifAttribution = 19;
  bool has_gifattribution() const;
  private:
  bool _internal_has_gifattribution() const;
  public:
  void clear_gifattribution();
  ::proto::VideoMessage_VideoMessageAttribution gifattribution() const;
  void set_gifattribution(::proto::VideoMessage_VideoMessageAttribution value);
  private:
  ::proto::VideoMessage_VideoMessageAttribution _internal_gifattribution() const;
  void _internal_set_gifattribution(::proto::VideoMessage_VideoMessageAttribution value);
  public:

  // @@protoc_insertion_point(class_scope:proto.VideoMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::InteractiveAnnotation > interactiveannotations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mimetype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filesha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mediakey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caption_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fileencsha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directpath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jpegthumbnail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr streamingsidecar_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnaildirectpath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnailsha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnailencsha256_;
    ::proto::ContextInfo* contextinfo_;
    uint64_t filelength_;
    uint32_t seconds_;
    uint32_t height_;
    uint32_t width_;
    bool gifplayback_;
    bool viewonce_;
    int64_t mediakeytimestamp_;
    int gifattribution_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class Call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Call) */ {
 public:
  inline Call() : Call(nullptr) {}
  ~Call() override;
  explicit PROTOBUF_CONSTEXPR Call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Call(const Call& from);
  Call(Call&& from) noexcept
    : Call() {
    *this = ::std::move(from);
  }

  inline Call& operator=(const Call& from) {
    CopyFrom(from);
    return *this;
  }
  inline Call& operator=(Call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Call& default_instance() {
    return *internal_default_instance();
  }
  static inline const Call* internal_default_instance() {
    return reinterpret_cast<const Call*>(
               &_Call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Call& a, Call& b) {
    a.Swap(&b);
  }
  inline void Swap(Call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Call& from) {
    Call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Call";
  }
  protected:
  explicit Call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallKeyFieldNumber = 1,
  };
  // optional bytes callKey = 1;
  bool has_callkey() const;
  private:
  bool _internal_has_callkey() const;
  public:
  void clear_callkey();
  const std::string& callkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_callkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_callkey();
  PROTOBUF_NODISCARD std::string* release_callkey();
  void set_allocated_callkey(std::string* callkey);
  private:
  const std::string& _internal_callkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_callkey(const std::string& value);
  std::string* _internal_mutable_callkey();
  public:

  // @@protoc_insertion_point(class_scope:proto.Call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr callkey_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class Chat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Chat) */ {
 public:
  inline Chat() : Chat(nullptr) {}
  ~Chat() override;
  explicit PROTOBUF_CONSTEXPR Chat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Chat(const Chat& from);
  Chat(Chat&& from) noexcept
    : Chat() {
    *this = ::std::move(from);
  }

  inline Chat& operator=(const Chat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Chat& operator=(Chat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Chat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Chat* internal_default_instance() {
    return reinterpret_cast<const Chat*>(
               &_Chat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Chat& a, Chat& b) {
    a.Swap(&b);
  }
  inline void Swap(Chat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Chat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Chat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Chat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Chat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Chat& from) {
    Chat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Chat";
  }
  protected:
  explicit Chat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayNameFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // optional string displayName = 1;
  bool has_displayname() const;
  private:
  bool _internal_has_displayname() const;
  public:
  void clear_displayname();
  const std::string& displayname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_displayname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_displayname();
  PROTOBUF_NODISCARD std::string* release_displayname();
  void set_allocated_displayname(std::string* displayname);
  private:
  const std::string& _internal_displayname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_displayname(const std::string& value);
  std::string* _internal_mutable_displayname();
  public:

  // optional string id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:proto.Chat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr displayname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class ProtocolMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ProtocolMessage) */ {
 public:
  inline ProtocolMessage() : ProtocolMessage(nullptr) {}
  ~ProtocolMessage() override;
  explicit PROTOBUF_CONSTEXPR ProtocolMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtocolMessage(const ProtocolMessage& from);
  ProtocolMessage(ProtocolMessage&& from) noexcept
    : ProtocolMessage() {
    *this = ::std::move(from);
  }

  inline ProtocolMessage& operator=(const ProtocolMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtocolMessage& operator=(ProtocolMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtocolMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtocolMessage* internal_default_instance() {
    return reinterpret_cast<const ProtocolMessage*>(
               &_ProtocolMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ProtocolMessage& a, ProtocolMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtocolMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtocolMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtocolMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtocolMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtocolMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtocolMessage& from) {
    ProtocolMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtocolMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ProtocolMessage";
  }
  protected:
  explicit ProtocolMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ProtocolMessage_ProtocolMessageType ProtocolMessageType;
  static constexpr ProtocolMessageType REVOKE =
    ProtocolMessage_ProtocolMessageType_REVOKE;
  static constexpr ProtocolMessageType EPHEMERAL_SETTING =
    ProtocolMessage_ProtocolMessageType_EPHEMERAL_SETTING;
  static constexpr ProtocolMessageType EPHEMERAL_SYNC_RESPONSE =
    ProtocolMessage_ProtocolMessageType_EPHEMERAL_SYNC_RESPONSE;
  static constexpr ProtocolMessageType HISTORY_SYNC_NOTIFICATION =
    ProtocolMessage_ProtocolMessageType_HISTORY_SYNC_NOTIFICATION;
  static constexpr ProtocolMessageType APP_STATE_SYNC_KEY_SHARE =
    ProtocolMessage_ProtocolMessageType_APP_STATE_SYNC_KEY_SHARE;
  static constexpr ProtocolMessageType APP_STATE_SYNC_KEY_REQUEST =
    ProtocolMessage_ProtocolMessageType_APP_STATE_SYNC_KEY_REQUEST;
  static constexpr ProtocolMessageType MSG_FANOUT_BACKFILL_REQUEST =
    ProtocolMessage_ProtocolMessageType_MSG_FANOUT_BACKFILL_REQUEST;
  static constexpr ProtocolMessageType INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC =
    ProtocolMessage_ProtocolMessageType_INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC;
  static constexpr ProtocolMessageType APP_STATE_FATAL_EXCEPTION_NOTIFICATION =
    ProtocolMessage_ProtocolMessageType_APP_STATE_FATAL_EXCEPTION_NOTIFICATION;
  static inline bool ProtocolMessageType_IsValid(int value) {
    return ProtocolMessage_ProtocolMessageType_IsValid(value);
  }
  static constexpr ProtocolMessageType ProtocolMessageType_MIN =
    ProtocolMessage_ProtocolMessageType_ProtocolMessageType_MIN;
  static constexpr ProtocolMessageType ProtocolMessageType_MAX =
    ProtocolMessage_ProtocolMessageType_ProtocolMessageType_MAX;
  static constexpr int ProtocolMessageType_ARRAYSIZE =
    ProtocolMessage_ProtocolMessageType_ProtocolMessageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ProtocolMessageType_descriptor() {
    return ProtocolMessage_ProtocolMessageType_descriptor();
  }
  template<typename T>
  static inline const std::string& ProtocolMessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ProtocolMessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ProtocolMessageType_Name.");
    return ProtocolMessage_ProtocolMessageType_Name(enum_t_value);
  }
  static inline bool ProtocolMessageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ProtocolMessageType* value) {
    return ProtocolMessage_ProtocolMessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kHistorySyncNotificationFieldNumber = 6,
    kAppStateSyncKeyShareFieldNumber = 7,
    kAppStateSyncKeyRequestFieldNumber = 8,
    kInitialSecurityNotificationSettingSyncFieldNumber = 9,
    kAppStateFatalExceptionNotificationFieldNumber = 10,
    kTypeFieldNumber = 2,
    kEphemeralExpirationFieldNumber = 4,
    kEphemeralSettingTimestampFieldNumber = 5,
  };
  // optional .proto.MessageKey key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::proto::MessageKey& key() const;
  PROTOBUF_NODISCARD ::proto::MessageKey* release_key();
  ::proto::MessageKey* mutable_key();
  void set_allocated_key(::proto::MessageKey* key);
  private:
  const ::proto::MessageKey& _internal_key() const;
  ::proto::MessageKey* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::proto::MessageKey* key);
  ::proto::MessageKey* unsafe_arena_release_key();

  // optional .proto.HistorySyncNotification historySyncNotification = 6;
  bool has_historysyncnotification() const;
  private:
  bool _internal_has_historysyncnotification() const;
  public:
  void clear_historysyncnotification();
  const ::proto::HistorySyncNotification& historysyncnotification() const;
  PROTOBUF_NODISCARD ::proto::HistorySyncNotification* release_historysyncnotification();
  ::proto::HistorySyncNotification* mutable_historysyncnotification();
  void set_allocated_historysyncnotification(::proto::HistorySyncNotification* historysyncnotification);
  private:
  const ::proto::HistorySyncNotification& _internal_historysyncnotification() const;
  ::proto::HistorySyncNotification* _internal_mutable_historysyncnotification();
  public:
  void unsafe_arena_set_allocated_historysyncnotification(
      ::proto::HistorySyncNotification* historysyncnotification);
  ::proto::HistorySyncNotification* unsafe_arena_release_historysyncnotification();

  // optional .proto.AppStateSyncKeyShare appStateSyncKeyShare = 7;
  bool has_appstatesynckeyshare() const;
  private:
  bool _internal_has_appstatesynckeyshare() const;
  public:
  void clear_appstatesynckeyshare();
  const ::proto::AppStateSyncKeyShare& appstatesynckeyshare() const;
  PROTOBUF_NODISCARD ::proto::AppStateSyncKeyShare* release_appstatesynckeyshare();
  ::proto::AppStateSyncKeyShare* mutable_appstatesynckeyshare();
  void set_allocated_appstatesynckeyshare(::proto::AppStateSyncKeyShare* appstatesynckeyshare);
  private:
  const ::proto::AppStateSyncKeyShare& _internal_appstatesynckeyshare() const;
  ::proto::AppStateSyncKeyShare* _internal_mutable_appstatesynckeyshare();
  public:
  void unsafe_arena_set_allocated_appstatesynckeyshare(
      ::proto::AppStateSyncKeyShare* appstatesynckeyshare);
  ::proto::AppStateSyncKeyShare* unsafe_arena_release_appstatesynckeyshare();

  // optional .proto.AppStateSyncKeyRequest appStateSyncKeyRequest = 8;
  bool has_appstatesynckeyrequest() const;
  private:
  bool _internal_has_appstatesynckeyrequest() const;
  public:
  void clear_appstatesynckeyrequest();
  const ::proto::AppStateSyncKeyRequest& appstatesynckeyrequest() const;
  PROTOBUF_NODISCARD ::proto::AppStateSyncKeyRequest* release_appstatesynckeyrequest();
  ::proto::AppStateSyncKeyRequest* mutable_appstatesynckeyrequest();
  void set_allocated_appstatesynckeyrequest(::proto::AppStateSyncKeyRequest* appstatesynckeyrequest);
  private:
  const ::proto::AppStateSyncKeyRequest& _internal_appstatesynckeyrequest() const;
  ::proto::AppStateSyncKeyRequest* _internal_mutable_appstatesynckeyrequest();
  public:
  void unsafe_arena_set_allocated_appstatesynckeyrequest(
      ::proto::AppStateSyncKeyRequest* appstatesynckeyrequest);
  ::proto::AppStateSyncKeyRequest* unsafe_arena_release_appstatesynckeyrequest();

  // optional .proto.InitialSecurityNotificationSettingSync initialSecurityNotificationSettingSync = 9;
  bool has_initialsecuritynotificationsettingsync() const;
  private:
  bool _internal_has_initialsecuritynotificationsettingsync() const;
  public:
  void clear_initialsecuritynotificationsettingsync();
  const ::proto::InitialSecurityNotificationSettingSync& initialsecuritynotificationsettingsync() const;
  PROTOBUF_NODISCARD ::proto::InitialSecurityNotificationSettingSync* release_initialsecuritynotificationsettingsync();
  ::proto::InitialSecurityNotificationSettingSync* mutable_initialsecuritynotificationsettingsync();
  void set_allocated_initialsecuritynotificationsettingsync(::proto::InitialSecurityNotificationSettingSync* initialsecuritynotificationsettingsync);
  private:
  const ::proto::InitialSecurityNotificationSettingSync& _internal_initialsecuritynotificationsettingsync() const;
  ::proto::InitialSecurityNotificationSettingSync* _internal_mutable_initialsecuritynotificationsettingsync();
  public:
  void unsafe_arena_set_allocated_initialsecuritynotificationsettingsync(
      ::proto::InitialSecurityNotificationSettingSync* initialsecuritynotificationsettingsync);
  ::proto::InitialSecurityNotificationSettingSync* unsafe_arena_release_initialsecuritynotificationsettingsync();

  // optional .proto.AppStateFatalExceptionNotification appStateFatalExceptionNotification = 10;
  bool has_appstatefatalexceptionnotification() const;
  private:
  bool _internal_has_appstatefatalexceptionnotification() const;
  public:
  void clear_appstatefatalexceptionnotification();
  const ::proto::AppStateFatalExceptionNotification& appstatefatalexceptionnotification() const;
  PROTOBUF_NODISCARD ::proto::AppStateFatalExceptionNotification* release_appstatefatalexceptionnotification();
  ::proto::AppStateFatalExceptionNotification* mutable_appstatefatalexceptionnotification();
  void set_allocated_appstatefatalexceptionnotification(::proto::AppStateFatalExceptionNotification* appstatefatalexceptionnotification);
  private:
  const ::proto::AppStateFatalExceptionNotification& _internal_appstatefatalexceptionnotification() const;
  ::proto::AppStateFatalExceptionNotification* _internal_mutable_appstatefatalexceptionnotification();
  public:
  void unsafe_arena_set_allocated_appstatefatalexceptionnotification(
      ::proto::AppStateFatalExceptionNotification* appstatefatalexceptionnotification);
  ::proto::AppStateFatalExceptionNotification* unsafe_arena_release_appstatefatalexceptionnotification();

  // optional .proto.ProtocolMessage.ProtocolMessageType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::proto::ProtocolMessage_ProtocolMessageType type() const;
  void set_type(::proto::ProtocolMessage_ProtocolMessageType value);
  private:
  ::proto::ProtocolMessage_ProtocolMessageType _internal_type() const;
  void _internal_set_type(::proto::ProtocolMessage_ProtocolMessageType value);
  public:

  // optional uint32 ephemeralExpiration = 4;
  bool has_ephemeralexpiration() const;
  private:
  bool _internal_has_ephemeralexpiration() const;
  public:
  void clear_ephemeralexpiration();
  uint32_t ephemeralexpiration() const;
  void set_ephemeralexpiration(uint32_t value);
  private:
  uint32_t _internal_ephemeralexpiration() const;
  void _internal_set_ephemeralexpiration(uint32_t value);
  public:

  // optional int64 ephemeralSettingTimestamp = 5;
  bool has_ephemeralsettingtimestamp() const;
  private:
  bool _internal_has_ephemeralsettingtimestamp() const;
  public:
  void clear_ephemeralsettingtimestamp();
  int64_t ephemeralsettingtimestamp() const;
  void set_ephemeralsettingtimestamp(int64_t value);
  private:
  int64_t _internal_ephemeralsettingtimestamp() const;
  void _internal_set_ephemeralsettingtimestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ProtocolMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::proto::MessageKey* key_;
    ::proto::HistorySyncNotification* historysyncnotification_;
    ::proto::AppStateSyncKeyShare* appstatesynckeyshare_;
    ::proto::AppStateSyncKeyRequest* appstatesynckeyrequest_;
    ::proto::InitialSecurityNotificationSettingSync* initialsecuritynotificationsettingsync_;
    ::proto::AppStateFatalExceptionNotification* appstatefatalexceptionnotification_;
    int type_;
    uint32_t ephemeralexpiration_;
    int64_t ephemeralsettingtimestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class HistorySyncNotification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.HistorySyncNotification) */ {
 public:
  inline HistorySyncNotification() : HistorySyncNotification(nullptr) {}
  ~HistorySyncNotification() override;
  explicit PROTOBUF_CONSTEXPR HistorySyncNotification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HistorySyncNotification(const HistorySyncNotification& from);
  HistorySyncNotification(HistorySyncNotification&& from) noexcept
    : HistorySyncNotification() {
    *this = ::std::move(from);
  }

  inline HistorySyncNotification& operator=(const HistorySyncNotification& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistorySyncNotification& operator=(HistorySyncNotification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HistorySyncNotification& default_instance() {
    return *internal_default_instance();
  }
  static inline const HistorySyncNotification* internal_default_instance() {
    return reinterpret_cast<const HistorySyncNotification*>(
               &_HistorySyncNotification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(HistorySyncNotification& a, HistorySyncNotification& b) {
    a.Swap(&b);
  }
  inline void Swap(HistorySyncNotification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistorySyncNotification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HistorySyncNotification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HistorySyncNotification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HistorySyncNotification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HistorySyncNotification& from) {
    HistorySyncNotification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistorySyncNotification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HistorySyncNotification";
  }
  protected:
  explicit HistorySyncNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HistorySyncNotification_HistorySyncNotificationHistorySyncType HistorySyncNotificationHistorySyncType;
  static constexpr HistorySyncNotificationHistorySyncType INITIAL_BOOTSTRAP =
    HistorySyncNotification_HistorySyncNotificationHistorySyncType_INITIAL_BOOTSTRAP;
  static constexpr HistorySyncNotificationHistorySyncType INITIAL_STATUS_V3 =
    HistorySyncNotification_HistorySyncNotificationHistorySyncType_INITIAL_STATUS_V3;
  static constexpr HistorySyncNotificationHistorySyncType FULL =
    HistorySyncNotification_HistorySyncNotificationHistorySyncType_FULL;
  static constexpr HistorySyncNotificationHistorySyncType RECENT =
    HistorySyncNotification_HistorySyncNotificationHistorySyncType_RECENT;
  static constexpr HistorySyncNotificationHistorySyncType PUSH_NAME =
    HistorySyncNotification_HistorySyncNotificationHistorySyncType_PUSH_NAME;
  static inline bool HistorySyncNotificationHistorySyncType_IsValid(int value) {
    return HistorySyncNotification_HistorySyncNotificationHistorySyncType_IsValid(value);
  }
  static constexpr HistorySyncNotificationHistorySyncType HistorySyncNotificationHistorySyncType_MIN =
    HistorySyncNotification_HistorySyncNotificationHistorySyncType_HistorySyncNotificationHistorySyncType_MIN;
  static constexpr HistorySyncNotificationHistorySyncType HistorySyncNotificationHistorySyncType_MAX =
    HistorySyncNotification_HistorySyncNotificationHistorySyncType_HistorySyncNotificationHistorySyncType_MAX;
  static constexpr int HistorySyncNotificationHistorySyncType_ARRAYSIZE =
    HistorySyncNotification_HistorySyncNotificationHistorySyncType_HistorySyncNotificationHistorySyncType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HistorySyncNotificationHistorySyncType_descriptor() {
    return HistorySyncNotification_HistorySyncNotificationHistorySyncType_descriptor();
  }
  template<typename T>
  static inline const std::string& HistorySyncNotificationHistorySyncType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HistorySyncNotificationHistorySyncType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HistorySyncNotificationHistorySyncType_Name.");
    return HistorySyncNotification_HistorySyncNotificationHistorySyncType_Name(enum_t_value);
  }
  static inline bool HistorySyncNotificationHistorySyncType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      HistorySyncNotificationHistorySyncType* value) {
    return HistorySyncNotification_HistorySyncNotificationHistorySyncType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFileSha256FieldNumber = 1,
    kMediaKeyFieldNumber = 3,
    kFileEncSha256FieldNumber = 4,
    kDirectPathFieldNumber = 5,
    kOriginalMessageIdFieldNumber = 8,
    kFileLengthFieldNumber = 2,
    kSyncTypeFieldNumber = 6,
    kChunkOrderFieldNumber = 7,
  };
  // optional bytes fileSha256 = 1;
  bool has_filesha256() const;
  private:
  bool _internal_has_filesha256() const;
  public:
  void clear_filesha256();
  const std::string& filesha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filesha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filesha256();
  PROTOBUF_NODISCARD std::string* release_filesha256();
  void set_allocated_filesha256(std::string* filesha256);
  private:
  const std::string& _internal_filesha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filesha256(const std::string& value);
  std::string* _internal_mutable_filesha256();
  public:

  // optional bytes mediaKey = 3;
  bool has_mediakey() const;
  private:
  bool _internal_has_mediakey() const;
  public:
  void clear_mediakey();
  const std::string& mediakey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mediakey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mediakey();
  PROTOBUF_NODISCARD std::string* release_mediakey();
  void set_allocated_mediakey(std::string* mediakey);
  private:
  const std::string& _internal_mediakey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mediakey(const std::string& value);
  std::string* _internal_mutable_mediakey();
  public:

  // optional bytes fileEncSha256 = 4;
  bool has_fileencsha256() const;
  private:
  bool _internal_has_fileencsha256() const;
  public:
  void clear_fileencsha256();
  const std::string& fileencsha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fileencsha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fileencsha256();
  PROTOBUF_NODISCARD std::string* release_fileencsha256();
  void set_allocated_fileencsha256(std::string* fileencsha256);
  private:
  const std::string& _internal_fileencsha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fileencsha256(const std::string& value);
  std::string* _internal_mutable_fileencsha256();
  public:

  // optional string directPath = 5;
  bool has_directpath() const;
  private:
  bool _internal_has_directpath() const;
  public:
  void clear_directpath();
  const std::string& directpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_directpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_directpath();
  PROTOBUF_NODISCARD std::string* release_directpath();
  void set_allocated_directpath(std::string* directpath);
  private:
  const std::string& _internal_directpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_directpath(const std::string& value);
  std::string* _internal_mutable_directpath();
  public:

  // optional string originalMessageId = 8;
  bool has_originalmessageid() const;
  private:
  bool _internal_has_originalmessageid() const;
  public:
  void clear_originalmessageid();
  const std::string& originalmessageid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_originalmessageid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_originalmessageid();
  PROTOBUF_NODISCARD std::string* release_originalmessageid();
  void set_allocated_originalmessageid(std::string* originalmessageid);
  private:
  const std::string& _internal_originalmessageid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_originalmessageid(const std::string& value);
  std::string* _internal_mutable_originalmessageid();
  public:

  // optional uint64 fileLength = 2;
  bool has_filelength() const;
  private:
  bool _internal_has_filelength() const;
  public:
  void clear_filelength();
  uint64_t filelength() const;
  void set_filelength(uint64_t value);
  private:
  uint64_t _internal_filelength() const;
  void _internal_set_filelength(uint64_t value);
  public:

  // optional .proto.HistorySyncNotification.HistorySyncNotificationHistorySyncType syncType = 6;
  bool has_synctype() const;
  private:
  bool _internal_has_synctype() const;
  public:
  void clear_synctype();
  ::proto::HistorySyncNotification_HistorySyncNotificationHistorySyncType synctype() const;
  void set_synctype(::proto::HistorySyncNotification_HistorySyncNotificationHistorySyncType value);
  private:
  ::proto::HistorySyncNotification_HistorySyncNotificationHistorySyncType _internal_synctype() const;
  void _internal_set_synctype(::proto::HistorySyncNotification_HistorySyncNotificationHistorySyncType value);
  public:

  // optional uint32 chunkOrder = 7;
  bool has_chunkorder() const;
  private:
  bool _internal_has_chunkorder() const;
  public:
  void clear_chunkorder();
  uint32_t chunkorder() const;
  void set_chunkorder(uint32_t value);
  private:
  uint32_t _internal_chunkorder() const;
  void _internal_set_chunkorder(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.HistorySyncNotification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filesha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mediakey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fileencsha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directpath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr originalmessageid_;
    uint64_t filelength_;
    int synctype_;
    uint32_t chunkorder_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class AppStateSyncKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.AppStateSyncKey) */ {
 public:
  inline AppStateSyncKey() : AppStateSyncKey(nullptr) {}
  ~AppStateSyncKey() override;
  explicit PROTOBUF_CONSTEXPR AppStateSyncKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppStateSyncKey(const AppStateSyncKey& from);
  AppStateSyncKey(AppStateSyncKey&& from) noexcept
    : AppStateSyncKey() {
    *this = ::std::move(from);
  }

  inline AppStateSyncKey& operator=(const AppStateSyncKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppStateSyncKey& operator=(AppStateSyncKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppStateSyncKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppStateSyncKey* internal_default_instance() {
    return reinterpret_cast<const AppStateSyncKey*>(
               &_AppStateSyncKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(AppStateSyncKey& a, AppStateSyncKey& b) {
    a.Swap(&b);
  }
  inline void Swap(AppStateSyncKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppStateSyncKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppStateSyncKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppStateSyncKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppStateSyncKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppStateSyncKey& from) {
    AppStateSyncKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppStateSyncKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.AppStateSyncKey";
  }
  protected:
  explicit AppStateSyncKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyIdFieldNumber = 1,
    kKeyDataFieldNumber = 2,
  };
  // optional .proto.AppStateSyncKeyId keyId = 1;
  bool has_keyid() const;
  private:
  bool _internal_has_keyid() const;
  public:
  void clear_keyid();
  const ::proto::AppStateSyncKeyId& keyid() const;
  PROTOBUF_NODISCARD ::proto::AppStateSyncKeyId* release_keyid();
  ::proto::AppStateSyncKeyId* mutable_keyid();
  void set_allocated_keyid(::proto::AppStateSyncKeyId* keyid);
  private:
  const ::proto::AppStateSyncKeyId& _internal_keyid() const;
  ::proto::AppStateSyncKeyId* _internal_mutable_keyid();
  public:
  void unsafe_arena_set_allocated_keyid(
      ::proto::AppStateSyncKeyId* keyid);
  ::proto::AppStateSyncKeyId* unsafe_arena_release_keyid();

  // optional .proto.AppStateSyncKeyData keyData = 2;
  bool has_keydata() const;
  private:
  bool _internal_has_keydata() const;
  public:
  void clear_keydata();
  const ::proto::AppStateSyncKeyData& keydata() const;
  PROTOBUF_NODISCARD ::proto::AppStateSyncKeyData* release_keydata();
  ::proto::AppStateSyncKeyData* mutable_keydata();
  void set_allocated_keydata(::proto::AppStateSyncKeyData* keydata);
  private:
  const ::proto::AppStateSyncKeyData& _internal_keydata() const;
  ::proto::AppStateSyncKeyData* _internal_mutable_keydata();
  public:
  void unsafe_arena_set_allocated_keydata(
      ::proto::AppStateSyncKeyData* keydata);
  ::proto::AppStateSyncKeyData* unsafe_arena_release_keydata();

  // @@protoc_insertion_point(class_scope:proto.AppStateSyncKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::proto::AppStateSyncKeyId* keyid_;
    ::proto::AppStateSyncKeyData* keydata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class AppStateSyncKeyId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.AppStateSyncKeyId) */ {
 public:
  inline AppStateSyncKeyId() : AppStateSyncKeyId(nullptr) {}
  ~AppStateSyncKeyId() override;
  explicit PROTOBUF_CONSTEXPR AppStateSyncKeyId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppStateSyncKeyId(const AppStateSyncKeyId& from);
  AppStateSyncKeyId(AppStateSyncKeyId&& from) noexcept
    : AppStateSyncKeyId() {
    *this = ::std::move(from);
  }

  inline AppStateSyncKeyId& operator=(const AppStateSyncKeyId& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppStateSyncKeyId& operator=(AppStateSyncKeyId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppStateSyncKeyId& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppStateSyncKeyId* internal_default_instance() {
    return reinterpret_cast<const AppStateSyncKeyId*>(
               &_AppStateSyncKeyId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(AppStateSyncKeyId& a, AppStateSyncKeyId& b) {
    a.Swap(&b);
  }
  inline void Swap(AppStateSyncKeyId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppStateSyncKeyId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppStateSyncKeyId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppStateSyncKeyId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppStateSyncKeyId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppStateSyncKeyId& from) {
    AppStateSyncKeyId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppStateSyncKeyId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.AppStateSyncKeyId";
  }
  protected:
  explicit AppStateSyncKeyId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyIdFieldNumber = 1,
  };
  // optional bytes keyId = 1;
  bool has_keyid() const;
  private:
  bool _internal_has_keyid() const;
  public:
  void clear_keyid();
  const std::string& keyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keyid();
  PROTOBUF_NODISCARD std::string* release_keyid();
  void set_allocated_keyid(std::string* keyid);
  private:
  const std::string& _internal_keyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keyid(const std::string& value);
  std::string* _internal_mutable_keyid();
  public:

  // @@protoc_insertion_point(class_scope:proto.AppStateSyncKeyId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keyid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class AppStateSyncKeyFingerprint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.AppStateSyncKeyFingerprint) */ {
 public:
  inline AppStateSyncKeyFingerprint() : AppStateSyncKeyFingerprint(nullptr) {}
  ~AppStateSyncKeyFingerprint() override;
  explicit PROTOBUF_CONSTEXPR AppStateSyncKeyFingerprint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppStateSyncKeyFingerprint(const AppStateSyncKeyFingerprint& from);
  AppStateSyncKeyFingerprint(AppStateSyncKeyFingerprint&& from) noexcept
    : AppStateSyncKeyFingerprint() {
    *this = ::std::move(from);
  }

  inline AppStateSyncKeyFingerprint& operator=(const AppStateSyncKeyFingerprint& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppStateSyncKeyFingerprint& operator=(AppStateSyncKeyFingerprint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppStateSyncKeyFingerprint& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppStateSyncKeyFingerprint* internal_default_instance() {
    return reinterpret_cast<const AppStateSyncKeyFingerprint*>(
               &_AppStateSyncKeyFingerprint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(AppStateSyncKeyFingerprint& a, AppStateSyncKeyFingerprint& b) {
    a.Swap(&b);
  }
  inline void Swap(AppStateSyncKeyFingerprint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppStateSyncKeyFingerprint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppStateSyncKeyFingerprint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppStateSyncKeyFingerprint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppStateSyncKeyFingerprint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppStateSyncKeyFingerprint& from) {
    AppStateSyncKeyFingerprint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppStateSyncKeyFingerprint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.AppStateSyncKeyFingerprint";
  }
  protected:
  explicit AppStateSyncKeyFingerprint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceIndexesFieldNumber = 3,
    kRawIdFieldNumber = 1,
    kCurrentIndexFieldNumber = 2,
  };
  // repeated uint32 deviceIndexes = 3 [packed = true];
  int deviceindexes_size() const;
  private:
  int _internal_deviceindexes_size() const;
  public:
  void clear_deviceindexes();
  private:
  uint32_t _internal_deviceindexes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_deviceindexes() const;
  void _internal_add_deviceindexes(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_deviceindexes();
  public:
  uint32_t deviceindexes(int index) const;
  void set_deviceindexes(int index, uint32_t value);
  void add_deviceindexes(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      deviceindexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_deviceindexes();

  // optional uint32 rawId = 1;
  bool has_rawid() const;
  private:
  bool _internal_has_rawid() const;
  public:
  void clear_rawid();
  uint32_t rawid() const;
  void set_rawid(uint32_t value);
  private:
  uint32_t _internal_rawid() const;
  void _internal_set_rawid(uint32_t value);
  public:

  // optional uint32 currentIndex = 2;
  bool has_currentindex() const;
  private:
  bool _internal_has_currentindex() const;
  public:
  void clear_currentindex();
  uint32_t currentindex() const;
  void set_currentindex(uint32_t value);
  private:
  uint32_t _internal_currentindex() const;
  void _internal_set_currentindex(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.AppStateSyncKeyFingerprint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > deviceindexes_;
    mutable std::atomic<int> _deviceindexes_cached_byte_size_;
    uint32_t rawid_;
    uint32_t currentindex_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class AppStateSyncKeyData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.AppStateSyncKeyData) */ {
 public:
  inline AppStateSyncKeyData() : AppStateSyncKeyData(nullptr) {}
  ~AppStateSyncKeyData() override;
  explicit PROTOBUF_CONSTEXPR AppStateSyncKeyData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppStateSyncKeyData(const AppStateSyncKeyData& from);
  AppStateSyncKeyData(AppStateSyncKeyData&& from) noexcept
    : AppStateSyncKeyData() {
    *this = ::std::move(from);
  }

  inline AppStateSyncKeyData& operator=(const AppStateSyncKeyData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppStateSyncKeyData& operator=(AppStateSyncKeyData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppStateSyncKeyData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppStateSyncKeyData* internal_default_instance() {
    return reinterpret_cast<const AppStateSyncKeyData*>(
               &_AppStateSyncKeyData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(AppStateSyncKeyData& a, AppStateSyncKeyData& b) {
    a.Swap(&b);
  }
  inline void Swap(AppStateSyncKeyData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppStateSyncKeyData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppStateSyncKeyData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppStateSyncKeyData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppStateSyncKeyData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppStateSyncKeyData& from) {
    AppStateSyncKeyData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppStateSyncKeyData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.AppStateSyncKeyData";
  }
  protected:
  explicit AppStateSyncKeyData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyDataFieldNumber = 1,
    kFingerprintFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // optional bytes keyData = 1;
  bool has_keydata() const;
  private:
  bool _internal_has_keydata() const;
  public:
  void clear_keydata();
  const std::string& keydata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keydata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keydata();
  PROTOBUF_NODISCARD std::string* release_keydata();
  void set_allocated_keydata(std::string* keydata);
  private:
  const std::string& _internal_keydata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keydata(const std::string& value);
  std::string* _internal_mutable_keydata();
  public:

  // optional .proto.AppStateSyncKeyFingerprint fingerprint = 2;
  bool has_fingerprint() const;
  private:
  bool _internal_has_fingerprint() const;
  public:
  void clear_fingerprint();
  const ::proto::AppStateSyncKeyFingerprint& fingerprint() const;
  PROTOBUF_NODISCARD ::proto::AppStateSyncKeyFingerprint* release_fingerprint();
  ::proto::AppStateSyncKeyFingerprint* mutable_fingerprint();
  void set_allocated_fingerprint(::proto::AppStateSyncKeyFingerprint* fingerprint);
  private:
  const ::proto::AppStateSyncKeyFingerprint& _internal_fingerprint() const;
  ::proto::AppStateSyncKeyFingerprint* _internal_mutable_fingerprint();
  public:
  void unsafe_arena_set_allocated_fingerprint(
      ::proto::AppStateSyncKeyFingerprint* fingerprint);
  ::proto::AppStateSyncKeyFingerprint* unsafe_arena_release_fingerprint();

  // optional int64 timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.AppStateSyncKeyData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keydata_;
    ::proto::AppStateSyncKeyFingerprint* fingerprint_;
    int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class AppStateSyncKeyShare final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.AppStateSyncKeyShare) */ {
 public:
  inline AppStateSyncKeyShare() : AppStateSyncKeyShare(nullptr) {}
  ~AppStateSyncKeyShare() override;
  explicit PROTOBUF_CONSTEXPR AppStateSyncKeyShare(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppStateSyncKeyShare(const AppStateSyncKeyShare& from);
  AppStateSyncKeyShare(AppStateSyncKeyShare&& from) noexcept
    : AppStateSyncKeyShare() {
    *this = ::std::move(from);
  }

  inline AppStateSyncKeyShare& operator=(const AppStateSyncKeyShare& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppStateSyncKeyShare& operator=(AppStateSyncKeyShare&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppStateSyncKeyShare& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppStateSyncKeyShare* internal_default_instance() {
    return reinterpret_cast<const AppStateSyncKeyShare*>(
               &_AppStateSyncKeyShare_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(AppStateSyncKeyShare& a, AppStateSyncKeyShare& b) {
    a.Swap(&b);
  }
  inline void Swap(AppStateSyncKeyShare* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppStateSyncKeyShare* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppStateSyncKeyShare* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppStateSyncKeyShare>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppStateSyncKeyShare& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppStateSyncKeyShare& from) {
    AppStateSyncKeyShare::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppStateSyncKeyShare* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.AppStateSyncKeyShare";
  }
  protected:
  explicit AppStateSyncKeyShare(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
  };
  // repeated .proto.AppStateSyncKey keys = 1;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  ::proto::AppStateSyncKey* mutable_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AppStateSyncKey >*
      mutable_keys();
  private:
  const ::proto::AppStateSyncKey& _internal_keys(int index) const;
  ::proto::AppStateSyncKey* _internal_add_keys();
  public:
  const ::proto::AppStateSyncKey& keys(int index) const;
  ::proto::AppStateSyncKey* add_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AppStateSyncKey >&
      keys() const;

  // @@protoc_insertion_point(class_scope:proto.AppStateSyncKeyShare)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AppStateSyncKey > keys_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class AppStateSyncKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.AppStateSyncKeyRequest) */ {
 public:
  inline AppStateSyncKeyRequest() : AppStateSyncKeyRequest(nullptr) {}
  ~AppStateSyncKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR AppStateSyncKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppStateSyncKeyRequest(const AppStateSyncKeyRequest& from);
  AppStateSyncKeyRequest(AppStateSyncKeyRequest&& from) noexcept
    : AppStateSyncKeyRequest() {
    *this = ::std::move(from);
  }

  inline AppStateSyncKeyRequest& operator=(const AppStateSyncKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppStateSyncKeyRequest& operator=(AppStateSyncKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppStateSyncKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppStateSyncKeyRequest* internal_default_instance() {
    return reinterpret_cast<const AppStateSyncKeyRequest*>(
               &_AppStateSyncKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(AppStateSyncKeyRequest& a, AppStateSyncKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AppStateSyncKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppStateSyncKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppStateSyncKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppStateSyncKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppStateSyncKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppStateSyncKeyRequest& from) {
    AppStateSyncKeyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppStateSyncKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.AppStateSyncKeyRequest";
  }
  protected:
  explicit AppStateSyncKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyIdsFieldNumber = 1,
  };
  // repeated .proto.AppStateSyncKeyId keyIds = 1;
  int keyids_size() const;
  private:
  int _internal_keyids_size() const;
  public:
  void clear_keyids();
  ::proto::AppStateSyncKeyId* mutable_keyids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AppStateSyncKeyId >*
      mutable_keyids();
  private:
  const ::proto::AppStateSyncKeyId& _internal_keyids(int index) const;
  ::proto::AppStateSyncKeyId* _internal_add_keyids();
  public:
  const ::proto::AppStateSyncKeyId& keyids(int index) const;
  ::proto::AppStateSyncKeyId* add_keyids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AppStateSyncKeyId >&
      keyids() const;

  // @@protoc_insertion_point(class_scope:proto.AppStateSyncKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AppStateSyncKeyId > keyids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class AppStateFatalExceptionNotification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.AppStateFatalExceptionNotification) */ {
 public:
  inline AppStateFatalExceptionNotification() : AppStateFatalExceptionNotification(nullptr) {}
  ~AppStateFatalExceptionNotification() override;
  explicit PROTOBUF_CONSTEXPR AppStateFatalExceptionNotification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppStateFatalExceptionNotification(const AppStateFatalExceptionNotification& from);
  AppStateFatalExceptionNotification(AppStateFatalExceptionNotification&& from) noexcept
    : AppStateFatalExceptionNotification() {
    *this = ::std::move(from);
  }

  inline AppStateFatalExceptionNotification& operator=(const AppStateFatalExceptionNotification& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppStateFatalExceptionNotification& operator=(AppStateFatalExceptionNotification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppStateFatalExceptionNotification& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppStateFatalExceptionNotification* internal_default_instance() {
    return reinterpret_cast<const AppStateFatalExceptionNotification*>(
               &_AppStateFatalExceptionNotification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(AppStateFatalExceptionNotification& a, AppStateFatalExceptionNotification& b) {
    a.Swap(&b);
  }
  inline void Swap(AppStateFatalExceptionNotification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppStateFatalExceptionNotification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppStateFatalExceptionNotification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppStateFatalExceptionNotification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppStateFatalExceptionNotification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppStateFatalExceptionNotification& from) {
    AppStateFatalExceptionNotification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppStateFatalExceptionNotification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.AppStateFatalExceptionNotification";
  }
  protected:
  explicit AppStateFatalExceptionNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectionNamesFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // repeated string collectionNames = 1;
  int collectionnames_size() const;
  private:
  int _internal_collectionnames_size() const;
  public:
  void clear_collectionnames();
  const std::string& collectionnames(int index) const;
  std::string* mutable_collectionnames(int index);
  void set_collectionnames(int index, const std::string& value);
  void set_collectionnames(int index, std::string&& value);
  void set_collectionnames(int index, const char* value);
  void set_collectionnames(int index, const char* value, size_t size);
  std::string* add_collectionnames();
  void add_collectionnames(const std::string& value);
  void add_collectionnames(std::string&& value);
  void add_collectionnames(const char* value);
  void add_collectionnames(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& collectionnames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_collectionnames();
  private:
  const std::string& _internal_collectionnames(int index) const;
  std::string* _internal_add_collectionnames();
  public:

  // optional int64 timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.AppStateFatalExceptionNotification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> collectionnames_;
    int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class InitialSecurityNotificationSettingSync final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.InitialSecurityNotificationSettingSync) */ {
 public:
  inline InitialSecurityNotificationSettingSync() : InitialSecurityNotificationSettingSync(nullptr) {}
  ~InitialSecurityNotificationSettingSync() override;
  explicit PROTOBUF_CONSTEXPR InitialSecurityNotificationSettingSync(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitialSecurityNotificationSettingSync(const InitialSecurityNotificationSettingSync& from);
  InitialSecurityNotificationSettingSync(InitialSecurityNotificationSettingSync&& from) noexcept
    : InitialSecurityNotificationSettingSync() {
    *this = ::std::move(from);
  }

  inline InitialSecurityNotificationSettingSync& operator=(const InitialSecurityNotificationSettingSync& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitialSecurityNotificationSettingSync& operator=(InitialSecurityNotificationSettingSync&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitialSecurityNotificationSettingSync& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitialSecurityNotificationSettingSync* internal_default_instance() {
    return reinterpret_cast<const InitialSecurityNotificationSettingSync*>(
               &_InitialSecurityNotificationSettingSync_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(InitialSecurityNotificationSettingSync& a, InitialSecurityNotificationSettingSync& b) {
    a.Swap(&b);
  }
  inline void Swap(InitialSecurityNotificationSettingSync* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitialSecurityNotificationSettingSync* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitialSecurityNotificationSettingSync* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitialSecurityNotificationSettingSync>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitialSecurityNotificationSettingSync& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitialSecurityNotificationSettingSync& from) {
    InitialSecurityNotificationSettingSync::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitialSecurityNotificationSettingSync* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.InitialSecurityNotificationSettingSync";
  }
  protected:
  explicit InitialSecurityNotificationSettingSync(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityNotificationEnabledFieldNumber = 1,
  };
  // optional bool securityNotificationEnabled = 1;
  bool has_securitynotificationenabled() const;
  private:
  bool _internal_has_securitynotificationenabled() const;
  public:
  void clear_securitynotificationenabled();
  bool securitynotificationenabled() const;
  void set_securitynotificationenabled(bool value);
  private:
  bool _internal_securitynotificationenabled() const;
  void _internal_set_securitynotificationenabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.InitialSecurityNotificationSettingSync)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool securitynotificationenabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class ContactsArrayMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ContactsArrayMessage) */ {
 public:
  inline ContactsArrayMessage() : ContactsArrayMessage(nullptr) {}
  ~ContactsArrayMessage() override;
  explicit PROTOBUF_CONSTEXPR ContactsArrayMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContactsArrayMessage(const ContactsArrayMessage& from);
  ContactsArrayMessage(ContactsArrayMessage&& from) noexcept
    : ContactsArrayMessage() {
    *this = ::std::move(from);
  }

  inline ContactsArrayMessage& operator=(const ContactsArrayMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContactsArrayMessage& operator=(ContactsArrayMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContactsArrayMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContactsArrayMessage* internal_default_instance() {
    return reinterpret_cast<const ContactsArrayMessage*>(
               &_ContactsArrayMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ContactsArrayMessage& a, ContactsArrayMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ContactsArrayMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContactsArrayMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContactsArrayMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContactsArrayMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContactsArrayMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContactsArrayMessage& from) {
    ContactsArrayMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContactsArrayMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ContactsArrayMessage";
  }
  protected:
  explicit ContactsArrayMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContactsFieldNumber = 2,
    kDisplayNameFieldNumber = 1,
    kContextInfoFieldNumber = 17,
  };
  // repeated .proto.ContactMessage contacts = 2;
  int contacts_size() const;
  private:
  int _internal_contacts_size() const;
  public:
  void clear_contacts();
  ::proto::ContactMessage* mutable_contacts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ContactMessage >*
      mutable_contacts();
  private:
  const ::proto::ContactMessage& _internal_contacts(int index) const;
  ::proto::ContactMessage* _internal_add_contacts();
  public:
  const ::proto::ContactMessage& contacts(int index) const;
  ::proto::ContactMessage* add_contacts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ContactMessage >&
      contacts() const;

  // optional string displayName = 1;
  bool has_displayname() const;
  private:
  bool _internal_has_displayname() const;
  public:
  void clear_displayname();
  const std::string& displayname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_displayname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_displayname();
  PROTOBUF_NODISCARD std::string* release_displayname();
  void set_allocated_displayname(std::string* displayname);
  private:
  const std::string& _internal_displayname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_displayname(const std::string& value);
  std::string* _internal_mutable_displayname();
  public:

  // optional .proto.ContextInfo contextInfo = 17;
  bool has_contextinfo() const;
  private:
  bool _internal_has_contextinfo() const;
  public:
  void clear_contextinfo();
  const ::proto::ContextInfo& contextinfo() const;
  PROTOBUF_NODISCARD ::proto::ContextInfo* release_contextinfo();
  ::proto::ContextInfo* mutable_contextinfo();
  void set_allocated_contextinfo(::proto::ContextInfo* contextinfo);
  private:
  const ::proto::ContextInfo& _internal_contextinfo() const;
  ::proto::ContextInfo* _internal_mutable_contextinfo();
  public:
  void unsafe_arena_set_allocated_contextinfo(
      ::proto::ContextInfo* contextinfo);
  ::proto::ContextInfo* unsafe_arena_release_contextinfo();

  // @@protoc_insertion_point(class_scope:proto.ContactsArrayMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ContactMessage > contacts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr displayname_;
    ::proto::ContextInfo* contextinfo_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class HSMCurrency final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.HSMCurrency) */ {
 public:
  inline HSMCurrency() : HSMCurrency(nullptr) {}
  ~HSMCurrency() override;
  explicit PROTOBUF_CONSTEXPR HSMCurrency(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HSMCurrency(const HSMCurrency& from);
  HSMCurrency(HSMCurrency&& from) noexcept
    : HSMCurrency() {
    *this = ::std::move(from);
  }

  inline HSMCurrency& operator=(const HSMCurrency& from) {
    CopyFrom(from);
    return *this;
  }
  inline HSMCurrency& operator=(HSMCurrency&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HSMCurrency& default_instance() {
    return *internal_default_instance();
  }
  static inline const HSMCurrency* internal_default_instance() {
    return reinterpret_cast<const HSMCurrency*>(
               &_HSMCurrency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(HSMCurrency& a, HSMCurrency& b) {
    a.Swap(&b);
  }
  inline void Swap(HSMCurrency* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HSMCurrency* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HSMCurrency* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HSMCurrency>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HSMCurrency& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HSMCurrency& from) {
    HSMCurrency::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HSMCurrency* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HSMCurrency";
  }
  protected:
  explicit HSMCurrency(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrencyCodeFieldNumber = 1,
    kAmount1000FieldNumber = 2,
  };
  // optional string currencyCode = 1;
  bool has_currencycode() const;
  private:
  bool _internal_has_currencycode() const;
  public:
  void clear_currencycode();
  const std::string& currencycode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currencycode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currencycode();
  PROTOBUF_NODISCARD std::string* release_currencycode();
  void set_allocated_currencycode(std::string* currencycode);
  private:
  const std::string& _internal_currencycode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currencycode(const std::string& value);
  std::string* _internal_mutable_currencycode();
  public:

  // optional int64 amount1000 = 2;
  bool has_amount1000() const;
  private:
  bool _internal_has_amount1000() const;
  public:
  void clear_amount1000();
  int64_t amount1000() const;
  void set_amount1000(int64_t value);
  private:
  int64_t _internal_amount1000() const;
  void _internal_set_amount1000(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.HSMCurrency)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currencycode_;
    int64_t amount1000_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class HSMDateTimeComponent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.HSMDateTimeComponent) */ {
 public:
  inline HSMDateTimeComponent() : HSMDateTimeComponent(nullptr) {}
  ~HSMDateTimeComponent() override;
  explicit PROTOBUF_CONSTEXPR HSMDateTimeComponent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HSMDateTimeComponent(const HSMDateTimeComponent& from);
  HSMDateTimeComponent(HSMDateTimeComponent&& from) noexcept
    : HSMDateTimeComponent() {
    *this = ::std::move(from);
  }

  inline HSMDateTimeComponent& operator=(const HSMDateTimeComponent& from) {
    CopyFrom(from);
    return *this;
  }
  inline HSMDateTimeComponent& operator=(HSMDateTimeComponent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HSMDateTimeComponent& default_instance() {
    return *internal_default_instance();
  }
  static inline const HSMDateTimeComponent* internal_default_instance() {
    return reinterpret_cast<const HSMDateTimeComponent*>(
               &_HSMDateTimeComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(HSMDateTimeComponent& a, HSMDateTimeComponent& b) {
    a.Swap(&b);
  }
  inline void Swap(HSMDateTimeComponent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HSMDateTimeComponent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HSMDateTimeComponent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HSMDateTimeComponent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HSMDateTimeComponent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HSMDateTimeComponent& from) {
    HSMDateTimeComponent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HSMDateTimeComponent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HSMDateTimeComponent";
  }
  protected:
  explicit HSMDateTimeComponent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType HSMDateTimeComponentDayOfWeekType;
  static constexpr HSMDateTimeComponentDayOfWeekType MONDAY =
    HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_MONDAY;
  static constexpr HSMDateTimeComponentDayOfWeekType TUESDAY =
    HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_TUESDAY;
  static constexpr HSMDateTimeComponentDayOfWeekType WEDNESDAY =
    HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_WEDNESDAY;
  static constexpr HSMDateTimeComponentDayOfWeekType THURSDAY =
    HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_THURSDAY;
  static constexpr HSMDateTimeComponentDayOfWeekType FRIDAY =
    HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_FRIDAY;
  static constexpr HSMDateTimeComponentDayOfWeekType SATURDAY =
    HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_SATURDAY;
  static constexpr HSMDateTimeComponentDayOfWeekType SUNDAY =
    HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_SUNDAY;
  static inline bool HSMDateTimeComponentDayOfWeekType_IsValid(int value) {
    return HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_IsValid(value);
  }
  static constexpr HSMDateTimeComponentDayOfWeekType HSMDateTimeComponentDayOfWeekType_MIN =
    HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_HSMDateTimeComponentDayOfWeekType_MIN;
  static constexpr HSMDateTimeComponentDayOfWeekType HSMDateTimeComponentDayOfWeekType_MAX =
    HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_HSMDateTimeComponentDayOfWeekType_MAX;
  static constexpr int HSMDateTimeComponentDayOfWeekType_ARRAYSIZE =
    HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_HSMDateTimeComponentDayOfWeekType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HSMDateTimeComponentDayOfWeekType_descriptor() {
    return HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_descriptor();
  }
  template<typename T>
  static inline const std::string& HSMDateTimeComponentDayOfWeekType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HSMDateTimeComponentDayOfWeekType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HSMDateTimeComponentDayOfWeekType_Name.");
    return HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_Name(enum_t_value);
  }
  static inline bool HSMDateTimeComponentDayOfWeekType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      HSMDateTimeComponentDayOfWeekType* value) {
    return HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_Parse(name, value);
  }

  typedef HSMDateTimeComponent_HSMDateTimeComponentCalendarType HSMDateTimeComponentCalendarType;
  static constexpr HSMDateTimeComponentCalendarType GREGORIAN =
    HSMDateTimeComponent_HSMDateTimeComponentCalendarType_GREGORIAN;
  static constexpr HSMDateTimeComponentCalendarType SOLAR_HIJRI =
    HSMDateTimeComponent_HSMDateTimeComponentCalendarType_SOLAR_HIJRI;
  static inline bool HSMDateTimeComponentCalendarType_IsValid(int value) {
    return HSMDateTimeComponent_HSMDateTimeComponentCalendarType_IsValid(value);
  }
  static constexpr HSMDateTimeComponentCalendarType HSMDateTimeComponentCalendarType_MIN =
    HSMDateTimeComponent_HSMDateTimeComponentCalendarType_HSMDateTimeComponentCalendarType_MIN;
  static constexpr HSMDateTimeComponentCalendarType HSMDateTimeComponentCalendarType_MAX =
    HSMDateTimeComponent_HSMDateTimeComponentCalendarType_HSMDateTimeComponentCalendarType_MAX;
  static constexpr int HSMDateTimeComponentCalendarType_ARRAYSIZE =
    HSMDateTimeComponent_HSMDateTimeComponentCalendarType_HSMDateTimeComponentCalendarType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HSMDateTimeComponentCalendarType_descriptor() {
    return HSMDateTimeComponent_HSMDateTimeComponentCalendarType_descriptor();
  }
  template<typename T>
  static inline const std::string& HSMDateTimeComponentCalendarType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HSMDateTimeComponentCalendarType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HSMDateTimeComponentCalendarType_Name.");
    return HSMDateTimeComponent_HSMDateTimeComponentCalendarType_Name(enum_t_value);
  }
  static inline bool HSMDateTimeComponentCalendarType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      HSMDateTimeComponentCalendarType* value) {
    return HSMDateTimeComponent_HSMDateTimeComponentCalendarType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kYearFieldNumber = 2,
    kMonthFieldNumber = 3,
    kDayOfMonthFieldNumber = 4,
    kHourFieldNumber = 5,
    kMinuteFieldNumber = 6,
    kDayOfWeekFieldNumber = 1,
    kCalendarFieldNumber = 7,
  };
  // optional uint32 year = 2;
  bool has_year() const;
  private:
  bool _internal_has_year() const;
  public:
  void clear_year();
  uint32_t year() const;
  void set_year(uint32_t value);
  private:
  uint32_t _internal_year() const;
  void _internal_set_year(uint32_t value);
  public:

  // optional uint32 month = 3;
  bool has_month() const;
  private:
  bool _internal_has_month() const;
  public:
  void clear_month();
  uint32_t month() const;
  void set_month(uint32_t value);
  private:
  uint32_t _internal_month() const;
  void _internal_set_month(uint32_t value);
  public:

  // optional uint32 dayOfMonth = 4;
  bool has_dayofmonth() const;
  private:
  bool _internal_has_dayofmonth() const;
  public:
  void clear_dayofmonth();
  uint32_t dayofmonth() const;
  void set_dayofmonth(uint32_t value);
  private:
  uint32_t _internal_dayofmonth() const;
  void _internal_set_dayofmonth(uint32_t value);
  public:

  // optional uint32 hour = 5;
  bool has_hour() const;
  private:
  bool _internal_has_hour() const;
  public:
  void clear_hour();
  uint32_t hour() const;
  void set_hour(uint32_t value);
  private:
  uint32_t _internal_hour() const;
  void _internal_set_hour(uint32_t value);
  public:

  // optional uint32 minute = 6;
  bool has_minute() const;
  private:
  bool _internal_has_minute() const;
  public:
  void clear_minute();
  uint32_t minute() const;
  void set_minute(uint32_t value);
  private:
  uint32_t _internal_minute() const;
  void _internal_set_minute(uint32_t value);
  public:

  // optional .proto.HSMDateTimeComponent.HSMDateTimeComponentDayOfWeekType dayOfWeek = 1;
  bool has_dayofweek() const;
  private:
  bool _internal_has_dayofweek() const;
  public:
  void clear_dayofweek();
  ::proto::HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType dayofweek() const;
  void set_dayofweek(::proto::HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType value);
  private:
  ::proto::HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType _internal_dayofweek() const;
  void _internal_set_dayofweek(::proto::HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType value);
  public:

  // optional .proto.HSMDateTimeComponent.HSMDateTimeComponentCalendarType calendar = 7;
  bool has_calendar() const;
  private:
  bool _internal_has_calendar() const;
  public:
  void clear_calendar();
  ::proto::HSMDateTimeComponent_HSMDateTimeComponentCalendarType calendar() const;
  void set_calendar(::proto::HSMDateTimeComponent_HSMDateTimeComponentCalendarType value);
  private:
  ::proto::HSMDateTimeComponent_HSMDateTimeComponentCalendarType _internal_calendar() const;
  void _internal_set_calendar(::proto::HSMDateTimeComponent_HSMDateTimeComponentCalendarType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.HSMDateTimeComponent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t year_;
    uint32_t month_;
    uint32_t dayofmonth_;
    uint32_t hour_;
    uint32_t minute_;
    int dayofweek_;
    int calendar_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class HSMDateTimeUnixEpoch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.HSMDateTimeUnixEpoch) */ {
 public:
  inline HSMDateTimeUnixEpoch() : HSMDateTimeUnixEpoch(nullptr) {}
  ~HSMDateTimeUnixEpoch() override;
  explicit PROTOBUF_CONSTEXPR HSMDateTimeUnixEpoch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HSMDateTimeUnixEpoch(const HSMDateTimeUnixEpoch& from);
  HSMDateTimeUnixEpoch(HSMDateTimeUnixEpoch&& from) noexcept
    : HSMDateTimeUnixEpoch() {
    *this = ::std::move(from);
  }

  inline HSMDateTimeUnixEpoch& operator=(const HSMDateTimeUnixEpoch& from) {
    CopyFrom(from);
    return *this;
  }
  inline HSMDateTimeUnixEpoch& operator=(HSMDateTimeUnixEpoch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HSMDateTimeUnixEpoch& default_instance() {
    return *internal_default_instance();
  }
  static inline const HSMDateTimeUnixEpoch* internal_default_instance() {
    return reinterpret_cast<const HSMDateTimeUnixEpoch*>(
               &_HSMDateTimeUnixEpoch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(HSMDateTimeUnixEpoch& a, HSMDateTimeUnixEpoch& b) {
    a.Swap(&b);
  }
  inline void Swap(HSMDateTimeUnixEpoch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HSMDateTimeUnixEpoch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HSMDateTimeUnixEpoch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HSMDateTimeUnixEpoch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HSMDateTimeUnixEpoch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HSMDateTimeUnixEpoch& from) {
    HSMDateTimeUnixEpoch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HSMDateTimeUnixEpoch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HSMDateTimeUnixEpoch";
  }
  protected:
  explicit HSMDateTimeUnixEpoch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // optional int64 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.HSMDateTimeUnixEpoch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class HSMDateTime final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.HSMDateTime) */ {
 public:
  inline HSMDateTime() : HSMDateTime(nullptr) {}
  ~HSMDateTime() override;
  explicit PROTOBUF_CONSTEXPR HSMDateTime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HSMDateTime(const HSMDateTime& from);
  HSMDateTime(HSMDateTime&& from) noexcept
    : HSMDateTime() {
    *this = ::std::move(from);
  }

  inline HSMDateTime& operator=(const HSMDateTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline HSMDateTime& operator=(HSMDateTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HSMDateTime& default_instance() {
    return *internal_default_instance();
  }
  enum DatetimeOneofCase {
    kComponent = 1,
    kUnixEpoch = 2,
    DATETIMEONEOF_NOT_SET = 0,
  };

  static inline const HSMDateTime* internal_default_instance() {
    return reinterpret_cast<const HSMDateTime*>(
               &_HSMDateTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(HSMDateTime& a, HSMDateTime& b) {
    a.Swap(&b);
  }
  inline void Swap(HSMDateTime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HSMDateTime* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HSMDateTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HSMDateTime>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HSMDateTime& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HSMDateTime& from) {
    HSMDateTime::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HSMDateTime* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HSMDateTime";
  }
  protected:
  explicit HSMDateTime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComponentFieldNumber = 1,
    kUnixEpochFieldNumber = 2,
  };
  // .proto.HSMDateTimeComponent component = 1;
  bool has_component() const;
  private:
  bool _internal_has_component() const;
  public:
  void clear_component();
  const ::proto::HSMDateTimeComponent& component() const;
  PROTOBUF_NODISCARD ::proto::HSMDateTimeComponent* release_component();
  ::proto::HSMDateTimeComponent* mutable_component();
  void set_allocated_component(::proto::HSMDateTimeComponent* component);
  private:
  const ::proto::HSMDateTimeComponent& _internal_component() const;
  ::proto::HSMDateTimeComponent* _internal_mutable_component();
  public:
  void unsafe_arena_set_allocated_component(
      ::proto::HSMDateTimeComponent* component);
  ::proto::HSMDateTimeComponent* unsafe_arena_release_component();

  // .proto.HSMDateTimeUnixEpoch unixEpoch = 2;
  bool has_unixepoch() const;
  private:
  bool _internal_has_unixepoch() const;
  public:
  void clear_unixepoch();
  const ::proto::HSMDateTimeUnixEpoch& unixepoch() const;
  PROTOBUF_NODISCARD ::proto::HSMDateTimeUnixEpoch* release_unixepoch();
  ::proto::HSMDateTimeUnixEpoch* mutable_unixepoch();
  void set_allocated_unixepoch(::proto::HSMDateTimeUnixEpoch* unixepoch);
  private:
  const ::proto::HSMDateTimeUnixEpoch& _internal_unixepoch() const;
  ::proto::HSMDateTimeUnixEpoch* _internal_mutable_unixepoch();
  public:
  void unsafe_arena_set_allocated_unixepoch(
      ::proto::HSMDateTimeUnixEpoch* unixepoch);
  ::proto::HSMDateTimeUnixEpoch* unsafe_arena_release_unixepoch();

  void clear_datetimeOneof();
  DatetimeOneofCase datetimeOneof_case() const;
  // @@protoc_insertion_point(class_scope:proto.HSMDateTime)
 private:
  class _Internal;
  void set_has_component();
  void set_has_unixepoch();

  inline bool has_datetimeOneof() const;
  inline void clear_has_datetimeOneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union DatetimeOneofUnion {
      constexpr DatetimeOneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::proto::HSMDateTimeComponent* component_;
      ::proto::HSMDateTimeUnixEpoch* unixepoch_;
    } datetimeOneof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class HSMLocalizableParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.HSMLocalizableParameter) */ {
 public:
  inline HSMLocalizableParameter() : HSMLocalizableParameter(nullptr) {}
  ~HSMLocalizableParameter() override;
  explicit PROTOBUF_CONSTEXPR HSMLocalizableParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HSMLocalizableParameter(const HSMLocalizableParameter& from);
  HSMLocalizableParameter(HSMLocalizableParameter&& from) noexcept
    : HSMLocalizableParameter() {
    *this = ::std::move(from);
  }

  inline HSMLocalizableParameter& operator=(const HSMLocalizableParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline HSMLocalizableParameter& operator=(HSMLocalizableParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HSMLocalizableParameter& default_instance() {
    return *internal_default_instance();
  }
  enum ParamOneofCase {
    kCurrency = 2,
    kDateTime = 3,
    PARAMONEOF_NOT_SET = 0,
  };

  static inline const HSMLocalizableParameter* internal_default_instance() {
    return reinterpret_cast<const HSMLocalizableParameter*>(
               &_HSMLocalizableParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(HSMLocalizableParameter& a, HSMLocalizableParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(HSMLocalizableParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HSMLocalizableParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HSMLocalizableParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HSMLocalizableParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HSMLocalizableParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HSMLocalizableParameter& from) {
    HSMLocalizableParameter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HSMLocalizableParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HSMLocalizableParameter";
  }
  protected:
  explicit HSMLocalizableParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDefaultFieldNumber = 1,
    kCurrencyFieldNumber = 2,
    kDateTimeFieldNumber = 3,
  };
  // optional string default = 1;
  bool has_default_() const;
  private:
  bool _internal_has_default_() const;
  public:
  void clear_default_();
  const std::string& default_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_();
  PROTOBUF_NODISCARD std::string* release_default_();
  void set_allocated_default_(std::string* default_);
  private:
  const std::string& _internal_default_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_(const std::string& value);
  std::string* _internal_mutable_default_();
  public:

  // .proto.HSMCurrency currency = 2;
  bool has_currency() const;
  private:
  bool _internal_has_currency() const;
  public:
  void clear_currency();
  const ::proto::HSMCurrency& currency() const;
  PROTOBUF_NODISCARD ::proto::HSMCurrency* release_currency();
  ::proto::HSMCurrency* mutable_currency();
  void set_allocated_currency(::proto::HSMCurrency* currency);
  private:
  const ::proto::HSMCurrency& _internal_currency() const;
  ::proto::HSMCurrency* _internal_mutable_currency();
  public:
  void unsafe_arena_set_allocated_currency(
      ::proto::HSMCurrency* currency);
  ::proto::HSMCurrency* unsafe_arena_release_currency();

  // .proto.HSMDateTime dateTime = 3;
  bool has_datetime() const;
  private:
  bool _internal_has_datetime() const;
  public:
  void clear_datetime();
  const ::proto::HSMDateTime& datetime() const;
  PROTOBUF_NODISCARD ::proto::HSMDateTime* release_datetime();
  ::proto::HSMDateTime* mutable_datetime();
  void set_allocated_datetime(::proto::HSMDateTime* datetime);
  private:
  const ::proto::HSMDateTime& _internal_datetime() const;
  ::proto::HSMDateTime* _internal_mutable_datetime();
  public:
  void unsafe_arena_set_allocated_datetime(
      ::proto::HSMDateTime* datetime);
  ::proto::HSMDateTime* unsafe_arena_release_datetime();

  void clear_paramOneof();
  ParamOneofCase paramOneof_case() const;
  // @@protoc_insertion_point(class_scope:proto.HSMLocalizableParameter)
 private:
  class _Internal;
  void set_has_currency();
  void set_has_datetime();

  inline bool has_paramOneof() const;
  inline void clear_has_paramOneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default__;
    union ParamOneofUnion {
      constexpr ParamOneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::proto::HSMCurrency* currency_;
      ::proto::HSMDateTime* datetime_;
    } paramOneof_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class HighlyStructuredMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.HighlyStructuredMessage) */ {
 public:
  inline HighlyStructuredMessage() : HighlyStructuredMessage(nullptr) {}
  ~HighlyStructuredMessage() override;
  explicit PROTOBUF_CONSTEXPR HighlyStructuredMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HighlyStructuredMessage(const HighlyStructuredMessage& from);
  HighlyStructuredMessage(HighlyStructuredMessage&& from) noexcept
    : HighlyStructuredMessage() {
    *this = ::std::move(from);
  }

  inline HighlyStructuredMessage& operator=(const HighlyStructuredMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline HighlyStructuredMessage& operator=(HighlyStructuredMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HighlyStructuredMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const HighlyStructuredMessage* internal_default_instance() {
    return reinterpret_cast<const HighlyStructuredMessage*>(
               &_HighlyStructuredMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(HighlyStructuredMessage& a, HighlyStructuredMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(HighlyStructuredMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HighlyStructuredMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HighlyStructuredMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HighlyStructuredMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HighlyStructuredMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HighlyStructuredMessage& from) {
    HighlyStructuredMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HighlyStructuredMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HighlyStructuredMessage";
  }
  protected:
  explicit HighlyStructuredMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 3,
    kLocalizableParamsFieldNumber = 6,
    kNamespaceFieldNumber = 1,
    kElementNameFieldNumber = 2,
    kFallbackLgFieldNumber = 4,
    kFallbackLcFieldNumber = 5,
    kDeterministicLgFieldNumber = 7,
    kDeterministicLcFieldNumber = 8,
    kHydratedHsmFieldNumber = 9,
  };
  // repeated string params = 3;
  int params_size() const;
  private:
  int _internal_params_size() const;
  public:
  void clear_params();
  const std::string& params(int index) const;
  std::string* mutable_params(int index);
  void set_params(int index, const std::string& value);
  void set_params(int index, std::string&& value);
  void set_params(int index, const char* value);
  void set_params(int index, const char* value, size_t size);
  std::string* add_params();
  void add_params(const std::string& value);
  void add_params(std::string&& value);
  void add_params(const char* value);
  void add_params(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& params() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_params();
  private:
  const std::string& _internal_params(int index) const;
  std::string* _internal_add_params();
  public:

  // repeated .proto.HSMLocalizableParameter localizableParams = 6;
  int localizableparams_size() const;
  private:
  int _internal_localizableparams_size() const;
  public:
  void clear_localizableparams();
  ::proto::HSMLocalizableParameter* mutable_localizableparams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::HSMLocalizableParameter >*
      mutable_localizableparams();
  private:
  const ::proto::HSMLocalizableParameter& _internal_localizableparams(int index) const;
  ::proto::HSMLocalizableParameter* _internal_add_localizableparams();
  public:
  const ::proto::HSMLocalizableParameter& localizableparams(int index) const;
  ::proto::HSMLocalizableParameter* add_localizableparams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::HSMLocalizableParameter >&
      localizableparams() const;

  // optional string namespace = 1;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // optional string elementName = 2;
  bool has_elementname() const;
  private:
  bool _internal_has_elementname() const;
  public:
  void clear_elementname();
  const std::string& elementname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_elementname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_elementname();
  PROTOBUF_NODISCARD std::string* release_elementname();
  void set_allocated_elementname(std::string* elementname);
  private:
  const std::string& _internal_elementname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_elementname(const std::string& value);
  std::string* _internal_mutable_elementname();
  public:

  // optional string fallbackLg = 4;
  bool has_fallbacklg() const;
  private:
  bool _internal_has_fallbacklg() const;
  public:
  void clear_fallbacklg();
  const std::string& fallbacklg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fallbacklg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fallbacklg();
  PROTOBUF_NODISCARD std::string* release_fallbacklg();
  void set_allocated_fallbacklg(std::string* fallbacklg);
  private:
  const std::string& _internal_fallbacklg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fallbacklg(const std::string& value);
  std::string* _internal_mutable_fallbacklg();
  public:

  // optional string fallbackLc = 5;
  bool has_fallbacklc() const;
  private:
  bool _internal_has_fallbacklc() const;
  public:
  void clear_fallbacklc();
  const std::string& fallbacklc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fallbacklc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fallbacklc();
  PROTOBUF_NODISCARD std::string* release_fallbacklc();
  void set_allocated_fallbacklc(std::string* fallbacklc);
  private:
  const std::string& _internal_fallbacklc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fallbacklc(const std::string& value);
  std::string* _internal_mutable_fallbacklc();
  public:

  // optional string deterministicLg = 7;
  bool has_deterministiclg() const;
  private:
  bool _internal_has_deterministiclg() const;
  public:
  void clear_deterministiclg();
  const std::string& deterministiclg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deterministiclg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deterministiclg();
  PROTOBUF_NODISCARD std::string* release_deterministiclg();
  void set_allocated_deterministiclg(std::string* deterministiclg);
  private:
  const std::string& _internal_deterministiclg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deterministiclg(const std::string& value);
  std::string* _internal_mutable_deterministiclg();
  public:

  // optional string deterministicLc = 8;
  bool has_deterministiclc() const;
  private:
  bool _internal_has_deterministiclc() const;
  public:
  void clear_deterministiclc();
  const std::string& deterministiclc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deterministiclc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deterministiclc();
  PROTOBUF_NODISCARD std::string* release_deterministiclc();
  void set_allocated_deterministiclc(std::string* deterministiclc);
  private:
  const std::string& _internal_deterministiclc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deterministiclc(const std::string& value);
  std::string* _internal_mutable_deterministiclc();
  public:

  // optional .proto.TemplateMessage hydratedHsm = 9;
  bool has_hydratedhsm() const;
  private:
  bool _internal_has_hydratedhsm() const;
  public:
  void clear_hydratedhsm();
  const ::proto::TemplateMessage& hydratedhsm() const;
  PROTOBUF_NODISCARD ::proto::TemplateMessage* release_hydratedhsm();
  ::proto::TemplateMessage* mutable_hydratedhsm();
  void set_allocated_hydratedhsm(::proto::TemplateMessage* hydratedhsm);
  private:
  const ::proto::TemplateMessage& _internal_hydratedhsm() const;
  ::proto::TemplateMessage* _internal_mutable_hydratedhsm();
  public:
  void unsafe_arena_set_allocated_hydratedhsm(
      ::proto::TemplateMessage* hydratedhsm);
  ::proto::TemplateMessage* unsafe_arena_release_hydratedhsm();

  // @@protoc_insertion_point(class_scope:proto.HighlyStructuredMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> params_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::HSMLocalizableParameter > localizableparams_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr elementname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fallbacklg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fallbacklc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deterministiclg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deterministiclc_;
    ::proto::TemplateMessage* hydratedhsm_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class SendPaymentMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.SendPaymentMessage) */ {
 public:
  inline SendPaymentMessage() : SendPaymentMessage(nullptr) {}
  ~SendPaymentMessage() override;
  explicit PROTOBUF_CONSTEXPR SendPaymentMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendPaymentMessage(const SendPaymentMessage& from);
  SendPaymentMessage(SendPaymentMessage&& from) noexcept
    : SendPaymentMessage() {
    *this = ::std::move(from);
  }

  inline SendPaymentMessage& operator=(const SendPaymentMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendPaymentMessage& operator=(SendPaymentMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendPaymentMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendPaymentMessage* internal_default_instance() {
    return reinterpret_cast<const SendPaymentMessage*>(
               &_SendPaymentMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(SendPaymentMessage& a, SendPaymentMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SendPaymentMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendPaymentMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendPaymentMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendPaymentMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendPaymentMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendPaymentMessage& from) {
    SendPaymentMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendPaymentMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SendPaymentMessage";
  }
  protected:
  explicit SendPaymentMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoteMessageFieldNumber = 2,
    kRequestMessageKeyFieldNumber = 3,
  };
  // optional .proto.Message noteMessage = 2;
  bool has_notemessage() const;
  private:
  bool _internal_has_notemessage() const;
  public:
  void clear_notemessage();
  const ::proto::Message& notemessage() const;
  PROTOBUF_NODISCARD ::proto::Message* release_notemessage();
  ::proto::Message* mutable_notemessage();
  void set_allocated_notemessage(::proto::Message* notemessage);
  private:
  const ::proto::Message& _internal_notemessage() const;
  ::proto::Message* _internal_mutable_notemessage();
  public:
  void unsafe_arena_set_allocated_notemessage(
      ::proto::Message* notemessage);
  ::proto::Message* unsafe_arena_release_notemessage();

  // optional .proto.MessageKey requestMessageKey = 3;
  bool has_requestmessagekey() const;
  private:
  bool _internal_has_requestmessagekey() const;
  public:
  void clear_requestmessagekey();
  const ::proto::MessageKey& requestmessagekey() const;
  PROTOBUF_NODISCARD ::proto::MessageKey* release_requestmessagekey();
  ::proto::MessageKey* mutable_requestmessagekey();
  void set_allocated_requestmessagekey(::proto::MessageKey* requestmessagekey);
  private:
  const ::proto::MessageKey& _internal_requestmessagekey() const;
  ::proto::MessageKey* _internal_mutable_requestmessagekey();
  public:
  void unsafe_arena_set_allocated_requestmessagekey(
      ::proto::MessageKey* requestmessagekey);
  ::proto::MessageKey* unsafe_arena_release_requestmessagekey();

  // @@protoc_insertion_point(class_scope:proto.SendPaymentMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::proto::Message* notemessage_;
    ::proto::MessageKey* requestmessagekey_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class RequestPaymentMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.RequestPaymentMessage) */ {
 public:
  inline RequestPaymentMessage() : RequestPaymentMessage(nullptr) {}
  ~RequestPaymentMessage() override;
  explicit PROTOBUF_CONSTEXPR RequestPaymentMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestPaymentMessage(const RequestPaymentMessage& from);
  RequestPaymentMessage(RequestPaymentMessage&& from) noexcept
    : RequestPaymentMessage() {
    *this = ::std::move(from);
  }

  inline RequestPaymentMessage& operator=(const RequestPaymentMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestPaymentMessage& operator=(RequestPaymentMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestPaymentMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestPaymentMessage* internal_default_instance() {
    return reinterpret_cast<const RequestPaymentMessage*>(
               &_RequestPaymentMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(RequestPaymentMessage& a, RequestPaymentMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestPaymentMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestPaymentMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestPaymentMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestPaymentMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestPaymentMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestPaymentMessage& from) {
    RequestPaymentMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestPaymentMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RequestPaymentMessage";
  }
  protected:
  explicit RequestPaymentMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrencyCodeIso4217FieldNumber = 1,
    kRequestFromFieldNumber = 3,
    kNoteMessageFieldNumber = 4,
    kAmountFieldNumber = 6,
    kAmount1000FieldNumber = 2,
    kExpiryTimestampFieldNumber = 5,
  };
  // optional string currencyCodeIso4217 = 1;
  bool has_currencycodeiso4217() const;
  private:
  bool _internal_has_currencycodeiso4217() const;
  public:
  void clear_currencycodeiso4217();
  const std::string& currencycodeiso4217() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currencycodeiso4217(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currencycodeiso4217();
  PROTOBUF_NODISCARD std::string* release_currencycodeiso4217();
  void set_allocated_currencycodeiso4217(std::string* currencycodeiso4217);
  private:
  const std::string& _internal_currencycodeiso4217() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currencycodeiso4217(const std::string& value);
  std::string* _internal_mutable_currencycodeiso4217();
  public:

  // optional string requestFrom = 3;
  bool has_requestfrom() const;
  private:
  bool _internal_has_requestfrom() const;
  public:
  void clear_requestfrom();
  const std::string& requestfrom() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requestfrom(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requestfrom();
  PROTOBUF_NODISCARD std::string* release_requestfrom();
  void set_allocated_requestfrom(std::string* requestfrom);
  private:
  const std::string& _internal_requestfrom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestfrom(const std::string& value);
  std::string* _internal_mutable_requestfrom();
  public:

  // optional .proto.Message noteMessage = 4;
  bool has_notemessage() const;
  private:
  bool _internal_has_notemessage() const;
  public:
  void clear_notemessage();
  const ::proto::Message& notemessage() const;
  PROTOBUF_NODISCARD ::proto::Message* release_notemessage();
  ::proto::Message* mutable_notemessage();
  void set_allocated_notemessage(::proto::Message* notemessage);
  private:
  const ::proto::Message& _internal_notemessage() const;
  ::proto::Message* _internal_mutable_notemessage();
  public:
  void unsafe_arena_set_allocated_notemessage(
      ::proto::Message* notemessage);
  ::proto::Message* unsafe_arena_release_notemessage();

  // optional .proto.PaymentMoney amount = 6;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  const ::proto::PaymentMoney& amount() const;
  PROTOBUF_NODISCARD ::proto::PaymentMoney* release_amount();
  ::proto::PaymentMoney* mutable_amount();
  void set_allocated_amount(::proto::PaymentMoney* amount);
  private:
  const ::proto::PaymentMoney& _internal_amount() const;
  ::proto::PaymentMoney* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::proto::PaymentMoney* amount);
  ::proto::PaymentMoney* unsafe_arena_release_amount();

  // optional uint64 amount1000 = 2;
  bool has_amount1000() const;
  private:
  bool _internal_has_amount1000() const;
  public:
  void clear_amount1000();
  uint64_t amount1000() const;
  void set_amount1000(uint64_t value);
  private:
  uint64_t _internal_amount1000() const;
  void _internal_set_amount1000(uint64_t value);
  public:

  // optional int64 expiryTimestamp = 5;
  bool has_expirytimestamp() const;
  private:
  bool _internal_has_expirytimestamp() const;
  public:
  void clear_expirytimestamp();
  int64_t expirytimestamp() const;
  void set_expirytimestamp(int64_t value);
  private:
  int64_t _internal_expirytimestamp() const;
  void _internal_set_expirytimestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RequestPaymentMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currencycodeiso4217_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requestfrom_;
    ::proto::Message* notemessage_;
    ::proto::PaymentMoney* amount_;
    uint64_t amount1000_;
    int64_t expirytimestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class DeclinePaymentRequestMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.DeclinePaymentRequestMessage) */ {
 public:
  inline DeclinePaymentRequestMessage() : DeclinePaymentRequestMessage(nullptr) {}
  ~DeclinePaymentRequestMessage() override;
  explicit PROTOBUF_CONSTEXPR DeclinePaymentRequestMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeclinePaymentRequestMessage(const DeclinePaymentRequestMessage& from);
  DeclinePaymentRequestMessage(DeclinePaymentRequestMessage&& from) noexcept
    : DeclinePaymentRequestMessage() {
    *this = ::std::move(from);
  }

  inline DeclinePaymentRequestMessage& operator=(const DeclinePaymentRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeclinePaymentRequestMessage& operator=(DeclinePaymentRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeclinePaymentRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeclinePaymentRequestMessage* internal_default_instance() {
    return reinterpret_cast<const DeclinePaymentRequestMessage*>(
               &_DeclinePaymentRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(DeclinePaymentRequestMessage& a, DeclinePaymentRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DeclinePaymentRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeclinePaymentRequestMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeclinePaymentRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeclinePaymentRequestMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeclinePaymentRequestMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeclinePaymentRequestMessage& from) {
    DeclinePaymentRequestMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeclinePaymentRequestMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.DeclinePaymentRequestMessage";
  }
  protected:
  explicit DeclinePaymentRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // optional .proto.MessageKey key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::proto::MessageKey& key() const;
  PROTOBUF_NODISCARD ::proto::MessageKey* release_key();
  ::proto::MessageKey* mutable_key();
  void set_allocated_key(::proto::MessageKey* key);
  private:
  const ::proto::MessageKey& _internal_key() const;
  ::proto::MessageKey* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::proto::MessageKey* key);
  ::proto::MessageKey* unsafe_arena_release_key();

  // @@protoc_insertion_point(class_scope:proto.DeclinePaymentRequestMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::proto::MessageKey* key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class CancelPaymentRequestMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.CancelPaymentRequestMessage) */ {
 public:
  inline CancelPaymentRequestMessage() : CancelPaymentRequestMessage(nullptr) {}
  ~CancelPaymentRequestMessage() override;
  explicit PROTOBUF_CONSTEXPR CancelPaymentRequestMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelPaymentRequestMessage(const CancelPaymentRequestMessage& from);
  CancelPaymentRequestMessage(CancelPaymentRequestMessage&& from) noexcept
    : CancelPaymentRequestMessage() {
    *this = ::std::move(from);
  }

  inline CancelPaymentRequestMessage& operator=(const CancelPaymentRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelPaymentRequestMessage& operator=(CancelPaymentRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelPaymentRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelPaymentRequestMessage* internal_default_instance() {
    return reinterpret_cast<const CancelPaymentRequestMessage*>(
               &_CancelPaymentRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(CancelPaymentRequestMessage& a, CancelPaymentRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelPaymentRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelPaymentRequestMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelPaymentRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelPaymentRequestMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelPaymentRequestMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelPaymentRequestMessage& from) {
    CancelPaymentRequestMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelPaymentRequestMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.CancelPaymentRequestMessage";
  }
  protected:
  explicit CancelPaymentRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // optional .proto.MessageKey key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::proto::MessageKey& key() const;
  PROTOBUF_NODISCARD ::proto::MessageKey* release_key();
  ::proto::MessageKey* mutable_key();
  void set_allocated_key(::proto::MessageKey* key);
  private:
  const ::proto::MessageKey& _internal_key() const;
  ::proto::MessageKey* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::proto::MessageKey* key);
  ::proto::MessageKey* unsafe_arena_release_key();

  // @@protoc_insertion_point(class_scope:proto.CancelPaymentRequestMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::proto::MessageKey* key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class LiveLocationMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.LiveLocationMessage) */ {
 public:
  inline LiveLocationMessage() : LiveLocationMessage(nullptr) {}
  ~LiveLocationMessage() override;
  explicit PROTOBUF_CONSTEXPR LiveLocationMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LiveLocationMessage(const LiveLocationMessage& from);
  LiveLocationMessage(LiveLocationMessage&& from) noexcept
    : LiveLocationMessage() {
    *this = ::std::move(from);
  }

  inline LiveLocationMessage& operator=(const LiveLocationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiveLocationMessage& operator=(LiveLocationMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiveLocationMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const LiveLocationMessage* internal_default_instance() {
    return reinterpret_cast<const LiveLocationMessage*>(
               &_LiveLocationMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(LiveLocationMessage& a, LiveLocationMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(LiveLocationMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiveLocationMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiveLocationMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiveLocationMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LiveLocationMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LiveLocationMessage& from) {
    LiveLocationMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiveLocationMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.LiveLocationMessage";
  }
  protected:
  explicit LiveLocationMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCaptionFieldNumber = 6,
    kJpegThumbnailFieldNumber = 16,
    kContextInfoFieldNumber = 17,
    kDegreesLatitudeFieldNumber = 1,
    kDegreesLongitudeFieldNumber = 2,
    kAccuracyInMetersFieldNumber = 3,
    kSpeedInMpsFieldNumber = 4,
    kDegreesClockwiseFromMagneticNorthFieldNumber = 5,
    kTimeOffsetFieldNumber = 8,
    kSequenceNumberFieldNumber = 7,
  };
  // optional string caption = 6;
  bool has_caption() const;
  private:
  bool _internal_has_caption() const;
  public:
  void clear_caption();
  const std::string& caption() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caption(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caption();
  PROTOBUF_NODISCARD std::string* release_caption();
  void set_allocated_caption(std::string* caption);
  private:
  const std::string& _internal_caption() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caption(const std::string& value);
  std::string* _internal_mutable_caption();
  public:

  // optional bytes jpegThumbnail = 16;
  bool has_jpegthumbnail() const;
  private:
  bool _internal_has_jpegthumbnail() const;
  public:
  void clear_jpegthumbnail();
  const std::string& jpegthumbnail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jpegthumbnail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jpegthumbnail();
  PROTOBUF_NODISCARD std::string* release_jpegthumbnail();
  void set_allocated_jpegthumbnail(std::string* jpegthumbnail);
  private:
  const std::string& _internal_jpegthumbnail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jpegthumbnail(const std::string& value);
  std::string* _internal_mutable_jpegthumbnail();
  public:

  // optional .proto.ContextInfo contextInfo = 17;
  bool has_contextinfo() const;
  private:
  bool _internal_has_contextinfo() const;
  public:
  void clear_contextinfo();
  const ::proto::ContextInfo& contextinfo() const;
  PROTOBUF_NODISCARD ::proto::ContextInfo* release_contextinfo();
  ::proto::ContextInfo* mutable_contextinfo();
  void set_allocated_contextinfo(::proto::ContextInfo* contextinfo);
  private:
  const ::proto::ContextInfo& _internal_contextinfo() const;
  ::proto::ContextInfo* _internal_mutable_contextinfo();
  public:
  void unsafe_arena_set_allocated_contextinfo(
      ::proto::ContextInfo* contextinfo);
  ::proto::ContextInfo* unsafe_arena_release_contextinfo();

  // optional double degreesLatitude = 1;
  bool has_degreeslatitude() const;
  private:
  bool _internal_has_degreeslatitude() const;
  public:
  void clear_degreeslatitude();
  double degreeslatitude() const;
  void set_degreeslatitude(double value);
  private:
  double _internal_degreeslatitude() const;
  void _internal_set_degreeslatitude(double value);
  public:

  // optional double degreesLongitude = 2;
  bool has_degreeslongitude() const;
  private:
  bool _internal_has_degreeslongitude() const;
  public:
  void clear_degreeslongitude();
  double degreeslongitude() const;
  void set_degreeslongitude(double value);
  private:
  double _internal_degreeslongitude() const;
  void _internal_set_degreeslongitude(double value);
  public:

  // optional uint32 accuracyInMeters = 3;
  bool has_accuracyinmeters() const;
  private:
  bool _internal_has_accuracyinmeters() const;
  public:
  void clear_accuracyinmeters();
  uint32_t accuracyinmeters() const;
  void set_accuracyinmeters(uint32_t value);
  private:
  uint32_t _internal_accuracyinmeters() const;
  void _internal_set_accuracyinmeters(uint32_t value);
  public:

  // optional float speedInMps = 4;
  bool has_speedinmps() const;
  private:
  bool _internal_has_speedinmps() const;
  public:
  void clear_speedinmps();
  float speedinmps() const;
  void set_speedinmps(float value);
  private:
  float _internal_speedinmps() const;
  void _internal_set_speedinmps(float value);
  public:

  // optional uint32 degreesClockwiseFromMagneticNorth = 5;
  bool has_degreesclockwisefrommagneticnorth() const;
  private:
  bool _internal_has_degreesclockwisefrommagneticnorth() const;
  public:
  void clear_degreesclockwisefrommagneticnorth();
  uint32_t degreesclockwisefrommagneticnorth() const;
  void set_degreesclockwisefrommagneticnorth(uint32_t value);
  private:
  uint32_t _internal_degreesclockwisefrommagneticnorth() const;
  void _internal_set_degreesclockwisefrommagneticnorth(uint32_t value);
  public:

  // optional uint32 timeOffset = 8;
  bool has_timeoffset() const;
  private:
  bool _internal_has_timeoffset() const;
  public:
  void clear_timeoffset();
  uint32_t timeoffset() const;
  void set_timeoffset(uint32_t value);
  private:
  uint32_t _internal_timeoffset() const;
  void _internal_set_timeoffset(uint32_t value);
  public:

  // optional int64 sequenceNumber = 7;
  bool has_sequencenumber() const;
  private:
  bool _internal_has_sequencenumber() const;
  public:
  void clear_sequencenumber();
  int64_t sequencenumber() const;
  void set_sequencenumber(int64_t value);
  private:
  int64_t _internal_sequencenumber() const;
  void _internal_set_sequencenumber(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.LiveLocationMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caption_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jpegthumbnail_;
    ::proto::ContextInfo* contextinfo_;
    double degreeslatitude_;
    double degreeslongitude_;
    uint32_t accuracyinmeters_;
    float speedinmps_;
    uint32_t degreesclockwisefrommagneticnorth_;
    uint32_t timeoffset_;
    int64_t sequencenumber_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class StickerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.StickerMessage) */ {
 public:
  inline StickerMessage() : StickerMessage(nullptr) {}
  ~StickerMessage() override;
  explicit PROTOBUF_CONSTEXPR StickerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StickerMessage(const StickerMessage& from);
  StickerMessage(StickerMessage&& from) noexcept
    : StickerMessage() {
    *this = ::std::move(from);
  }

  inline StickerMessage& operator=(const StickerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StickerMessage& operator=(StickerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StickerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StickerMessage* internal_default_instance() {
    return reinterpret_cast<const StickerMessage*>(
               &_StickerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(StickerMessage& a, StickerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StickerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StickerMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StickerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StickerMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StickerMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StickerMessage& from) {
    StickerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StickerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.StickerMessage";
  }
  protected:
  explicit StickerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kFileSha256FieldNumber = 2,
    kFileEncSha256FieldNumber = 3,
    kMediaKeyFieldNumber = 4,
    kMimetypeFieldNumber = 5,
    kDirectPathFieldNumber = 8,
    kFirstFrameSidecarFieldNumber = 12,
    kPngThumbnailFieldNumber = 16,
    kContextInfoFieldNumber = 17,
    kHeightFieldNumber = 6,
    kWidthFieldNumber = 7,
    kFileLengthFieldNumber = 9,
    kMediaKeyTimestampFieldNumber = 10,
    kFirstFrameLengthFieldNumber = 11,
    kIsAnimatedFieldNumber = 13,
  };
  // optional string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional bytes fileSha256 = 2;
  bool has_filesha256() const;
  private:
  bool _internal_has_filesha256() const;
  public:
  void clear_filesha256();
  const std::string& filesha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filesha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filesha256();
  PROTOBUF_NODISCARD std::string* release_filesha256();
  void set_allocated_filesha256(std::string* filesha256);
  private:
  const std::string& _internal_filesha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filesha256(const std::string& value);
  std::string* _internal_mutable_filesha256();
  public:

  // optional bytes fileEncSha256 = 3;
  bool has_fileencsha256() const;
  private:
  bool _internal_has_fileencsha256() const;
  public:
  void clear_fileencsha256();
  const std::string& fileencsha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fileencsha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fileencsha256();
  PROTOBUF_NODISCARD std::string* release_fileencsha256();
  void set_allocated_fileencsha256(std::string* fileencsha256);
  private:
  const std::string& _internal_fileencsha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fileencsha256(const std::string& value);
  std::string* _internal_mutable_fileencsha256();
  public:

  // optional bytes mediaKey = 4;
  bool has_mediakey() const;
  private:
  bool _internal_has_mediakey() const;
  public:
  void clear_mediakey();
  const std::string& mediakey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mediakey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mediakey();
  PROTOBUF_NODISCARD std::string* release_mediakey();
  void set_allocated_mediakey(std::string* mediakey);
  private:
  const std::string& _internal_mediakey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mediakey(const std::string& value);
  std::string* _internal_mutable_mediakey();
  public:

  // optional string mimetype = 5;
  bool has_mimetype() const;
  private:
  bool _internal_has_mimetype() const;
  public:
  void clear_mimetype();
  const std::string& mimetype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mimetype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mimetype();
  PROTOBUF_NODISCARD std::string* release_mimetype();
  void set_allocated_mimetype(std::string* mimetype);
  private:
  const std::string& _internal_mimetype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mimetype(const std::string& value);
  std::string* _internal_mutable_mimetype();
  public:

  // optional string directPath = 8;
  bool has_directpath() const;
  private:
  bool _internal_has_directpath() const;
  public:
  void clear_directpath();
  const std::string& directpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_directpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_directpath();
  PROTOBUF_NODISCARD std::string* release_directpath();
  void set_allocated_directpath(std::string* directpath);
  private:
  const std::string& _internal_directpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_directpath(const std::string& value);
  std::string* _internal_mutable_directpath();
  public:

  // optional bytes firstFrameSidecar = 12;
  bool has_firstframesidecar() const;
  private:
  bool _internal_has_firstframesidecar() const;
  public:
  void clear_firstframesidecar();
  const std::string& firstframesidecar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_firstframesidecar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_firstframesidecar();
  PROTOBUF_NODISCARD std::string* release_firstframesidecar();
  void set_allocated_firstframesidecar(std::string* firstframesidecar);
  private:
  const std::string& _internal_firstframesidecar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_firstframesidecar(const std::string& value);
  std::string* _internal_mutable_firstframesidecar();
  public:

  // optional bytes pngThumbnail = 16;
  bool has_pngthumbnail() const;
  private:
  bool _internal_has_pngthumbnail() const;
  public:
  void clear_pngthumbnail();
  const std::string& pngthumbnail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pngthumbnail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pngthumbnail();
  PROTOBUF_NODISCARD std::string* release_pngthumbnail();
  void set_allocated_pngthumbnail(std::string* pngthumbnail);
  private:
  const std::string& _internal_pngthumbnail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pngthumbnail(const std::string& value);
  std::string* _internal_mutable_pngthumbnail();
  public:

  // optional .proto.ContextInfo contextInfo = 17;
  bool has_contextinfo() const;
  private:
  bool _internal_has_contextinfo() const;
  public:
  void clear_contextinfo();
  const ::proto::ContextInfo& contextinfo() const;
  PROTOBUF_NODISCARD ::proto::ContextInfo* release_contextinfo();
  ::proto::ContextInfo* mutable_contextinfo();
  void set_allocated_contextinfo(::proto::ContextInfo* contextinfo);
  private:
  const ::proto::ContextInfo& _internal_contextinfo() const;
  ::proto::ContextInfo* _internal_mutable_contextinfo();
  public:
  void unsafe_arena_set_allocated_contextinfo(
      ::proto::ContextInfo* contextinfo);
  ::proto::ContextInfo* unsafe_arena_release_contextinfo();

  // optional uint32 height = 6;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // optional uint32 width = 7;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // optional uint64 fileLength = 9;
  bool has_filelength() const;
  private:
  bool _internal_has_filelength() const;
  public:
  void clear_filelength();
  uint64_t filelength() const;
  void set_filelength(uint64_t value);
  private:
  uint64_t _internal_filelength() const;
  void _internal_set_filelength(uint64_t value);
  public:

  // optional int64 mediaKeyTimestamp = 10;
  bool has_mediakeytimestamp() const;
  private:
  bool _internal_has_mediakeytimestamp() const;
  public:
  void clear_mediakeytimestamp();
  int64_t mediakeytimestamp() const;
  void set_mediakeytimestamp(int64_t value);
  private:
  int64_t _internal_mediakeytimestamp() const;
  void _internal_set_mediakeytimestamp(int64_t value);
  public:

  // optional uint32 firstFrameLength = 11;
  bool has_firstframelength() const;
  private:
  bool _internal_has_firstframelength() const;
  public:
  void clear_firstframelength();
  uint32_t firstframelength() const;
  void set_firstframelength(uint32_t value);
  private:
  uint32_t _internal_firstframelength() const;
  void _internal_set_firstframelength(uint32_t value);
  public:

  // optional bool isAnimated = 13;
  bool has_isanimated() const;
  private:
  bool _internal_has_isanimated() const;
  public:
  void clear_isanimated();
  bool isanimated() const;
  void set_isanimated(bool value);
  private:
  bool _internal_isanimated() const;
  void _internal_set_isanimated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.StickerMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filesha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fileencsha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mediakey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mimetype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directpath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr firstframesidecar_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pngthumbnail_;
    ::proto::ContextInfo* contextinfo_;
    uint32_t height_;
    uint32_t width_;
    uint64_t filelength_;
    int64_t mediakeytimestamp_;
    uint32_t firstframelength_;
    bool isanimated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class FourRowTemplate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.FourRowTemplate) */ {
 public:
  inline FourRowTemplate() : FourRowTemplate(nullptr) {}
  ~FourRowTemplate() override;
  explicit PROTOBUF_CONSTEXPR FourRowTemplate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FourRowTemplate(const FourRowTemplate& from);
  FourRowTemplate(FourRowTemplate&& from) noexcept
    : FourRowTemplate() {
    *this = ::std::move(from);
  }

  inline FourRowTemplate& operator=(const FourRowTemplate& from) {
    CopyFrom(from);
    return *this;
  }
  inline FourRowTemplate& operator=(FourRowTemplate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FourRowTemplate& default_instance() {
    return *internal_default_instance();
  }
  enum TitleCase {
    kDocumentMessage = 1,
    kHighlyStructuredMessage = 2,
    kImageMessage = 3,
    kVideoMessage = 4,
    kLocationMessage = 5,
    TITLE_NOT_SET = 0,
  };

  static inline const FourRowTemplate* internal_default_instance() {
    return reinterpret_cast<const FourRowTemplate*>(
               &_FourRowTemplate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(FourRowTemplate& a, FourRowTemplate& b) {
    a.Swap(&b);
  }
  inline void Swap(FourRowTemplate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FourRowTemplate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FourRowTemplate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FourRowTemplate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FourRowTemplate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FourRowTemplate& from) {
    FourRowTemplate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FourRowTemplate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.FourRowTemplate";
  }
  protected:
  explicit FourRowTemplate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kButtonsFieldNumber = 8,
    kContentFieldNumber = 6,
    kFooterFieldNumber = 7,
    kDocumentMessageFieldNumber = 1,
    kHighlyStructuredMessageFieldNumber = 2,
    kImageMessageFieldNumber = 3,
    kVideoMessageFieldNumber = 4,
    kLocationMessageFieldNumber = 5,
  };
  // repeated .proto.TemplateButton buttons = 8;
  int buttons_size() const;
  private:
  int _internal_buttons_size() const;
  public:
  void clear_buttons();
  ::proto::TemplateButton* mutable_buttons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TemplateButton >*
      mutable_buttons();
  private:
  const ::proto::TemplateButton& _internal_buttons(int index) const;
  ::proto::TemplateButton* _internal_add_buttons();
  public:
  const ::proto::TemplateButton& buttons(int index) const;
  ::proto::TemplateButton* add_buttons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TemplateButton >&
      buttons() const;

  // optional .proto.HighlyStructuredMessage content = 6;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const ::proto::HighlyStructuredMessage& content() const;
  PROTOBUF_NODISCARD ::proto::HighlyStructuredMessage* release_content();
  ::proto::HighlyStructuredMessage* mutable_content();
  void set_allocated_content(::proto::HighlyStructuredMessage* content);
  private:
  const ::proto::HighlyStructuredMessage& _internal_content() const;
  ::proto::HighlyStructuredMessage* _internal_mutable_content();
  public:
  void unsafe_arena_set_allocated_content(
      ::proto::HighlyStructuredMessage* content);
  ::proto::HighlyStructuredMessage* unsafe_arena_release_content();

  // optional .proto.HighlyStructuredMessage footer = 7;
  bool has_footer() const;
  private:
  bool _internal_has_footer() const;
  public:
  void clear_footer();
  const ::proto::HighlyStructuredMessage& footer() const;
  PROTOBUF_NODISCARD ::proto::HighlyStructuredMessage* release_footer();
  ::proto::HighlyStructuredMessage* mutable_footer();
  void set_allocated_footer(::proto::HighlyStructuredMessage* footer);
  private:
  const ::proto::HighlyStructuredMessage& _internal_footer() const;
  ::proto::HighlyStructuredMessage* _internal_mutable_footer();
  public:
  void unsafe_arena_set_allocated_footer(
      ::proto::HighlyStructuredMessage* footer);
  ::proto::HighlyStructuredMessage* unsafe_arena_release_footer();

  // .proto.DocumentMessage documentMessage = 1;
  bool has_documentmessage() const;
  private:
  bool _internal_has_documentmessage() const;
  public:
  void clear_documentmessage();
  const ::proto::DocumentMessage& documentmessage() const;
  PROTOBUF_NODISCARD ::proto::DocumentMessage* release_documentmessage();
  ::proto::DocumentMessage* mutable_documentmessage();
  void set_allocated_documentmessage(::proto::DocumentMessage* documentmessage);
  private:
  const ::proto::DocumentMessage& _internal_documentmessage() const;
  ::proto::DocumentMessage* _internal_mutable_documentmessage();
  public:
  void unsafe_arena_set_allocated_documentmessage(
      ::proto::DocumentMessage* documentmessage);
  ::proto::DocumentMessage* unsafe_arena_release_documentmessage();

  // .proto.HighlyStructuredMessage highlyStructuredMessage = 2;
  bool has_highlystructuredmessage() const;
  private:
  bool _internal_has_highlystructuredmessage() const;
  public:
  void clear_highlystructuredmessage();
  const ::proto::HighlyStructuredMessage& highlystructuredmessage() const;
  PROTOBUF_NODISCARD ::proto::HighlyStructuredMessage* release_highlystructuredmessage();
  ::proto::HighlyStructuredMessage* mutable_highlystructuredmessage();
  void set_allocated_highlystructuredmessage(::proto::HighlyStructuredMessage* highlystructuredmessage);
  private:
  const ::proto::HighlyStructuredMessage& _internal_highlystructuredmessage() const;
  ::proto::HighlyStructuredMessage* _internal_mutable_highlystructuredmessage();
  public:
  void unsafe_arena_set_allocated_highlystructuredmessage(
      ::proto::HighlyStructuredMessage* highlystructuredmessage);
  ::proto::HighlyStructuredMessage* unsafe_arena_release_highlystructuredmessage();

  // .proto.ImageMessage imageMessage = 3;
  bool has_imagemessage() const;
  private:
  bool _internal_has_imagemessage() const;
  public:
  void clear_imagemessage();
  const ::proto::ImageMessage& imagemessage() const;
  PROTOBUF_NODISCARD ::proto::ImageMessage* release_imagemessage();
  ::proto::ImageMessage* mutable_imagemessage();
  void set_allocated_imagemessage(::proto::ImageMessage* imagemessage);
  private:
  const ::proto::ImageMessage& _internal_imagemessage() const;
  ::proto::ImageMessage* _internal_mutable_imagemessage();
  public:
  void unsafe_arena_set_allocated_imagemessage(
      ::proto::ImageMessage* imagemessage);
  ::proto::ImageMessage* unsafe_arena_release_imagemessage();

  // .proto.VideoMessage videoMessage = 4;
  bool has_videomessage() const;
  private:
  bool _internal_has_videomessage() const;
  public:
  void clear_videomessage();
  const ::proto::VideoMessage& videomessage() const;
  PROTOBUF_NODISCARD ::proto::VideoMessage* release_videomessage();
  ::proto::VideoMessage* mutable_videomessage();
  void set_allocated_videomessage(::proto::VideoMessage* videomessage);
  private:
  const ::proto::VideoMessage& _internal_videomessage() const;
  ::proto::VideoMessage* _internal_mutable_videomessage();
  public:
  void unsafe_arena_set_allocated_videomessage(
      ::proto::VideoMessage* videomessage);
  ::proto::VideoMessage* unsafe_arena_release_videomessage();

  // .proto.LocationMessage locationMessage = 5;
  bool has_locationmessage() const;
  private:
  bool _internal_has_locationmessage() const;
  public:
  void clear_locationmessage();
  const ::proto::LocationMessage& locationmessage() const;
  PROTOBUF_NODISCARD ::proto::LocationMessage* release_locationmessage();
  ::proto::LocationMessage* mutable_locationmessage();
  void set_allocated_locationmessage(::proto::LocationMessage* locationmessage);
  private:
  const ::proto::LocationMessage& _internal_locationmessage() const;
  ::proto::LocationMessage* _internal_mutable_locationmessage();
  public:
  void unsafe_arena_set_allocated_locationmessage(
      ::proto::LocationMessage* locationmessage);
  ::proto::LocationMessage* unsafe_arena_release_locationmessage();

  void clear_title();
  TitleCase title_case() const;
  // @@protoc_insertion_point(class_scope:proto.FourRowTemplate)
 private:
  class _Internal;
  void set_has_documentmessage();
  void set_has_highlystructuredmessage();
  void set_has_imagemessage();
  void set_has_videomessage();
  void set_has_locationmessage();

  inline bool has_title() const;
  inline void clear_has_title();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TemplateButton > buttons_;
    ::proto::HighlyStructuredMessage* content_;
    ::proto::HighlyStructuredMessage* footer_;
    union TitleUnion {
      constexpr TitleUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::proto::DocumentMessage* documentmessage_;
      ::proto::HighlyStructuredMessage* highlystructuredmessage_;
      ::proto::ImageMessage* imagemessage_;
      ::proto::VideoMessage* videomessage_;
      ::proto::LocationMessage* locationmessage_;
    } title_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class HydratedFourRowTemplate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.HydratedFourRowTemplate) */ {
 public:
  inline HydratedFourRowTemplate() : HydratedFourRowTemplate(nullptr) {}
  ~HydratedFourRowTemplate() override;
  explicit PROTOBUF_CONSTEXPR HydratedFourRowTemplate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HydratedFourRowTemplate(const HydratedFourRowTemplate& from);
  HydratedFourRowTemplate(HydratedFourRowTemplate&& from) noexcept
    : HydratedFourRowTemplate() {
    *this = ::std::move(from);
  }

  inline HydratedFourRowTemplate& operator=(const HydratedFourRowTemplate& from) {
    CopyFrom(from);
    return *this;
  }
  inline HydratedFourRowTemplate& operator=(HydratedFourRowTemplate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HydratedFourRowTemplate& default_instance() {
    return *internal_default_instance();
  }
  enum TitleCase {
    kDocumentMessage = 1,
    kHydratedTitleText = 2,
    kImageMessage = 3,
    kVideoMessage = 4,
    kLocationMessage = 5,
    TITLE_NOT_SET = 0,
  };

  static inline const HydratedFourRowTemplate* internal_default_instance() {
    return reinterpret_cast<const HydratedFourRowTemplate*>(
               &_HydratedFourRowTemplate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(HydratedFourRowTemplate& a, HydratedFourRowTemplate& b) {
    a.Swap(&b);
  }
  inline void Swap(HydratedFourRowTemplate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HydratedFourRowTemplate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HydratedFourRowTemplate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HydratedFourRowTemplate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HydratedFourRowTemplate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HydratedFourRowTemplate& from) {
    HydratedFourRowTemplate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HydratedFourRowTemplate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HydratedFourRowTemplate";
  }
  protected:
  explicit HydratedFourRowTemplate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHydratedButtonsFieldNumber = 8,
    kHydratedContentTextFieldNumber = 6,
    kHydratedFooterTextFieldNumber = 7,
    kTemplateIdFieldNumber = 9,
    kDocumentMessageFieldNumber = 1,
    kHydratedTitleTextFieldNumber = 2,
    kImageMessageFieldNumber = 3,
    kVideoMessageFieldNumber = 4,
    kLocationMessageFieldNumber = 5,
  };
  // repeated .proto.HydratedTemplateButton hydratedButtons = 8;
  int hydratedbuttons_size() const;
  private:
  int _internal_hydratedbuttons_size() const;
  public:
  void clear_hydratedbuttons();
  ::proto::HydratedTemplateButton* mutable_hydratedbuttons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::HydratedTemplateButton >*
      mutable_hydratedbuttons();
  private:
  const ::proto::HydratedTemplateButton& _internal_hydratedbuttons(int index) const;
  ::proto::HydratedTemplateButton* _internal_add_hydratedbuttons();
  public:
  const ::proto::HydratedTemplateButton& hydratedbuttons(int index) const;
  ::proto::HydratedTemplateButton* add_hydratedbuttons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::HydratedTemplateButton >&
      hydratedbuttons() const;

  // optional string hydratedContentText = 6;
  bool has_hydratedcontenttext() const;
  private:
  bool _internal_has_hydratedcontenttext() const;
  public:
  void clear_hydratedcontenttext();
  const std::string& hydratedcontenttext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hydratedcontenttext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hydratedcontenttext();
  PROTOBUF_NODISCARD std::string* release_hydratedcontenttext();
  void set_allocated_hydratedcontenttext(std::string* hydratedcontenttext);
  private:
  const std::string& _internal_hydratedcontenttext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hydratedcontenttext(const std::string& value);
  std::string* _internal_mutable_hydratedcontenttext();
  public:

  // optional string hydratedFooterText = 7;
  bool has_hydratedfootertext() const;
  private:
  bool _internal_has_hydratedfootertext() const;
  public:
  void clear_hydratedfootertext();
  const std::string& hydratedfootertext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hydratedfootertext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hydratedfootertext();
  PROTOBUF_NODISCARD std::string* release_hydratedfootertext();
  void set_allocated_hydratedfootertext(std::string* hydratedfootertext);
  private:
  const std::string& _internal_hydratedfootertext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hydratedfootertext(const std::string& value);
  std::string* _internal_mutable_hydratedfootertext();
  public:

  // optional string templateId = 9;
  bool has_templateid() const;
  private:
  bool _internal_has_templateid() const;
  public:
  void clear_templateid();
  const std::string& templateid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_templateid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_templateid();
  PROTOBUF_NODISCARD std::string* release_templateid();
  void set_allocated_templateid(std::string* templateid);
  private:
  const std::string& _internal_templateid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_templateid(const std::string& value);
  std::string* _internal_mutable_templateid();
  public:

  // .proto.DocumentMessage documentMessage = 1;
  bool has_documentmessage() const;
  private:
  bool _internal_has_documentmessage() const;
  public:
  void clear_documentmessage();
  const ::proto::DocumentMessage& documentmessage() const;
  PROTOBUF_NODISCARD ::proto::DocumentMessage* release_documentmessage();
  ::proto::DocumentMessage* mutable_documentmessage();
  void set_allocated_documentmessage(::proto::DocumentMessage* documentmessage);
  private:
  const ::proto::DocumentMessage& _internal_documentmessage() const;
  ::proto::DocumentMessage* _internal_mutable_documentmessage();
  public:
  void unsafe_arena_set_allocated_documentmessage(
      ::proto::DocumentMessage* documentmessage);
  ::proto::DocumentMessage* unsafe_arena_release_documentmessage();

  // string hydratedTitleText = 2;
  bool has_hydratedtitletext() const;
  private:
  bool _internal_has_hydratedtitletext() const;
  public:
  void clear_hydratedtitletext();
  const std::string& hydratedtitletext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hydratedtitletext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hydratedtitletext();
  PROTOBUF_NODISCARD std::string* release_hydratedtitletext();
  void set_allocated_hydratedtitletext(std::string* hydratedtitletext);
  private:
  const std::string& _internal_hydratedtitletext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hydratedtitletext(const std::string& value);
  std::string* _internal_mutable_hydratedtitletext();
  public:

  // .proto.ImageMessage imageMessage = 3;
  bool has_imagemessage() const;
  private:
  bool _internal_has_imagemessage() const;
  public:
  void clear_imagemessage();
  const ::proto::ImageMessage& imagemessage() const;
  PROTOBUF_NODISCARD ::proto::ImageMessage* release_imagemessage();
  ::proto::ImageMessage* mutable_imagemessage();
  void set_allocated_imagemessage(::proto::ImageMessage* imagemessage);
  private:
  const ::proto::ImageMessage& _internal_imagemessage() const;
  ::proto::ImageMessage* _internal_mutable_imagemessage();
  public:
  void unsafe_arena_set_allocated_imagemessage(
      ::proto::ImageMessage* imagemessage);
  ::proto::ImageMessage* unsafe_arena_release_imagemessage();

  // .proto.VideoMessage videoMessage = 4;
  bool has_videomessage() const;
  private:
  bool _internal_has_videomessage() const;
  public:
  void clear_videomessage();
  const ::proto::VideoMessage& videomessage() const;
  PROTOBUF_NODISCARD ::proto::VideoMessage* release_videomessage();
  ::proto::VideoMessage* mutable_videomessage();
  void set_allocated_videomessage(::proto::VideoMessage* videomessage);
  private:
  const ::proto::VideoMessage& _internal_videomessage() const;
  ::proto::VideoMessage* _internal_mutable_videomessage();
  public:
  void unsafe_arena_set_allocated_videomessage(
      ::proto::VideoMessage* videomessage);
  ::proto::VideoMessage* unsafe_arena_release_videomessage();

  // .proto.LocationMessage locationMessage = 5;
  bool has_locationmessage() const;
  private:
  bool _internal_has_locationmessage() const;
  public:
  void clear_locationmessage();
  const ::proto::LocationMessage& locationmessage() const;
  PROTOBUF_NODISCARD ::proto::LocationMessage* release_locationmessage();
  ::proto::LocationMessage* mutable_locationmessage();
  void set_allocated_locationmessage(::proto::LocationMessage* locationmessage);
  private:
  const ::proto::LocationMessage& _internal_locationmessage() const;
  ::proto::LocationMessage* _internal_mutable_locationmessage();
  public:
  void unsafe_arena_set_allocated_locationmessage(
      ::proto::LocationMessage* locationmessage);
  ::proto::LocationMessage* unsafe_arena_release_locationmessage();

  void clear_title();
  TitleCase title_case() const;
  // @@protoc_insertion_point(class_scope:proto.HydratedFourRowTemplate)
 private:
  class _Internal;
  void set_has_documentmessage();
  void set_has_hydratedtitletext();
  void set_has_imagemessage();
  void set_has_videomessage();
  void set_has_locationmessage();

  inline bool has_title() const;
  inline void clear_has_title();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::HydratedTemplateButton > hydratedbuttons_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hydratedcontenttext_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hydratedfootertext_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr templateid_;
    union TitleUnion {
      constexpr TitleUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::proto::DocumentMessage* documentmessage_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hydratedtitletext_;
      ::proto::ImageMessage* imagemessage_;
      ::proto::VideoMessage* videomessage_;
      ::proto::LocationMessage* locationmessage_;
    } title_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class TemplateMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.TemplateMessage) */ {
 public:
  inline TemplateMessage() : TemplateMessage(nullptr) {}
  ~TemplateMessage() override;
  explicit PROTOBUF_CONSTEXPR TemplateMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TemplateMessage(const TemplateMessage& from);
  TemplateMessage(TemplateMessage&& from) noexcept
    : TemplateMessage() {
    *this = ::std::move(from);
  }

  inline TemplateMessage& operator=(const TemplateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TemplateMessage& operator=(TemplateMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TemplateMessage& default_instance() {
    return *internal_default_instance();
  }
  enum FormatCase {
    kFourRowTemplate = 1,
    kHydratedFourRowTemplate = 2,
    FORMAT_NOT_SET = 0,
  };

  static inline const TemplateMessage* internal_default_instance() {
    return reinterpret_cast<const TemplateMessage*>(
               &_TemplateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(TemplateMessage& a, TemplateMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TemplateMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TemplateMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TemplateMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TemplateMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TemplateMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TemplateMessage& from) {
    TemplateMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TemplateMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.TemplateMessage";
  }
  protected:
  explicit TemplateMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContextInfoFieldNumber = 3,
    kHydratedTemplateFieldNumber = 4,
    kFourRowTemplateFieldNumber = 1,
    kHydratedFourRowTemplateFieldNumber = 2,
  };
  // optional .proto.ContextInfo contextInfo = 3;
  bool has_contextinfo() const;
  private:
  bool _internal_has_contextinfo() const;
  public:
  void clear_contextinfo();
  const ::proto::ContextInfo& contextinfo() const;
  PROTOBUF_NODISCARD ::proto::ContextInfo* release_contextinfo();
  ::proto::ContextInfo* mutable_contextinfo();
  void set_allocated_contextinfo(::proto::ContextInfo* contextinfo);
  private:
  const ::proto::ContextInfo& _internal_contextinfo() const;
  ::proto::ContextInfo* _internal_mutable_contextinfo();
  public:
  void unsafe_arena_set_allocated_contextinfo(
      ::proto::ContextInfo* contextinfo);
  ::proto::ContextInfo* unsafe_arena_release_contextinfo();

  // optional .proto.HydratedFourRowTemplate hydratedTemplate = 4;
  bool has_hydratedtemplate() const;
  private:
  bool _internal_has_hydratedtemplate() const;
  public:
  void clear_hydratedtemplate();
  const ::proto::HydratedFourRowTemplate& hydratedtemplate() const;
  PROTOBUF_NODISCARD ::proto::HydratedFourRowTemplate* release_hydratedtemplate();
  ::proto::HydratedFourRowTemplate* mutable_hydratedtemplate();
  void set_allocated_hydratedtemplate(::proto::HydratedFourRowTemplate* hydratedtemplate);
  private:
  const ::proto::HydratedFourRowTemplate& _internal_hydratedtemplate() const;
  ::proto::HydratedFourRowTemplate* _internal_mutable_hydratedtemplate();
  public:
  void unsafe_arena_set_allocated_hydratedtemplate(
      ::proto::HydratedFourRowTemplate* hydratedtemplate);
  ::proto::HydratedFourRowTemplate* unsafe_arena_release_hydratedtemplate();

  // .proto.FourRowTemplate fourRowTemplate = 1;
  bool has_fourrowtemplate() const;
  private:
  bool _internal_has_fourrowtemplate() const;
  public:
  void clear_fourrowtemplate();
  const ::proto::FourRowTemplate& fourrowtemplate() const;
  PROTOBUF_NODISCARD ::proto::FourRowTemplate* release_fourrowtemplate();
  ::proto::FourRowTemplate* mutable_fourrowtemplate();
  void set_allocated_fourrowtemplate(::proto::FourRowTemplate* fourrowtemplate);
  private:
  const ::proto::FourRowTemplate& _internal_fourrowtemplate() const;
  ::proto::FourRowTemplate* _internal_mutable_fourrowtemplate();
  public:
  void unsafe_arena_set_allocated_fourrowtemplate(
      ::proto::FourRowTemplate* fourrowtemplate);
  ::proto::FourRowTemplate* unsafe_arena_release_fourrowtemplate();

  // .proto.HydratedFourRowTemplate hydratedFourRowTemplate = 2;
  bool has_hydratedfourrowtemplate() const;
  private:
  bool _internal_has_hydratedfourrowtemplate() const;
  public:
  void clear_hydratedfourrowtemplate();
  const ::proto::HydratedFourRowTemplate& hydratedfourrowtemplate() const;
  PROTOBUF_NODISCARD ::proto::HydratedFourRowTemplate* release_hydratedfourrowtemplate();
  ::proto::HydratedFourRowTemplate* mutable_hydratedfourrowtemplate();
  void set_allocated_hydratedfourrowtemplate(::proto::HydratedFourRowTemplate* hydratedfourrowtemplate);
  private:
  const ::proto::HydratedFourRowTemplate& _internal_hydratedfourrowtemplate() const;
  ::proto::HydratedFourRowTemplate* _internal_mutable_hydratedfourrowtemplate();
  public:
  void unsafe_arena_set_allocated_hydratedfourrowtemplate(
      ::proto::HydratedFourRowTemplate* hydratedfourrowtemplate);
  ::proto::HydratedFourRowTemplate* unsafe_arena_release_hydratedfourrowtemplate();

  void clear_format();
  FormatCase format_case() const;
  // @@protoc_insertion_point(class_scope:proto.TemplateMessage)
 private:
  class _Internal;
  void set_has_fourrowtemplate();
  void set_has_hydratedfourrowtemplate();

  inline bool has_format() const;
  inline void clear_has_format();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::proto::ContextInfo* contextinfo_;
    ::proto::HydratedFourRowTemplate* hydratedtemplate_;
    union FormatUnion {
      constexpr FormatUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::proto::FourRowTemplate* fourrowtemplate_;
      ::proto::HydratedFourRowTemplate* hydratedfourrowtemplate_;
    } format_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class TemplateButtonReplyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.TemplateButtonReplyMessage) */ {
 public:
  inline TemplateButtonReplyMessage() : TemplateButtonReplyMessage(nullptr) {}
  ~TemplateButtonReplyMessage() override;
  explicit PROTOBUF_CONSTEXPR TemplateButtonReplyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TemplateButtonReplyMessage(const TemplateButtonReplyMessage& from);
  TemplateButtonReplyMessage(TemplateButtonReplyMessage&& from) noexcept
    : TemplateButtonReplyMessage() {
    *this = ::std::move(from);
  }

  inline TemplateButtonReplyMessage& operator=(const TemplateButtonReplyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TemplateButtonReplyMessage& operator=(TemplateButtonReplyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TemplateButtonReplyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TemplateButtonReplyMessage* internal_default_instance() {
    return reinterpret_cast<const TemplateButtonReplyMessage*>(
               &_TemplateButtonReplyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(TemplateButtonReplyMessage& a, TemplateButtonReplyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TemplateButtonReplyMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TemplateButtonReplyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TemplateButtonReplyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TemplateButtonReplyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TemplateButtonReplyMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TemplateButtonReplyMessage& from) {
    TemplateButtonReplyMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TemplateButtonReplyMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.TemplateButtonReplyMessage";
  }
  protected:
  explicit TemplateButtonReplyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelectedIdFieldNumber = 1,
    kSelectedDisplayTextFieldNumber = 2,
    kContextInfoFieldNumber = 3,
    kSelectedIndexFieldNumber = 4,
  };
  // optional string selectedId = 1;
  bool has_selectedid() const;
  private:
  bool _internal_has_selectedid() const;
  public:
  void clear_selectedid();
  const std::string& selectedid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selectedid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selectedid();
  PROTOBUF_NODISCARD std::string* release_selectedid();
  void set_allocated_selectedid(std::string* selectedid);
  private:
  const std::string& _internal_selectedid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selectedid(const std::string& value);
  std::string* _internal_mutable_selectedid();
  public:

  // optional string selectedDisplayText = 2;
  bool has_selecteddisplaytext() const;
  private:
  bool _internal_has_selecteddisplaytext() const;
  public:
  void clear_selecteddisplaytext();
  const std::string& selecteddisplaytext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selecteddisplaytext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selecteddisplaytext();
  PROTOBUF_NODISCARD std::string* release_selecteddisplaytext();
  void set_allocated_selecteddisplaytext(std::string* selecteddisplaytext);
  private:
  const std::string& _internal_selecteddisplaytext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selecteddisplaytext(const std::string& value);
  std::string* _internal_mutable_selecteddisplaytext();
  public:

  // optional .proto.ContextInfo contextInfo = 3;
  bool has_contextinfo() const;
  private:
  bool _internal_has_contextinfo() const;
  public:
  void clear_contextinfo();
  const ::proto::ContextInfo& contextinfo() const;
  PROTOBUF_NODISCARD ::proto::ContextInfo* release_contextinfo();
  ::proto::ContextInfo* mutable_contextinfo();
  void set_allocated_contextinfo(::proto::ContextInfo* contextinfo);
  private:
  const ::proto::ContextInfo& _internal_contextinfo() const;
  ::proto::ContextInfo* _internal_mutable_contextinfo();
  public:
  void unsafe_arena_set_allocated_contextinfo(
      ::proto::ContextInfo* contextinfo);
  ::proto::ContextInfo* unsafe_arena_release_contextinfo();

  // optional uint32 selectedIndex = 4;
  bool has_selectedindex() const;
  private:
  bool _internal_has_selectedindex() const;
  public:
  void clear_selectedindex();
  uint32_t selectedindex() const;
  void set_selectedindex(uint32_t value);
  private:
  uint32_t _internal_selectedindex() const;
  void _internal_set_selectedindex(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.TemplateButtonReplyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selectedid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selecteddisplaytext_;
    ::proto::ContextInfo* contextinfo_;
    uint32_t selectedindex_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class CatalogSnapshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.CatalogSnapshot) */ {
 public:
  inline CatalogSnapshot() : CatalogSnapshot(nullptr) {}
  ~CatalogSnapshot() override;
  explicit PROTOBUF_CONSTEXPR CatalogSnapshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CatalogSnapshot(const CatalogSnapshot& from);
  CatalogSnapshot(CatalogSnapshot&& from) noexcept
    : CatalogSnapshot() {
    *this = ::std::move(from);
  }

  inline CatalogSnapshot& operator=(const CatalogSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline CatalogSnapshot& operator=(CatalogSnapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CatalogSnapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const CatalogSnapshot* internal_default_instance() {
    return reinterpret_cast<const CatalogSnapshot*>(
               &_CatalogSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(CatalogSnapshot& a, CatalogSnapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(CatalogSnapshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CatalogSnapshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CatalogSnapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CatalogSnapshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CatalogSnapshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CatalogSnapshot& from) {
    CatalogSnapshot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CatalogSnapshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.CatalogSnapshot";
  }
  protected:
  explicit CatalogSnapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kCatalogImageFieldNumber = 1,
  };
  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string description = 3;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional .proto.ImageMessage catalogImage = 1;
  bool has_catalogimage() const;
  private:
  bool _internal_has_catalogimage() const;
  public:
  void clear_catalogimage();
  const ::proto::ImageMessage& catalogimage() const;
  PROTOBUF_NODISCARD ::proto::ImageMessage* release_catalogimage();
  ::proto::ImageMessage* mutable_catalogimage();
  void set_allocated_catalogimage(::proto::ImageMessage* catalogimage);
  private:
  const ::proto::ImageMessage& _internal_catalogimage() const;
  ::proto::ImageMessage* _internal_mutable_catalogimage();
  public:
  void unsafe_arena_set_allocated_catalogimage(
      ::proto::ImageMessage* catalogimage);
  ::proto::ImageMessage* unsafe_arena_release_catalogimage();

  // @@protoc_insertion_point(class_scope:proto.CatalogSnapshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::proto::ImageMessage* catalogimage_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class ProductSnapshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ProductSnapshot) */ {
 public:
  inline ProductSnapshot() : ProductSnapshot(nullptr) {}
  ~ProductSnapshot() override;
  explicit PROTOBUF_CONSTEXPR ProductSnapshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProductSnapshot(const ProductSnapshot& from);
  ProductSnapshot(ProductSnapshot&& from) noexcept
    : ProductSnapshot() {
    *this = ::std::move(from);
  }

  inline ProductSnapshot& operator=(const ProductSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProductSnapshot& operator=(ProductSnapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProductSnapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProductSnapshot* internal_default_instance() {
    return reinterpret_cast<const ProductSnapshot*>(
               &_ProductSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(ProductSnapshot& a, ProductSnapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(ProductSnapshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProductSnapshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProductSnapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProductSnapshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProductSnapshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProductSnapshot& from) {
    ProductSnapshot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProductSnapshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ProductSnapshot";
  }
  protected:
  explicit ProductSnapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductIdFieldNumber = 2,
    kTitleFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kCurrencyCodeFieldNumber = 5,
    kRetailerIdFieldNumber = 7,
    kUrlFieldNumber = 8,
    kFirstImageIdFieldNumber = 11,
    kProductImageFieldNumber = 1,
    kPriceAmount1000FieldNumber = 6,
    kProductImageCountFieldNumber = 9,
  };
  // optional string productId = 2;
  bool has_productid() const;
  private:
  bool _internal_has_productid() const;
  public:
  void clear_productid();
  const std::string& productid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_productid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_productid();
  PROTOBUF_NODISCARD std::string* release_productid();
  void set_allocated_productid(std::string* productid);
  private:
  const std::string& _internal_productid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_productid(const std::string& value);
  std::string* _internal_mutable_productid();
  public:

  // optional string title = 3;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string description = 4;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string currencyCode = 5;
  bool has_currencycode() const;
  private:
  bool _internal_has_currencycode() const;
  public:
  void clear_currencycode();
  const std::string& currencycode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currencycode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currencycode();
  PROTOBUF_NODISCARD std::string* release_currencycode();
  void set_allocated_currencycode(std::string* currencycode);
  private:
  const std::string& _internal_currencycode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currencycode(const std::string& value);
  std::string* _internal_mutable_currencycode();
  public:

  // optional string retailerId = 7;
  bool has_retailerid() const;
  private:
  bool _internal_has_retailerid() const;
  public:
  void clear_retailerid();
  const std::string& retailerid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_retailerid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_retailerid();
  PROTOBUF_NODISCARD std::string* release_retailerid();
  void set_allocated_retailerid(std::string* retailerid);
  private:
  const std::string& _internal_retailerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_retailerid(const std::string& value);
  std::string* _internal_mutable_retailerid();
  public:

  // optional string url = 8;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string firstImageId = 11;
  bool has_firstimageid() const;
  private:
  bool _internal_has_firstimageid() const;
  public:
  void clear_firstimageid();
  const std::string& firstimageid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_firstimageid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_firstimageid();
  PROTOBUF_NODISCARD std::string* release_firstimageid();
  void set_allocated_firstimageid(std::string* firstimageid);
  private:
  const std::string& _internal_firstimageid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_firstimageid(const std::string& value);
  std::string* _internal_mutable_firstimageid();
  public:

  // optional .proto.ImageMessage productImage = 1;
  bool has_productimage() const;
  private:
  bool _internal_has_productimage() const;
  public:
  void clear_productimage();
  const ::proto::ImageMessage& productimage() const;
  PROTOBUF_NODISCARD ::proto::ImageMessage* release_productimage();
  ::proto::ImageMessage* mutable_productimage();
  void set_allocated_productimage(::proto::ImageMessage* productimage);
  private:
  const ::proto::ImageMessage& _internal_productimage() const;
  ::proto::ImageMessage* _internal_mutable_productimage();
  public:
  void unsafe_arena_set_allocated_productimage(
      ::proto::ImageMessage* productimage);
  ::proto::ImageMessage* unsafe_arena_release_productimage();

  // optional int64 priceAmount1000 = 6;
  bool has_priceamount1000() const;
  private:
  bool _internal_has_priceamount1000() const;
  public:
  void clear_priceamount1000();
  int64_t priceamount1000() const;
  void set_priceamount1000(int64_t value);
  private:
  int64_t _internal_priceamount1000() const;
  void _internal_set_priceamount1000(int64_t value);
  public:

  // optional uint32 productImageCount = 9;
  bool has_productimagecount() const;
  private:
  bool _internal_has_productimagecount() const;
  public:
  void clear_productimagecount();
  uint32_t productimagecount() const;
  void set_productimagecount(uint32_t value);
  private:
  uint32_t _internal_productimagecount() const;
  void _internal_set_productimagecount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ProductSnapshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr productid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currencycode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr retailerid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr firstimageid_;
    ::proto::ImageMessage* productimage_;
    int64_t priceamount1000_;
    uint32_t productimagecount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class ProductMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ProductMessage) */ {
 public:
  inline ProductMessage() : ProductMessage(nullptr) {}
  ~ProductMessage() override;
  explicit PROTOBUF_CONSTEXPR ProductMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProductMessage(const ProductMessage& from);
  ProductMessage(ProductMessage&& from) noexcept
    : ProductMessage() {
    *this = ::std::move(from);
  }

  inline ProductMessage& operator=(const ProductMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProductMessage& operator=(ProductMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProductMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProductMessage* internal_default_instance() {
    return reinterpret_cast<const ProductMessage*>(
               &_ProductMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(ProductMessage& a, ProductMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ProductMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProductMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProductMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProductMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProductMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProductMessage& from) {
    ProductMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProductMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ProductMessage";
  }
  protected:
  explicit ProductMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBusinessOwnerJidFieldNumber = 2,
    kProductFieldNumber = 1,
    kCatalogFieldNumber = 4,
    kContextInfoFieldNumber = 17,
  };
  // optional string businessOwnerJid = 2;
  bool has_businessownerjid() const;
  private:
  bool _internal_has_businessownerjid() const;
  public:
  void clear_businessownerjid();
  const std::string& businessownerjid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_businessownerjid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_businessownerjid();
  PROTOBUF_NODISCARD std::string* release_businessownerjid();
  void set_allocated_businessownerjid(std::string* businessownerjid);
  private:
  const std::string& _internal_businessownerjid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_businessownerjid(const std::string& value);
  std::string* _internal_mutable_businessownerjid();
  public:

  // optional .proto.ProductSnapshot product = 1;
  bool has_product() const;
  private:
  bool _internal_has_product() const;
  public:
  void clear_product();
  const ::proto::ProductSnapshot& product() const;
  PROTOBUF_NODISCARD ::proto::ProductSnapshot* release_product();
  ::proto::ProductSnapshot* mutable_product();
  void set_allocated_product(::proto::ProductSnapshot* product);
  private:
  const ::proto::ProductSnapshot& _internal_product() const;
  ::proto::ProductSnapshot* _internal_mutable_product();
  public:
  void unsafe_arena_set_allocated_product(
      ::proto::ProductSnapshot* product);
  ::proto::ProductSnapshot* unsafe_arena_release_product();

  // optional .proto.CatalogSnapshot catalog = 4;
  bool has_catalog() const;
  private:
  bool _internal_has_catalog() const;
  public:
  void clear_catalog();
  const ::proto::CatalogSnapshot& catalog() const;
  PROTOBUF_NODISCARD ::proto::CatalogSnapshot* release_catalog();
  ::proto::CatalogSnapshot* mutable_catalog();
  void set_allocated_catalog(::proto::CatalogSnapshot* catalog);
  private:
  const ::proto::CatalogSnapshot& _internal_catalog() const;
  ::proto::CatalogSnapshot* _internal_mutable_catalog();
  public:
  void unsafe_arena_set_allocated_catalog(
      ::proto::CatalogSnapshot* catalog);
  ::proto::CatalogSnapshot* unsafe_arena_release_catalog();

  // optional .proto.ContextInfo contextInfo = 17;
  bool has_contextinfo() const;
  private:
  bool _internal_has_contextinfo() const;
  public:
  void clear_contextinfo();
  const ::proto::ContextInfo& contextinfo() const;
  PROTOBUF_NODISCARD ::proto::ContextInfo* release_contextinfo();
  ::proto::ContextInfo* mutable_contextinfo();
  void set_allocated_contextinfo(::proto::ContextInfo* contextinfo);
  private:
  const ::proto::ContextInfo& _internal_contextinfo() const;
  ::proto::ContextInfo* _internal_mutable_contextinfo();
  public:
  void unsafe_arena_set_allocated_contextinfo(
      ::proto::ContextInfo* contextinfo);
  ::proto::ContextInfo* unsafe_arena_release_contextinfo();

  // @@protoc_insertion_point(class_scope:proto.ProductMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr businessownerjid_;
    ::proto::ProductSnapshot* product_;
    ::proto::CatalogSnapshot* catalog_;
    ::proto::ContextInfo* contextinfo_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class OrderMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.OrderMessage) */ {
 public:
  inline OrderMessage() : OrderMessage(nullptr) {}
  ~OrderMessage() override;
  explicit PROTOBUF_CONSTEXPR OrderMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderMessage(const OrderMessage& from);
  OrderMessage(OrderMessage&& from) noexcept
    : OrderMessage() {
    *this = ::std::move(from);
  }

  inline OrderMessage& operator=(const OrderMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderMessage& operator=(OrderMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderMessage* internal_default_instance() {
    return reinterpret_cast<const OrderMessage*>(
               &_OrderMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(OrderMessage& a, OrderMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderMessage& from) {
    OrderMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.OrderMessage";
  }
  protected:
  explicit OrderMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OrderMessage_OrderMessageOrderStatus OrderMessageOrderStatus;
  static constexpr OrderMessageOrderStatus INQUIRY =
    OrderMessage_OrderMessageOrderStatus_INQUIRY;
  static inline bool OrderMessageOrderStatus_IsValid(int value) {
    return OrderMessage_OrderMessageOrderStatus_IsValid(value);
  }
  static constexpr OrderMessageOrderStatus OrderMessageOrderStatus_MIN =
    OrderMessage_OrderMessageOrderStatus_OrderMessageOrderStatus_MIN;
  static constexpr OrderMessageOrderStatus OrderMessageOrderStatus_MAX =
    OrderMessage_OrderMessageOrderStatus_OrderMessageOrderStatus_MAX;
  static constexpr int OrderMessageOrderStatus_ARRAYSIZE =
    OrderMessage_OrderMessageOrderStatus_OrderMessageOrderStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OrderMessageOrderStatus_descriptor() {
    return OrderMessage_OrderMessageOrderStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& OrderMessageOrderStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OrderMessageOrderStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OrderMessageOrderStatus_Name.");
    return OrderMessage_OrderMessageOrderStatus_Name(enum_t_value);
  }
  static inline bool OrderMessageOrderStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OrderMessageOrderStatus* value) {
    return OrderMessage_OrderMessageOrderStatus_Parse(name, value);
  }

  typedef OrderMessage_OrderMessageOrderSurface OrderMessageOrderSurface;
  static constexpr OrderMessageOrderSurface CATALOG =
    OrderMessage_OrderMessageOrderSurface_CATALOG;
  static inline bool OrderMessageOrderSurface_IsValid(int value) {
    return OrderMessage_OrderMessageOrderSurface_IsValid(value);
  }
  static constexpr OrderMessageOrderSurface OrderMessageOrderSurface_MIN =
    OrderMessage_OrderMessageOrderSurface_OrderMessageOrderSurface_MIN;
  static constexpr OrderMessageOrderSurface OrderMessageOrderSurface_MAX =
    OrderMessage_OrderMessageOrderSurface_OrderMessageOrderSurface_MAX;
  static constexpr int OrderMessageOrderSurface_ARRAYSIZE =
    OrderMessage_OrderMessageOrderSurface_OrderMessageOrderSurface_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OrderMessageOrderSurface_descriptor() {
    return OrderMessage_OrderMessageOrderSurface_descriptor();
  }
  template<typename T>
  static inline const std::string& OrderMessageOrderSurface_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OrderMessageOrderSurface>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OrderMessageOrderSurface_Name.");
    return OrderMessage_OrderMessageOrderSurface_Name(enum_t_value);
  }
  static inline bool OrderMessageOrderSurface_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OrderMessageOrderSurface* value) {
    return OrderMessage_OrderMessageOrderSurface_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOrderIdFieldNumber = 1,
    kThumbnailFieldNumber = 2,
    kMessageFieldNumber = 6,
    kOrderTitleFieldNumber = 7,
    kSellerJidFieldNumber = 8,
    kTokenFieldNumber = 9,
    kTotalCurrencyCodeFieldNumber = 11,
    kContextInfoFieldNumber = 17,
    kTotalAmount1000FieldNumber = 10,
    kItemCountFieldNumber = 3,
    kStatusFieldNumber = 4,
    kSurfaceFieldNumber = 5,
  };
  // optional string orderId = 1;
  bool has_orderid() const;
  private:
  bool _internal_has_orderid() const;
  public:
  void clear_orderid();
  const std::string& orderid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_orderid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_orderid();
  PROTOBUF_NODISCARD std::string* release_orderid();
  void set_allocated_orderid(std::string* orderid);
  private:
  const std::string& _internal_orderid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orderid(const std::string& value);
  std::string* _internal_mutable_orderid();
  public:

  // optional bytes thumbnail = 2;
  bool has_thumbnail() const;
  private:
  bool _internal_has_thumbnail() const;
  public:
  void clear_thumbnail();
  const std::string& thumbnail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnail();
  PROTOBUF_NODISCARD std::string* release_thumbnail();
  void set_allocated_thumbnail(std::string* thumbnail);
  private:
  const std::string& _internal_thumbnail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnail(const std::string& value);
  std::string* _internal_mutable_thumbnail();
  public:

  // optional string message = 6;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional string orderTitle = 7;
  bool has_ordertitle() const;
  private:
  bool _internal_has_ordertitle() const;
  public:
  void clear_ordertitle();
  const std::string& ordertitle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ordertitle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ordertitle();
  PROTOBUF_NODISCARD std::string* release_ordertitle();
  void set_allocated_ordertitle(std::string* ordertitle);
  private:
  const std::string& _internal_ordertitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ordertitle(const std::string& value);
  std::string* _internal_mutable_ordertitle();
  public:

  // optional string sellerJid = 8;
  bool has_sellerjid() const;
  private:
  bool _internal_has_sellerjid() const;
  public:
  void clear_sellerjid();
  const std::string& sellerjid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sellerjid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sellerjid();
  PROTOBUF_NODISCARD std::string* release_sellerjid();
  void set_allocated_sellerjid(std::string* sellerjid);
  private:
  const std::string& _internal_sellerjid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sellerjid(const std::string& value);
  std::string* _internal_mutable_sellerjid();
  public:

  // optional string token = 9;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // optional string totalCurrencyCode = 11;
  bool has_totalcurrencycode() const;
  private:
  bool _internal_has_totalcurrencycode() const;
  public:
  void clear_totalcurrencycode();
  const std::string& totalcurrencycode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_totalcurrencycode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_totalcurrencycode();
  PROTOBUF_NODISCARD std::string* release_totalcurrencycode();
  void set_allocated_totalcurrencycode(std::string* totalcurrencycode);
  private:
  const std::string& _internal_totalcurrencycode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_totalcurrencycode(const std::string& value);
  std::string* _internal_mutable_totalcurrencycode();
  public:

  // optional .proto.ContextInfo contextInfo = 17;
  bool has_contextinfo() const;
  private:
  bool _internal_has_contextinfo() const;
  public:
  void clear_contextinfo();
  const ::proto::ContextInfo& contextinfo() const;
  PROTOBUF_NODISCARD ::proto::ContextInfo* release_contextinfo();
  ::proto::ContextInfo* mutable_contextinfo();
  void set_allocated_contextinfo(::proto::ContextInfo* contextinfo);
  private:
  const ::proto::ContextInfo& _internal_contextinfo() const;
  ::proto::ContextInfo* _internal_mutable_contextinfo();
  public:
  void unsafe_arena_set_allocated_contextinfo(
      ::proto::ContextInfo* contextinfo);
  ::proto::ContextInfo* unsafe_arena_release_contextinfo();

  // optional int64 totalAmount1000 = 10;
  bool has_totalamount1000() const;
  private:
  bool _internal_has_totalamount1000() const;
  public:
  void clear_totalamount1000();
  int64_t totalamount1000() const;
  void set_totalamount1000(int64_t value);
  private:
  int64_t _internal_totalamount1000() const;
  void _internal_set_totalamount1000(int64_t value);
  public:

  // optional int32 itemCount = 3;
  bool has_itemcount() const;
  private:
  bool _internal_has_itemcount() const;
  public:
  void clear_itemcount();
  int32_t itemcount() const;
  void set_itemcount(int32_t value);
  private:
  int32_t _internal_itemcount() const;
  void _internal_set_itemcount(int32_t value);
  public:

  // optional .proto.OrderMessage.OrderMessageOrderStatus status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::proto::OrderMessage_OrderMessageOrderStatus status() const;
  void set_status(::proto::OrderMessage_OrderMessageOrderStatus value);
  private:
  ::proto::OrderMessage_OrderMessageOrderStatus _internal_status() const;
  void _internal_set_status(::proto::OrderMessage_OrderMessageOrderStatus value);
  public:

  // optional .proto.OrderMessage.OrderMessageOrderSurface surface = 5;
  bool has_surface() const;
  private:
  bool _internal_has_surface() const;
  public:
  void clear_surface();
  ::proto::OrderMessage_OrderMessageOrderSurface surface() const;
  void set_surface(::proto::OrderMessage_OrderMessageOrderSurface value);
  private:
  ::proto::OrderMessage_OrderMessageOrderSurface _internal_surface() const;
  void _internal_set_surface(::proto::OrderMessage_OrderMessageOrderSurface value);
  public:

  // @@protoc_insertion_point(class_scope:proto.OrderMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orderid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ordertitle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sellerjid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr totalcurrencycode_;
    ::proto::ContextInfo* contextinfo_;
    int64_t totalamount1000_;
    int32_t itemcount_;
    int status_;
    int surface_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class Row final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Row) */ {
 public:
  inline Row() : Row(nullptr) {}
  ~Row() override;
  explicit PROTOBUF_CONSTEXPR Row(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Row(const Row& from);
  Row(Row&& from) noexcept
    : Row() {
    *this = ::std::move(from);
  }

  inline Row& operator=(const Row& from) {
    CopyFrom(from);
    return *this;
  }
  inline Row& operator=(Row&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Row& default_instance() {
    return *internal_default_instance();
  }
  static inline const Row* internal_default_instance() {
    return reinterpret_cast<const Row*>(
               &_Row_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(Row& a, Row& b) {
    a.Swap(&b);
  }
  inline void Swap(Row* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Row* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Row* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Row>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Row& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Row& from) {
    Row::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Row* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Row";
  }
  protected:
  explicit Row(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kRowIdFieldNumber = 3,
  };
  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string description = 2;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string rowId = 3;
  bool has_rowid() const;
  private:
  bool _internal_has_rowid() const;
  public:
  void clear_rowid();
  const std::string& rowid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rowid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rowid();
  PROTOBUF_NODISCARD std::string* release_rowid();
  void set_allocated_rowid(std::string* rowid);
  private:
  const std::string& _internal_rowid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rowid(const std::string& value);
  std::string* _internal_mutable_rowid();
  public:

  // @@protoc_insertion_point(class_scope:proto.Row)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rowid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class Section final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Section) */ {
 public:
  inline Section() : Section(nullptr) {}
  ~Section() override;
  explicit PROTOBUF_CONSTEXPR Section(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Section(const Section& from);
  Section(Section&& from) noexcept
    : Section() {
    *this = ::std::move(from);
  }

  inline Section& operator=(const Section& from) {
    CopyFrom(from);
    return *this;
  }
  inline Section& operator=(Section&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Section& default_instance() {
    return *internal_default_instance();
  }
  static inline const Section* internal_default_instance() {
    return reinterpret_cast<const Section*>(
               &_Section_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(Section& a, Section& b) {
    a.Swap(&b);
  }
  inline void Swap(Section* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Section* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Section* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Section>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Section& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Section& from) {
    Section::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Section* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Section";
  }
  protected:
  explicit Section(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowsFieldNumber = 2,
    kTitleFieldNumber = 1,
  };
  // repeated .proto.Row rows = 2;
  int rows_size() const;
  private:
  int _internal_rows_size() const;
  public:
  void clear_rows();
  ::proto::Row* mutable_rows(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Row >*
      mutable_rows();
  private:
  const ::proto::Row& _internal_rows(int index) const;
  ::proto::Row* _internal_add_rows();
  public:
  const ::proto::Row& rows(int index) const;
  ::proto::Row* add_rows();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Row >&
      rows() const;

  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // @@protoc_insertion_point(class_scope:proto.Section)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Row > rows_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class ListMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ListMessage) */ {
 public:
  inline ListMessage() : ListMessage(nullptr) {}
  ~ListMessage() override;
  explicit PROTOBUF_CONSTEXPR ListMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListMessage(const ListMessage& from);
  ListMessage(ListMessage&& from) noexcept
    : ListMessage() {
    *this = ::std::move(from);
  }

  inline ListMessage& operator=(const ListMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListMessage& operator=(ListMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListMessage* internal_default_instance() {
    return reinterpret_cast<const ListMessage*>(
               &_ListMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(ListMessage& a, ListMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ListMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListMessage& from) {
    ListMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ListMessage";
  }
  protected:
  explicit ListMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ListMessage_ListMessageListType ListMessageListType;
  static constexpr ListMessageListType UNKNOWN =
    ListMessage_ListMessageListType_UNKNOWN;
  static constexpr ListMessageListType SINGLE_SELECT =
    ListMessage_ListMessageListType_SINGLE_SELECT;
  static inline bool ListMessageListType_IsValid(int value) {
    return ListMessage_ListMessageListType_IsValid(value);
  }
  static constexpr ListMessageListType ListMessageListType_MIN =
    ListMessage_ListMessageListType_ListMessageListType_MIN;
  static constexpr ListMessageListType ListMessageListType_MAX =
    ListMessage_ListMessageListType_ListMessageListType_MAX;
  static constexpr int ListMessageListType_ARRAYSIZE =
    ListMessage_ListMessageListType_ListMessageListType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ListMessageListType_descriptor() {
    return ListMessage_ListMessageListType_descriptor();
  }
  template<typename T>
  static inline const std::string& ListMessageListType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ListMessageListType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ListMessageListType_Name.");
    return ListMessage_ListMessageListType_Name(enum_t_value);
  }
  static inline bool ListMessageListType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ListMessageListType* value) {
    return ListMessage_ListMessageListType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSectionsFieldNumber = 5,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kButtonTextFieldNumber = 3,
    kListTypeFieldNumber = 4,
  };
  // repeated .proto.Section sections = 5;
  int sections_size() const;
  private:
  int _internal_sections_size() const;
  public:
  void clear_sections();
  ::proto::Section* mutable_sections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Section >*
      mutable_sections();
  private:
  const ::proto::Section& _internal_sections(int index) const;
  ::proto::Section* _internal_add_sections();
  public:
  const ::proto::Section& sections(int index) const;
  ::proto::Section* add_sections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Section >&
      sections() const;

  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string description = 2;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string buttonText = 3;
  bool has_buttontext() const;
  private:
  bool _internal_has_buttontext() const;
  public:
  void clear_buttontext();
  const std::string& buttontext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buttontext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buttontext();
  PROTOBUF_NODISCARD std::string* release_buttontext();
  void set_allocated_buttontext(std::string* buttontext);
  private:
  const std::string& _internal_buttontext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buttontext(const std::string& value);
  std::string* _internal_mutable_buttontext();
  public:

  // optional .proto.ListMessage.ListMessageListType listType = 4;
  bool has_listtype() const;
  private:
  bool _internal_has_listtype() const;
  public:
  void clear_listtype();
  ::proto::ListMessage_ListMessageListType listtype() const;
  void set_listtype(::proto::ListMessage_ListMessageListType value);
  private:
  ::proto::ListMessage_ListMessageListType _internal_listtype() const;
  void _internal_set_listtype(::proto::ListMessage_ListMessageListType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ListMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Section > sections_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buttontext_;
    int listtype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class SingleSelectReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.SingleSelectReply) */ {
 public:
  inline SingleSelectReply() : SingleSelectReply(nullptr) {}
  ~SingleSelectReply() override;
  explicit PROTOBUF_CONSTEXPR SingleSelectReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleSelectReply(const SingleSelectReply& from);
  SingleSelectReply(SingleSelectReply&& from) noexcept
    : SingleSelectReply() {
    *this = ::std::move(from);
  }

  inline SingleSelectReply& operator=(const SingleSelectReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleSelectReply& operator=(SingleSelectReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleSelectReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleSelectReply* internal_default_instance() {
    return reinterpret_cast<const SingleSelectReply*>(
               &_SingleSelectReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(SingleSelectReply& a, SingleSelectReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleSelectReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleSelectReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SingleSelectReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SingleSelectReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleSelectReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SingleSelectReply& from) {
    SingleSelectReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleSelectReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SingleSelectReply";
  }
  protected:
  explicit SingleSelectReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelectedRowIdFieldNumber = 1,
  };
  // optional string selectedRowId = 1;
  bool has_selectedrowid() const;
  private:
  bool _internal_has_selectedrowid() const;
  public:
  void clear_selectedrowid();
  const std::string& selectedrowid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selectedrowid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selectedrowid();
  PROTOBUF_NODISCARD std::string* release_selectedrowid();
  void set_allocated_selectedrowid(std::string* selectedrowid);
  private:
  const std::string& _internal_selectedrowid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selectedrowid(const std::string& value);
  std::string* _internal_mutable_selectedrowid();
  public:

  // @@protoc_insertion_point(class_scope:proto.SingleSelectReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selectedrowid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class ListResponseMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ListResponseMessage) */ {
 public:
  inline ListResponseMessage() : ListResponseMessage(nullptr) {}
  ~ListResponseMessage() override;
  explicit PROTOBUF_CONSTEXPR ListResponseMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListResponseMessage(const ListResponseMessage& from);
  ListResponseMessage(ListResponseMessage&& from) noexcept
    : ListResponseMessage() {
    *this = ::std::move(from);
  }

  inline ListResponseMessage& operator=(const ListResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListResponseMessage& operator=(ListResponseMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListResponseMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListResponseMessage* internal_default_instance() {
    return reinterpret_cast<const ListResponseMessage*>(
               &_ListResponseMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(ListResponseMessage& a, ListResponseMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ListResponseMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListResponseMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListResponseMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListResponseMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListResponseMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListResponseMessage& from) {
    ListResponseMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListResponseMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ListResponseMessage";
  }
  protected:
  explicit ListResponseMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ListResponseMessage_ListResponseMessageListType ListResponseMessageListType;
  static constexpr ListResponseMessageListType UNKNOWN =
    ListResponseMessage_ListResponseMessageListType_UNKNOWN;
  static constexpr ListResponseMessageListType SINGLE_SELECT =
    ListResponseMessage_ListResponseMessageListType_SINGLE_SELECT;
  static inline bool ListResponseMessageListType_IsValid(int value) {
    return ListResponseMessage_ListResponseMessageListType_IsValid(value);
  }
  static constexpr ListResponseMessageListType ListResponseMessageListType_MIN =
    ListResponseMessage_ListResponseMessageListType_ListResponseMessageListType_MIN;
  static constexpr ListResponseMessageListType ListResponseMessageListType_MAX =
    ListResponseMessage_ListResponseMessageListType_ListResponseMessageListType_MAX;
  static constexpr int ListResponseMessageListType_ARRAYSIZE =
    ListResponseMessage_ListResponseMessageListType_ListResponseMessageListType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ListResponseMessageListType_descriptor() {
    return ListResponseMessage_ListResponseMessageListType_descriptor();
  }
  template<typename T>
  static inline const std::string& ListResponseMessageListType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ListResponseMessageListType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ListResponseMessageListType_Name.");
    return ListResponseMessage_ListResponseMessageListType_Name(enum_t_value);
  }
  static inline bool ListResponseMessageListType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ListResponseMessageListType* value) {
    return ListResponseMessage_ListResponseMessageListType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 5,
    kSingleSelectReplyFieldNumber = 3,
    kContextInfoFieldNumber = 4,
    kListTypeFieldNumber = 2,
  };
  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string description = 5;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional .proto.SingleSelectReply singleSelectReply = 3;
  bool has_singleselectreply() const;
  private:
  bool _internal_has_singleselectreply() const;
  public:
  void clear_singleselectreply();
  const ::proto::SingleSelectReply& singleselectreply() const;
  PROTOBUF_NODISCARD ::proto::SingleSelectReply* release_singleselectreply();
  ::proto::SingleSelectReply* mutable_singleselectreply();
  void set_allocated_singleselectreply(::proto::SingleSelectReply* singleselectreply);
  private:
  const ::proto::SingleSelectReply& _internal_singleselectreply() const;
  ::proto::SingleSelectReply* _internal_mutable_singleselectreply();
  public:
  void unsafe_arena_set_allocated_singleselectreply(
      ::proto::SingleSelectReply* singleselectreply);
  ::proto::SingleSelectReply* unsafe_arena_release_singleselectreply();

  // optional .proto.ContextInfo contextInfo = 4;
  bool has_contextinfo() const;
  private:
  bool _internal_has_contextinfo() const;
  public:
  void clear_contextinfo();
  const ::proto::ContextInfo& contextinfo() const;
  PROTOBUF_NODISCARD ::proto::ContextInfo* release_contextinfo();
  ::proto::ContextInfo* mutable_contextinfo();
  void set_allocated_contextinfo(::proto::ContextInfo* contextinfo);
  private:
  const ::proto::ContextInfo& _internal_contextinfo() const;
  ::proto::ContextInfo* _internal_mutable_contextinfo();
  public:
  void unsafe_arena_set_allocated_contextinfo(
      ::proto::ContextInfo* contextinfo);
  ::proto::ContextInfo* unsafe_arena_release_contextinfo();

  // optional .proto.ListResponseMessage.ListResponseMessageListType listType = 2;
  bool has_listtype() const;
  private:
  bool _internal_has_listtype() const;
  public:
  void clear_listtype();
  ::proto::ListResponseMessage_ListResponseMessageListType listtype() const;
  void set_listtype(::proto::ListResponseMessage_ListResponseMessageListType value);
  private:
  ::proto::ListResponseMessage_ListResponseMessageListType _internal_listtype() const;
  void _internal_set_listtype(::proto::ListResponseMessage_ListResponseMessageListType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ListResponseMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::proto::SingleSelectReply* singleselectreply_;
    ::proto::ContextInfo* contextinfo_;
    int listtype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class GroupInviteMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.GroupInviteMessage) */ {
 public:
  inline GroupInviteMessage() : GroupInviteMessage(nullptr) {}
  ~GroupInviteMessage() override;
  explicit PROTOBUF_CONSTEXPR GroupInviteMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupInviteMessage(const GroupInviteMessage& from);
  GroupInviteMessage(GroupInviteMessage&& from) noexcept
    : GroupInviteMessage() {
    *this = ::std::move(from);
  }

  inline GroupInviteMessage& operator=(const GroupInviteMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupInviteMessage& operator=(GroupInviteMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupInviteMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupInviteMessage* internal_default_instance() {
    return reinterpret_cast<const GroupInviteMessage*>(
               &_GroupInviteMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(GroupInviteMessage& a, GroupInviteMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupInviteMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupInviteMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupInviteMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupInviteMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupInviteMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupInviteMessage& from) {
    GroupInviteMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupInviteMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.GroupInviteMessage";
  }
  protected:
  explicit GroupInviteMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupJidFieldNumber = 1,
    kInviteCodeFieldNumber = 2,
    kGroupNameFieldNumber = 4,
    kJpegThumbnailFieldNumber = 5,
    kCaptionFieldNumber = 6,
    kContextInfoFieldNumber = 7,
    kInviteExpirationFieldNumber = 3,
  };
  // optional string groupJid = 1;
  bool has_groupjid() const;
  private:
  bool _internal_has_groupjid() const;
  public:
  void clear_groupjid();
  const std::string& groupjid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupjid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupjid();
  PROTOBUF_NODISCARD std::string* release_groupjid();
  void set_allocated_groupjid(std::string* groupjid);
  private:
  const std::string& _internal_groupjid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupjid(const std::string& value);
  std::string* _internal_mutable_groupjid();
  public:

  // optional string inviteCode = 2;
  bool has_invitecode() const;
  private:
  bool _internal_has_invitecode() const;
  public:
  void clear_invitecode();
  const std::string& invitecode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invitecode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invitecode();
  PROTOBUF_NODISCARD std::string* release_invitecode();
  void set_allocated_invitecode(std::string* invitecode);
  private:
  const std::string& _internal_invitecode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invitecode(const std::string& value);
  std::string* _internal_mutable_invitecode();
  public:

  // optional string groupName = 4;
  bool has_groupname() const;
  private:
  bool _internal_has_groupname() const;
  public:
  void clear_groupname();
  const std::string& groupname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupname();
  PROTOBUF_NODISCARD std::string* release_groupname();
  void set_allocated_groupname(std::string* groupname);
  private:
  const std::string& _internal_groupname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupname(const std::string& value);
  std::string* _internal_mutable_groupname();
  public:

  // optional bytes jpegThumbnail = 5;
  bool has_jpegthumbnail() const;
  private:
  bool _internal_has_jpegthumbnail() const;
  public:
  void clear_jpegthumbnail();
  const std::string& jpegthumbnail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jpegthumbnail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jpegthumbnail();
  PROTOBUF_NODISCARD std::string* release_jpegthumbnail();
  void set_allocated_jpegthumbnail(std::string* jpegthumbnail);
  private:
  const std::string& _internal_jpegthumbnail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jpegthumbnail(const std::string& value);
  std::string* _internal_mutable_jpegthumbnail();
  public:

  // optional string caption = 6;
  bool has_caption() const;
  private:
  bool _internal_has_caption() const;
  public:
  void clear_caption();
  const std::string& caption() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caption(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caption();
  PROTOBUF_NODISCARD std::string* release_caption();
  void set_allocated_caption(std::string* caption);
  private:
  const std::string& _internal_caption() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caption(const std::string& value);
  std::string* _internal_mutable_caption();
  public:

  // optional .proto.ContextInfo contextInfo = 7;
  bool has_contextinfo() const;
  private:
  bool _internal_has_contextinfo() const;
  public:
  void clear_contextinfo();
  const ::proto::ContextInfo& contextinfo() const;
  PROTOBUF_NODISCARD ::proto::ContextInfo* release_contextinfo();
  ::proto::ContextInfo* mutable_contextinfo();
  void set_allocated_contextinfo(::proto::ContextInfo* contextinfo);
  private:
  const ::proto::ContextInfo& _internal_contextinfo() const;
  ::proto::ContextInfo* _internal_mutable_contextinfo();
  public:
  void unsafe_arena_set_allocated_contextinfo(
      ::proto::ContextInfo* contextinfo);
  ::proto::ContextInfo* unsafe_arena_release_contextinfo();

  // optional int64 inviteExpiration = 3;
  bool has_inviteexpiration() const;
  private:
  bool _internal_has_inviteexpiration() const;
  public:
  void clear_inviteexpiration();
  int64_t inviteexpiration() const;
  void set_inviteexpiration(int64_t value);
  private:
  int64_t _internal_inviteexpiration() const;
  void _internal_set_inviteexpiration(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.GroupInviteMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupjid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invitecode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jpegthumbnail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caption_;
    ::proto::ContextInfo* contextinfo_;
    int64_t inviteexpiration_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class EphemeralSetting final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.EphemeralSetting) */ {
 public:
  inline EphemeralSetting() : EphemeralSetting(nullptr) {}
  ~EphemeralSetting() override;
  explicit PROTOBUF_CONSTEXPR EphemeralSetting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EphemeralSetting(const EphemeralSetting& from);
  EphemeralSetting(EphemeralSetting&& from) noexcept
    : EphemeralSetting() {
    *this = ::std::move(from);
  }

  inline EphemeralSetting& operator=(const EphemeralSetting& from) {
    CopyFrom(from);
    return *this;
  }
  inline EphemeralSetting& operator=(EphemeralSetting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EphemeralSetting& default_instance() {
    return *internal_default_instance();
  }
  static inline const EphemeralSetting* internal_default_instance() {
    return reinterpret_cast<const EphemeralSetting*>(
               &_EphemeralSetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(EphemeralSetting& a, EphemeralSetting& b) {
    a.Swap(&b);
  }
  inline void Swap(EphemeralSetting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EphemeralSetting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EphemeralSetting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EphemeralSetting>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EphemeralSetting& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EphemeralSetting& from) {
    EphemeralSetting::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EphemeralSetting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.EphemeralSetting";
  }
  protected:
  explicit EphemeralSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatJidFieldNumber = 1,
    kEphemeralSettingTimestampFieldNumber = 3,
    kEphemeralExpirationFieldNumber = 2,
  };
  // optional string chatJid = 1;
  bool has_chatjid() const;
  private:
  bool _internal_has_chatjid() const;
  public:
  void clear_chatjid();
  const std::string& chatjid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chatjid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chatjid();
  PROTOBUF_NODISCARD std::string* release_chatjid();
  void set_allocated_chatjid(std::string* chatjid);
  private:
  const std::string& _internal_chatjid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chatjid(const std::string& value);
  std::string* _internal_mutable_chatjid();
  public:

  // optional int64 ephemeralSettingTimestamp = 3;
  bool has_ephemeralsettingtimestamp() const;
  private:
  bool _internal_has_ephemeralsettingtimestamp() const;
  public:
  void clear_ephemeralsettingtimestamp();
  int64_t ephemeralsettingtimestamp() const;
  void set_ephemeralsettingtimestamp(int64_t value);
  private:
  int64_t _internal_ephemeralsettingtimestamp() const;
  void _internal_set_ephemeralsettingtimestamp(int64_t value);
  public:

  // optional uint32 ephemeralExpiration = 2;
  bool has_ephemeralexpiration() const;
  private:
  bool _internal_has_ephemeralexpiration() const;
  public:
  void clear_ephemeralexpiration();
  uint32_t ephemeralexpiration() const;
  void set_ephemeralexpiration(uint32_t value);
  private:
  uint32_t _internal_ephemeralexpiration() const;
  void _internal_set_ephemeralexpiration(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.EphemeralSetting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chatjid_;
    int64_t ephemeralsettingtimestamp_;
    uint32_t ephemeralexpiration_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class DeviceSentMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.DeviceSentMessage) */ {
 public:
  inline DeviceSentMessage() : DeviceSentMessage(nullptr) {}
  ~DeviceSentMessage() override;
  explicit PROTOBUF_CONSTEXPR DeviceSentMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceSentMessage(const DeviceSentMessage& from);
  DeviceSentMessage(DeviceSentMessage&& from) noexcept
    : DeviceSentMessage() {
    *this = ::std::move(from);
  }

  inline DeviceSentMessage& operator=(const DeviceSentMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceSentMessage& operator=(DeviceSentMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceSentMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceSentMessage* internal_default_instance() {
    return reinterpret_cast<const DeviceSentMessage*>(
               &_DeviceSentMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(DeviceSentMessage& a, DeviceSentMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceSentMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceSentMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceSentMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceSentMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceSentMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceSentMessage& from) {
    DeviceSentMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceSentMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.DeviceSentMessage";
  }
  protected:
  explicit DeviceSentMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastEphemeralSettingsFieldNumber = 4,
    kDestinationJidFieldNumber = 1,
    kPhashFieldNumber = 3,
    kMessageFieldNumber = 2,
  };
  // repeated .proto.EphemeralSetting broadcastEphemeralSettings = 4;
  int broadcastephemeralsettings_size() const;
  private:
  int _internal_broadcastephemeralsettings_size() const;
  public:
  void clear_broadcastephemeralsettings();
  ::proto::EphemeralSetting* mutable_broadcastephemeralsettings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::EphemeralSetting >*
      mutable_broadcastephemeralsettings();
  private:
  const ::proto::EphemeralSetting& _internal_broadcastephemeralsettings(int index) const;
  ::proto::EphemeralSetting* _internal_add_broadcastephemeralsettings();
  public:
  const ::proto::EphemeralSetting& broadcastephemeralsettings(int index) const;
  ::proto::EphemeralSetting* add_broadcastephemeralsettings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::EphemeralSetting >&
      broadcastephemeralsettings() const;

  // optional string destinationJid = 1;
  bool has_destinationjid() const;
  private:
  bool _internal_has_destinationjid() const;
  public:
  void clear_destinationjid();
  const std::string& destinationjid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destinationjid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destinationjid();
  PROTOBUF_NODISCARD std::string* release_destinationjid();
  void set_allocated_destinationjid(std::string* destinationjid);
  private:
  const std::string& _internal_destinationjid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destinationjid(const std::string& value);
  std::string* _internal_mutable_destinationjid();
  public:

  // optional string phash = 3;
  bool has_phash() const;
  private:
  bool _internal_has_phash() const;
  public:
  void clear_phash();
  const std::string& phash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phash();
  PROTOBUF_NODISCARD std::string* release_phash();
  void set_allocated_phash(std::string* phash);
  private:
  const std::string& _internal_phash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phash(const std::string& value);
  std::string* _internal_mutable_phash();
  public:

  // optional .proto.Message message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::proto::Message& message() const;
  PROTOBUF_NODISCARD ::proto::Message* release_message();
  ::proto::Message* mutable_message();
  void set_allocated_message(::proto::Message* message);
  private:
  const ::proto::Message& _internal_message() const;
  ::proto::Message* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::proto::Message* message);
  ::proto::Message* unsafe_arena_release_message();

  // @@protoc_insertion_point(class_scope:proto.DeviceSentMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::EphemeralSetting > broadcastephemeralsettings_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destinationjid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phash_;
    ::proto::Message* message_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class FutureProofMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.FutureProofMessage) */ {
 public:
  inline FutureProofMessage() : FutureProofMessage(nullptr) {}
  ~FutureProofMessage() override;
  explicit PROTOBUF_CONSTEXPR FutureProofMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FutureProofMessage(const FutureProofMessage& from);
  FutureProofMessage(FutureProofMessage&& from) noexcept
    : FutureProofMessage() {
    *this = ::std::move(from);
  }

  inline FutureProofMessage& operator=(const FutureProofMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline FutureProofMessage& operator=(FutureProofMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FutureProofMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const FutureProofMessage* internal_default_instance() {
    return reinterpret_cast<const FutureProofMessage*>(
               &_FutureProofMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(FutureProofMessage& a, FutureProofMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(FutureProofMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FutureProofMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FutureProofMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FutureProofMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FutureProofMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FutureProofMessage& from) {
    FutureProofMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FutureProofMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.FutureProofMessage";
  }
  protected:
  explicit FutureProofMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // optional .proto.Message message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::proto::Message& message() const;
  PROTOBUF_NODISCARD ::proto::Message* release_message();
  ::proto::Message* mutable_message();
  void set_allocated_message(::proto::Message* message);
  private:
  const ::proto::Message& _internal_message() const;
  ::proto::Message* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::proto::Message* message);
  ::proto::Message* unsafe_arena_release_message();

  // @@protoc_insertion_point(class_scope:proto.FutureProofMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::proto::Message* message_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class ButtonText final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ButtonText) */ {
 public:
  inline ButtonText() : ButtonText(nullptr) {}
  ~ButtonText() override;
  explicit PROTOBUF_CONSTEXPR ButtonText(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ButtonText(const ButtonText& from);
  ButtonText(ButtonText&& from) noexcept
    : ButtonText() {
    *this = ::std::move(from);
  }

  inline ButtonText& operator=(const ButtonText& from) {
    CopyFrom(from);
    return *this;
  }
  inline ButtonText& operator=(ButtonText&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ButtonText& default_instance() {
    return *internal_default_instance();
  }
  static inline const ButtonText* internal_default_instance() {
    return reinterpret_cast<const ButtonText*>(
               &_ButtonText_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(ButtonText& a, ButtonText& b) {
    a.Swap(&b);
  }
  inline void Swap(ButtonText* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ButtonText* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ButtonText* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ButtonText>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ButtonText& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ButtonText& from) {
    ButtonText::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ButtonText* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ButtonText";
  }
  protected:
  explicit ButtonText(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayTextFieldNumber = 1,
  };
  // optional string displayText = 1;
  bool has_displaytext() const;
  private:
  bool _internal_has_displaytext() const;
  public:
  void clear_displaytext();
  const std::string& displaytext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_displaytext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_displaytext();
  PROTOBUF_NODISCARD std::string* release_displaytext();
  void set_allocated_displaytext(std::string* displaytext);
  private:
  const std::string& _internal_displaytext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_displaytext(const std::string& value);
  std::string* _internal_mutable_displaytext();
  public:

  // @@protoc_insertion_point(class_scope:proto.ButtonText)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr displaytext_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class Button final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Button) */ {
 public:
  inline Button() : Button(nullptr) {}
  ~Button() override;
  explicit PROTOBUF_CONSTEXPR Button(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Button(const Button& from);
  Button(Button&& from) noexcept
    : Button() {
    *this = ::std::move(from);
  }

  inline Button& operator=(const Button& from) {
    CopyFrom(from);
    return *this;
  }
  inline Button& operator=(Button&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Button& default_instance() {
    return *internal_default_instance();
  }
  static inline const Button* internal_default_instance() {
    return reinterpret_cast<const Button*>(
               &_Button_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(Button& a, Button& b) {
    a.Swap(&b);
  }
  inline void Swap(Button* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Button* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Button* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Button>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Button& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Button& from) {
    Button::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Button* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Button";
  }
  protected:
  explicit Button(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Button_ButtonType ButtonType;
  static constexpr ButtonType UNKNOWN =
    Button_ButtonType_UNKNOWN;
  static constexpr ButtonType RESPONSE =
    Button_ButtonType_RESPONSE;
  static inline bool ButtonType_IsValid(int value) {
    return Button_ButtonType_IsValid(value);
  }
  static constexpr ButtonType ButtonType_MIN =
    Button_ButtonType_ButtonType_MIN;
  static constexpr ButtonType ButtonType_MAX =
    Button_ButtonType_ButtonType_MAX;
  static constexpr int ButtonType_ARRAYSIZE =
    Button_ButtonType_ButtonType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ButtonType_descriptor() {
    return Button_ButtonType_descriptor();
  }
  template<typename T>
  static inline const std::string& ButtonType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ButtonType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ButtonType_Name.");
    return Button_ButtonType_Name(enum_t_value);
  }
  static inline bool ButtonType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ButtonType* value) {
    return Button_ButtonType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kButtonIdFieldNumber = 1,
    kButtonTextFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // optional string buttonId = 1;
  bool has_buttonid() const;
  private:
  bool _internal_has_buttonid() const;
  public:
  void clear_buttonid();
  const std::string& buttonid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buttonid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buttonid();
  PROTOBUF_NODISCARD std::string* release_buttonid();
  void set_allocated_buttonid(std::string* buttonid);
  private:
  const std::string& _internal_buttonid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buttonid(const std::string& value);
  std::string* _internal_mutable_buttonid();
  public:

  // optional .proto.ButtonText buttonText = 2;
  bool has_buttontext() const;
  private:
  bool _internal_has_buttontext() const;
  public:
  void clear_buttontext();
  const ::proto::ButtonText& buttontext() const;
  PROTOBUF_NODISCARD ::proto::ButtonText* release_buttontext();
  ::proto::ButtonText* mutable_buttontext();
  void set_allocated_buttontext(::proto::ButtonText* buttontext);
  private:
  const ::proto::ButtonText& _internal_buttontext() const;
  ::proto::ButtonText* _internal_mutable_buttontext();
  public:
  void unsafe_arena_set_allocated_buttontext(
      ::proto::ButtonText* buttontext);
  ::proto::ButtonText* unsafe_arena_release_buttontext();

  // optional .proto.Button.ButtonType type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::proto::Button_ButtonType type() const;
  void set_type(::proto::Button_ButtonType value);
  private:
  ::proto::Button_ButtonType _internal_type() const;
  void _internal_set_type(::proto::Button_ButtonType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Button)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buttonid_;
    ::proto::ButtonText* buttontext_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class ButtonsMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ButtonsMessage) */ {
 public:
  inline ButtonsMessage() : ButtonsMessage(nullptr) {}
  ~ButtonsMessage() override;
  explicit PROTOBUF_CONSTEXPR ButtonsMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ButtonsMessage(const ButtonsMessage& from);
  ButtonsMessage(ButtonsMessage&& from) noexcept
    : ButtonsMessage() {
    *this = ::std::move(from);
  }

  inline ButtonsMessage& operator=(const ButtonsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ButtonsMessage& operator=(ButtonsMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ButtonsMessage& default_instance() {
    return *internal_default_instance();
  }
  enum HeaderCase {
    kText = 1,
    kDocumentMessage = 2,
    kImageMessage = 3,
    kVideoMessage = 4,
    kLocationMessage = 5,
    HEADER_NOT_SET = 0,
  };

  static inline const ButtonsMessage* internal_default_instance() {
    return reinterpret_cast<const ButtonsMessage*>(
               &_ButtonsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(ButtonsMessage& a, ButtonsMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ButtonsMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ButtonsMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ButtonsMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ButtonsMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ButtonsMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ButtonsMessage& from) {
    ButtonsMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ButtonsMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ButtonsMessage";
  }
  protected:
  explicit ButtonsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ButtonsMessage_ButtonsMessageHeaderType ButtonsMessageHeaderType;
  static constexpr ButtonsMessageHeaderType UNKNOWN =
    ButtonsMessage_ButtonsMessageHeaderType_UNKNOWN;
  static constexpr ButtonsMessageHeaderType EMPTY =
    ButtonsMessage_ButtonsMessageHeaderType_EMPTY;
  static constexpr ButtonsMessageHeaderType TEXT =
    ButtonsMessage_ButtonsMessageHeaderType_TEXT;
  static constexpr ButtonsMessageHeaderType DOCUMENT =
    ButtonsMessage_ButtonsMessageHeaderType_DOCUMENT;
  static constexpr ButtonsMessageHeaderType IMAGE =
    ButtonsMessage_ButtonsMessageHeaderType_IMAGE;
  static constexpr ButtonsMessageHeaderType VIDEO =
    ButtonsMessage_ButtonsMessageHeaderType_VIDEO;
  static constexpr ButtonsMessageHeaderType LOCATION =
    ButtonsMessage_ButtonsMessageHeaderType_LOCATION;
  static inline bool ButtonsMessageHeaderType_IsValid(int value) {
    return ButtonsMessage_ButtonsMessageHeaderType_IsValid(value);
  }
  static constexpr ButtonsMessageHeaderType ButtonsMessageHeaderType_MIN =
    ButtonsMessage_ButtonsMessageHeaderType_ButtonsMessageHeaderType_MIN;
  static constexpr ButtonsMessageHeaderType ButtonsMessageHeaderType_MAX =
    ButtonsMessage_ButtonsMessageHeaderType_ButtonsMessageHeaderType_MAX;
  static constexpr int ButtonsMessageHeaderType_ARRAYSIZE =
    ButtonsMessage_ButtonsMessageHeaderType_ButtonsMessageHeaderType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ButtonsMessageHeaderType_descriptor() {
    return ButtonsMessage_ButtonsMessageHeaderType_descriptor();
  }
  template<typename T>
  static inline const std::string& ButtonsMessageHeaderType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ButtonsMessageHeaderType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ButtonsMessageHeaderType_Name.");
    return ButtonsMessage_ButtonsMessageHeaderType_Name(enum_t_value);
  }
  static inline bool ButtonsMessageHeaderType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ButtonsMessageHeaderType* value) {
    return ButtonsMessage_ButtonsMessageHeaderType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kButtonsFieldNumber = 9,
    kContentTextFieldNumber = 6,
    kFooterTextFieldNumber = 7,
    kContextInfoFieldNumber = 8,
    kHeaderTypeFieldNumber = 10,
    kTextFieldNumber = 1,
    kDocumentMessageFieldNumber = 2,
    kImageMessageFieldNumber = 3,
    kVideoMessageFieldNumber = 4,
    kLocationMessageFieldNumber = 5,
  };
  // repeated .proto.Button buttons = 9;
  int buttons_size() const;
  private:
  int _internal_buttons_size() const;
  public:
  void clear_buttons();
  ::proto::Button* mutable_buttons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Button >*
      mutable_buttons();
  private:
  const ::proto::Button& _internal_buttons(int index) const;
  ::proto::Button* _internal_add_buttons();
  public:
  const ::proto::Button& buttons(int index) const;
  ::proto::Button* add_buttons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Button >&
      buttons() const;

  // optional string contentText = 6;
  bool has_contenttext() const;
  private:
  bool _internal_has_contenttext() const;
  public:
  void clear_contenttext();
  const std::string& contenttext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contenttext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contenttext();
  PROTOBUF_NODISCARD std::string* release_contenttext();
  void set_allocated_contenttext(std::string* contenttext);
  private:
  const std::string& _internal_contenttext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contenttext(const std::string& value);
  std::string* _internal_mutable_contenttext();
  public:

  // optional string footerText = 7;
  bool has_footertext() const;
  private:
  bool _internal_has_footertext() const;
  public:
  void clear_footertext();
  const std::string& footertext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_footertext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_footertext();
  PROTOBUF_NODISCARD std::string* release_footertext();
  void set_allocated_footertext(std::string* footertext);
  private:
  const std::string& _internal_footertext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_footertext(const std::string& value);
  std::string* _internal_mutable_footertext();
  public:

  // optional .proto.ContextInfo contextInfo = 8;
  bool has_contextinfo() const;
  private:
  bool _internal_has_contextinfo() const;
  public:
  void clear_contextinfo();
  const ::proto::ContextInfo& contextinfo() const;
  PROTOBUF_NODISCARD ::proto::ContextInfo* release_contextinfo();
  ::proto::ContextInfo* mutable_contextinfo();
  void set_allocated_contextinfo(::proto::ContextInfo* contextinfo);
  private:
  const ::proto::ContextInfo& _internal_contextinfo() const;
  ::proto::ContextInfo* _internal_mutable_contextinfo();
  public:
  void unsafe_arena_set_allocated_contextinfo(
      ::proto::ContextInfo* contextinfo);
  ::proto::ContextInfo* unsafe_arena_release_contextinfo();

  // optional .proto.ButtonsMessage.ButtonsMessageHeaderType headerType = 10;
  bool has_headertype() const;
  private:
  bool _internal_has_headertype() const;
  public:
  void clear_headertype();
  ::proto::ButtonsMessage_ButtonsMessageHeaderType headertype() const;
  void set_headertype(::proto::ButtonsMessage_ButtonsMessageHeaderType value);
  private:
  ::proto::ButtonsMessage_ButtonsMessageHeaderType _internal_headertype() const;
  void _internal_set_headertype(::proto::ButtonsMessage_ButtonsMessageHeaderType value);
  public:

  // string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .proto.DocumentMessage documentMessage = 2;
  bool has_documentmessage() const;
  private:
  bool _internal_has_documentmessage() const;
  public:
  void clear_documentmessage();
  const ::proto::DocumentMessage& documentmessage() const;
  PROTOBUF_NODISCARD ::proto::DocumentMessage* release_documentmessage();
  ::proto::DocumentMessage* mutable_documentmessage();
  void set_allocated_documentmessage(::proto::DocumentMessage* documentmessage);
  private:
  const ::proto::DocumentMessage& _internal_documentmessage() const;
  ::proto::DocumentMessage* _internal_mutable_documentmessage();
  public:
  void unsafe_arena_set_allocated_documentmessage(
      ::proto::DocumentMessage* documentmessage);
  ::proto::DocumentMessage* unsafe_arena_release_documentmessage();

  // .proto.ImageMessage imageMessage = 3;
  bool has_imagemessage() const;
  private:
  bool _internal_has_imagemessage() const;
  public:
  void clear_imagemessage();
  const ::proto::ImageMessage& imagemessage() const;
  PROTOBUF_NODISCARD ::proto::ImageMessage* release_imagemessage();
  ::proto::ImageMessage* mutable_imagemessage();
  void set_allocated_imagemessage(::proto::ImageMessage* imagemessage);
  private:
  const ::proto::ImageMessage& _internal_imagemessage() const;
  ::proto::ImageMessage* _internal_mutable_imagemessage();
  public:
  void unsafe_arena_set_allocated_imagemessage(
      ::proto::ImageMessage* imagemessage);
  ::proto::ImageMessage* unsafe_arena_release_imagemessage();

  // .proto.VideoMessage videoMessage = 4;
  bool has_videomessage() const;
  private:
  bool _internal_has_videomessage() const;
  public:
  void clear_videomessage();
  const ::proto::VideoMessage& videomessage() const;
  PROTOBUF_NODISCARD ::proto::VideoMessage* release_videomessage();
  ::proto::VideoMessage* mutable_videomessage();
  void set_allocated_videomessage(::proto::VideoMessage* videomessage);
  private:
  const ::proto::VideoMessage& _internal_videomessage() const;
  ::proto::VideoMessage* _internal_mutable_videomessage();
  public:
  void unsafe_arena_set_allocated_videomessage(
      ::proto::VideoMessage* videomessage);
  ::proto::VideoMessage* unsafe_arena_release_videomessage();

  // .proto.LocationMessage locationMessage = 5;
  bool has_locationmessage() const;
  private:
  bool _internal_has_locationmessage() const;
  public:
  void clear_locationmessage();
  const ::proto::LocationMessage& locationmessage() const;
  PROTOBUF_NODISCARD ::proto::LocationMessage* release_locationmessage();
  ::proto::LocationMessage* mutable_locationmessage();
  void set_allocated_locationmessage(::proto::LocationMessage* locationmessage);
  private:
  const ::proto::LocationMessage& _internal_locationmessage() const;
  ::proto::LocationMessage* _internal_mutable_locationmessage();
  public:
  void unsafe_arena_set_allocated_locationmessage(
      ::proto::LocationMessage* locationmessage);
  ::proto::LocationMessage* unsafe_arena_release_locationmessage();

  void clear_header();
  HeaderCase header_case() const;
  // @@protoc_insertion_point(class_scope:proto.ButtonsMessage)
 private:
  class _Internal;
  void set_has_text();
  void set_has_documentmessage();
  void set_has_imagemessage();
  void set_has_videomessage();
  void set_has_locationmessage();

  inline bool has_header() const;
  inline void clear_has_header();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Button > buttons_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contenttext_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr footertext_;
    ::proto::ContextInfo* contextinfo_;
    int headertype_;
    union HeaderUnion {
      constexpr HeaderUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
      ::proto::DocumentMessage* documentmessage_;
      ::proto::ImageMessage* imagemessage_;
      ::proto::VideoMessage* videomessage_;
      ::proto::LocationMessage* locationmessage_;
    } header_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class ButtonsResponseMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ButtonsResponseMessage) */ {
 public:
  inline ButtonsResponseMessage() : ButtonsResponseMessage(nullptr) {}
  ~ButtonsResponseMessage() override;
  explicit PROTOBUF_CONSTEXPR ButtonsResponseMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ButtonsResponseMessage(const ButtonsResponseMessage& from);
  ButtonsResponseMessage(ButtonsResponseMessage&& from) noexcept
    : ButtonsResponseMessage() {
    *this = ::std::move(from);
  }

  inline ButtonsResponseMessage& operator=(const ButtonsResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ButtonsResponseMessage& operator=(ButtonsResponseMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ButtonsResponseMessage& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kSelectedDisplayText = 2,
    RESPONSE_NOT_SET = 0,
  };

  static inline const ButtonsResponseMessage* internal_default_instance() {
    return reinterpret_cast<const ButtonsResponseMessage*>(
               &_ButtonsResponseMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(ButtonsResponseMessage& a, ButtonsResponseMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ButtonsResponseMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ButtonsResponseMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ButtonsResponseMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ButtonsResponseMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ButtonsResponseMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ButtonsResponseMessage& from) {
    ButtonsResponseMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ButtonsResponseMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ButtonsResponseMessage";
  }
  protected:
  explicit ButtonsResponseMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ButtonsResponseMessage_ButtonsResponseMessageType ButtonsResponseMessageType;
  static constexpr ButtonsResponseMessageType UNKNOWN =
    ButtonsResponseMessage_ButtonsResponseMessageType_UNKNOWN;
  static constexpr ButtonsResponseMessageType DISPLAY_TEXT =
    ButtonsResponseMessage_ButtonsResponseMessageType_DISPLAY_TEXT;
  static inline bool ButtonsResponseMessageType_IsValid(int value) {
    return ButtonsResponseMessage_ButtonsResponseMessageType_IsValid(value);
  }
  static constexpr ButtonsResponseMessageType ButtonsResponseMessageType_MIN =
    ButtonsResponseMessage_ButtonsResponseMessageType_ButtonsResponseMessageType_MIN;
  static constexpr ButtonsResponseMessageType ButtonsResponseMessageType_MAX =
    ButtonsResponseMessage_ButtonsResponseMessageType_ButtonsResponseMessageType_MAX;
  static constexpr int ButtonsResponseMessageType_ARRAYSIZE =
    ButtonsResponseMessage_ButtonsResponseMessageType_ButtonsResponseMessageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ButtonsResponseMessageType_descriptor() {
    return ButtonsResponseMessage_ButtonsResponseMessageType_descriptor();
  }
  template<typename T>
  static inline const std::string& ButtonsResponseMessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ButtonsResponseMessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ButtonsResponseMessageType_Name.");
    return ButtonsResponseMessage_ButtonsResponseMessageType_Name(enum_t_value);
  }
  static inline bool ButtonsResponseMessageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ButtonsResponseMessageType* value) {
    return ButtonsResponseMessage_ButtonsResponseMessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSelectedButtonIdFieldNumber = 1,
    kContextInfoFieldNumber = 3,
    kTypeFieldNumber = 4,
    kSelectedDisplayTextFieldNumber = 2,
  };
  // optional string selectedButtonId = 1;
  bool has_selectedbuttonid() const;
  private:
  bool _internal_has_selectedbuttonid() const;
  public:
  void clear_selectedbuttonid();
  const std::string& selectedbuttonid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selectedbuttonid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selectedbuttonid();
  PROTOBUF_NODISCARD std::string* release_selectedbuttonid();
  void set_allocated_selectedbuttonid(std::string* selectedbuttonid);
  private:
  const std::string& _internal_selectedbuttonid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selectedbuttonid(const std::string& value);
  std::string* _internal_mutable_selectedbuttonid();
  public:

  // optional .proto.ContextInfo contextInfo = 3;
  bool has_contextinfo() const;
  private:
  bool _internal_has_contextinfo() const;
  public:
  void clear_contextinfo();
  const ::proto::ContextInfo& contextinfo() const;
  PROTOBUF_NODISCARD ::proto::ContextInfo* release_contextinfo();
  ::proto::ContextInfo* mutable_contextinfo();
  void set_allocated_contextinfo(::proto::ContextInfo* contextinfo);
  private:
  const ::proto::ContextInfo& _internal_contextinfo() const;
  ::proto::ContextInfo* _internal_mutable_contextinfo();
  public:
  void unsafe_arena_set_allocated_contextinfo(
      ::proto::ContextInfo* contextinfo);
  ::proto::ContextInfo* unsafe_arena_release_contextinfo();

  // optional .proto.ButtonsResponseMessage.ButtonsResponseMessageType type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::proto::ButtonsResponseMessage_ButtonsResponseMessageType type() const;
  void set_type(::proto::ButtonsResponseMessage_ButtonsResponseMessageType value);
  private:
  ::proto::ButtonsResponseMessage_ButtonsResponseMessageType _internal_type() const;
  void _internal_set_type(::proto::ButtonsResponseMessage_ButtonsResponseMessageType value);
  public:

  // string selectedDisplayText = 2;
  bool has_selecteddisplaytext() const;
  private:
  bool _internal_has_selecteddisplaytext() const;
  public:
  void clear_selecteddisplaytext();
  const std::string& selecteddisplaytext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selecteddisplaytext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selecteddisplaytext();
  PROTOBUF_NODISCARD std::string* release_selecteddisplaytext();
  void set_allocated_selecteddisplaytext(std::string* selecteddisplaytext);
  private:
  const std::string& _internal_selecteddisplaytext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selecteddisplaytext(const std::string& value);
  std::string* _internal_mutable_selecteddisplaytext();
  public:

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:proto.ButtonsResponseMessage)
 private:
  class _Internal;
  void set_has_selecteddisplaytext();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selectedbuttonid_;
    ::proto::ContextInfo* contextinfo_;
    int type_;
    union ResponseUnion {
      constexpr ResponseUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selecteddisplaytext_;
    } response_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationFieldNumber = 1,
    kSenderKeyDistributionMessageFieldNumber = 2,
    kImageMessageFieldNumber = 3,
    kContactMessageFieldNumber = 4,
    kLocationMessageFieldNumber = 5,
    kExtendedTextMessageFieldNumber = 6,
    kDocumentMessageFieldNumber = 7,
    kAudioMessageFieldNumber = 8,
    kVideoMessageFieldNumber = 9,
    kCallFieldNumber = 10,
    kChatFieldNumber = 11,
    kProtocolMessageFieldNumber = 12,
    kContactsArrayMessageFieldNumber = 13,
    kHighlyStructuredMessageFieldNumber = 14,
    kFastRatchetKeySenderKeyDistributionMessageFieldNumber = 15,
    kSendPaymentMessageFieldNumber = 16,
    kLiveLocationMessageFieldNumber = 18,
    kRequestPaymentMessageFieldNumber = 22,
    kDeclinePaymentRequestMessageFieldNumber = 23,
    kCancelPaymentRequestMessageFieldNumber = 24,
    kTemplateMessageFieldNumber = 25,
    kStickerMessageFieldNumber = 26,
    kGroupInviteMessageFieldNumber = 28,
    kTemplateButtonReplyMessageFieldNumber = 29,
    kProductMessageFieldNumber = 30,
    kDeviceSentMessageFieldNumber = 31,
    kMessageContextInfoFieldNumber = 35,
    kListMessageFieldNumber = 36,
    kViewOnceMessageFieldNumber = 37,
    kOrderMessageFieldNumber = 38,
    kListResponseMessageFieldNumber = 39,
    kEphemeralMessageFieldNumber = 40,
    kInvoiceMessageFieldNumber = 41,
    kButtonsMessageFieldNumber = 42,
    kButtonsResponseMessageFieldNumber = 43,
  };
  // optional string conversation = 1;
  bool has_conversation() const;
  private:
  bool _internal_has_conversation() const;
  public:
  void clear_conversation();
  const std::string& conversation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversation();
  PROTOBUF_NODISCARD std::string* release_conversation();
  void set_allocated_conversation(std::string* conversation);
  private:
  const std::string& _internal_conversation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversation(const std::string& value);
  std::string* _internal_mutable_conversation();
  public:

  // optional .proto.SenderKeyDistributionMessage senderKeyDistributionMessage = 2;
  bool has_senderkeydistributionmessage() const;
  private:
  bool _internal_has_senderkeydistributionmessage() const;
  public:
  void clear_senderkeydistributionmessage();
  const ::proto::SenderKeyDistributionMessage& senderkeydistributionmessage() const;
  PROTOBUF_NODISCARD ::proto::SenderKeyDistributionMessage* release_senderkeydistributionmessage();
  ::proto::SenderKeyDistributionMessage* mutable_senderkeydistributionmessage();
  void set_allocated_senderkeydistributionmessage(::proto::SenderKeyDistributionMessage* senderkeydistributionmessage);
  private:
  const ::proto::SenderKeyDistributionMessage& _internal_senderkeydistributionmessage() const;
  ::proto::SenderKeyDistributionMessage* _internal_mutable_senderkeydistributionmessage();
  public:
  void unsafe_arena_set_allocated_senderkeydistributionmessage(
      ::proto::SenderKeyDistributionMessage* senderkeydistributionmessage);
  ::proto::SenderKeyDistributionMessage* unsafe_arena_release_senderkeydistributionmessage();

  // optional .proto.ImageMessage imageMessage = 3;
  bool has_imagemessage() const;
  private:
  bool _internal_has_imagemessage() const;
  public:
  void clear_imagemessage();
  const ::proto::ImageMessage& imagemessage() const;
  PROTOBUF_NODISCARD ::proto::ImageMessage* release_imagemessage();
  ::proto::ImageMessage* mutable_imagemessage();
  void set_allocated_imagemessage(::proto::ImageMessage* imagemessage);
  private:
  const ::proto::ImageMessage& _internal_imagemessage() const;
  ::proto::ImageMessage* _internal_mutable_imagemessage();
  public:
  void unsafe_arena_set_allocated_imagemessage(
      ::proto::ImageMessage* imagemessage);
  ::proto::ImageMessage* unsafe_arena_release_imagemessage();

  // optional .proto.ContactMessage contactMessage = 4;
  bool has_contactmessage() const;
  private:
  bool _internal_has_contactmessage() const;
  public:
  void clear_contactmessage();
  const ::proto::ContactMessage& contactmessage() const;
  PROTOBUF_NODISCARD ::proto::ContactMessage* release_contactmessage();
  ::proto::ContactMessage* mutable_contactmessage();
  void set_allocated_contactmessage(::proto::ContactMessage* contactmessage);
  private:
  const ::proto::ContactMessage& _internal_contactmessage() const;
  ::proto::ContactMessage* _internal_mutable_contactmessage();
  public:
  void unsafe_arena_set_allocated_contactmessage(
      ::proto::ContactMessage* contactmessage);
  ::proto::ContactMessage* unsafe_arena_release_contactmessage();

  // optional .proto.LocationMessage locationMessage = 5;
  bool has_locationmessage() const;
  private:
  bool _internal_has_locationmessage() const;
  public:
  void clear_locationmessage();
  const ::proto::LocationMessage& locationmessage() const;
  PROTOBUF_NODISCARD ::proto::LocationMessage* release_locationmessage();
  ::proto::LocationMessage* mutable_locationmessage();
  void set_allocated_locationmessage(::proto::LocationMessage* locationmessage);
  private:
  const ::proto::LocationMessage& _internal_locationmessage() const;
  ::proto::LocationMessage* _internal_mutable_locationmessage();
  public:
  void unsafe_arena_set_allocated_locationmessage(
      ::proto::LocationMessage* locationmessage);
  ::proto::LocationMessage* unsafe_arena_release_locationmessage();

  // optional .proto.ExtendedTextMessage extendedTextMessage = 6;
  bool has_extendedtextmessage() const;
  private:
  bool _internal_has_extendedtextmessage() const;
  public:
  void clear_extendedtextmessage();
  const ::proto::ExtendedTextMessage& extendedtextmessage() const;
  PROTOBUF_NODISCARD ::proto::ExtendedTextMessage* release_extendedtextmessage();
  ::proto::ExtendedTextMessage* mutable_extendedtextmessage();
  void set_allocated_extendedtextmessage(::proto::ExtendedTextMessage* extendedtextmessage);
  private:
  const ::proto::ExtendedTextMessage& _internal_extendedtextmessage() const;
  ::proto::ExtendedTextMessage* _internal_mutable_extendedtextmessage();
  public:
  void unsafe_arena_set_allocated_extendedtextmessage(
      ::proto::ExtendedTextMessage* extendedtextmessage);
  ::proto::ExtendedTextMessage* unsafe_arena_release_extendedtextmessage();

  // optional .proto.DocumentMessage documentMessage = 7;
  bool has_documentmessage() const;
  private:
  bool _internal_has_documentmessage() const;
  public:
  void clear_documentmessage();
  const ::proto::DocumentMessage& documentmessage() const;
  PROTOBUF_NODISCARD ::proto::DocumentMessage* release_documentmessage();
  ::proto::DocumentMessage* mutable_documentmessage();
  void set_allocated_documentmessage(::proto::DocumentMessage* documentmessage);
  private:
  const ::proto::DocumentMessage& _internal_documentmessage() const;
  ::proto::DocumentMessage* _internal_mutable_documentmessage();
  public:
  void unsafe_arena_set_allocated_documentmessage(
      ::proto::DocumentMessage* documentmessage);
  ::proto::DocumentMessage* unsafe_arena_release_documentmessage();

  // optional .proto.AudioMessage audioMessage = 8;
  bool has_audiomessage() const;
  private:
  bool _internal_has_audiomessage() const;
  public:
  void clear_audiomessage();
  const ::proto::AudioMessage& audiomessage() const;
  PROTOBUF_NODISCARD ::proto::AudioMessage* release_audiomessage();
  ::proto::AudioMessage* mutable_audiomessage();
  void set_allocated_audiomessage(::proto::AudioMessage* audiomessage);
  private:
  const ::proto::AudioMessage& _internal_audiomessage() const;
  ::proto::AudioMessage* _internal_mutable_audiomessage();
  public:
  void unsafe_arena_set_allocated_audiomessage(
      ::proto::AudioMessage* audiomessage);
  ::proto::AudioMessage* unsafe_arena_release_audiomessage();

  // optional .proto.VideoMessage videoMessage = 9;
  bool has_videomessage() const;
  private:
  bool _internal_has_videomessage() const;
  public:
  void clear_videomessage();
  const ::proto::VideoMessage& videomessage() const;
  PROTOBUF_NODISCARD ::proto::VideoMessage* release_videomessage();
  ::proto::VideoMessage* mutable_videomessage();
  void set_allocated_videomessage(::proto::VideoMessage* videomessage);
  private:
  const ::proto::VideoMessage& _internal_videomessage() const;
  ::proto::VideoMessage* _internal_mutable_videomessage();
  public:
  void unsafe_arena_set_allocated_videomessage(
      ::proto::VideoMessage* videomessage);
  ::proto::VideoMessage* unsafe_arena_release_videomessage();

  // optional .proto.Call call = 10;
  bool has_call() const;
  private:
  bool _internal_has_call() const;
  public:
  void clear_call();
  const ::proto::Call& call() const;
  PROTOBUF_NODISCARD ::proto::Call* release_call();
  ::proto::Call* mutable_call();
  void set_allocated_call(::proto::Call* call);
  private:
  const ::proto::Call& _internal_call() const;
  ::proto::Call* _internal_mutable_call();
  public:
  void unsafe_arena_set_allocated_call(
      ::proto::Call* call);
  ::proto::Call* unsafe_arena_release_call();

  // optional .proto.Chat chat = 11;
  bool has_chat() const;
  private:
  bool _internal_has_chat() const;
  public:
  void clear_chat();
  const ::proto::Chat& chat() const;
  PROTOBUF_NODISCARD ::proto::Chat* release_chat();
  ::proto::Chat* mutable_chat();
  void set_allocated_chat(::proto::Chat* chat);
  private:
  const ::proto::Chat& _internal_chat() const;
  ::proto::Chat* _internal_mutable_chat();
  public:
  void unsafe_arena_set_allocated_chat(
      ::proto::Chat* chat);
  ::proto::Chat* unsafe_arena_release_chat();

  // optional .proto.ProtocolMessage protocolMessage = 12;
  bool has_protocolmessage() const;
  private:
  bool _internal_has_protocolmessage() const;
  public:
  void clear_protocolmessage();
  const ::proto::ProtocolMessage& protocolmessage() const;
  PROTOBUF_NODISCARD ::proto::ProtocolMessage* release_protocolmessage();
  ::proto::ProtocolMessage* mutable_protocolmessage();
  void set_allocated_protocolmessage(::proto::ProtocolMessage* protocolmessage);
  private:
  const ::proto::ProtocolMessage& _internal_protocolmessage() const;
  ::proto::ProtocolMessage* _internal_mutable_protocolmessage();
  public:
  void unsafe_arena_set_allocated_protocolmessage(
      ::proto::ProtocolMessage* protocolmessage);
  ::proto::ProtocolMessage* unsafe_arena_release_protocolmessage();

  // optional .proto.ContactsArrayMessage contactsArrayMessage = 13;
  bool has_contactsarraymessage() const;
  private:
  bool _internal_has_contactsarraymessage() const;
  public:
  void clear_contactsarraymessage();
  const ::proto::ContactsArrayMessage& contactsarraymessage() const;
  PROTOBUF_NODISCARD ::proto::ContactsArrayMessage* release_contactsarraymessage();
  ::proto::ContactsArrayMessage* mutable_contactsarraymessage();
  void set_allocated_contactsarraymessage(::proto::ContactsArrayMessage* contactsarraymessage);
  private:
  const ::proto::ContactsArrayMessage& _internal_contactsarraymessage() const;
  ::proto::ContactsArrayMessage* _internal_mutable_contactsarraymessage();
  public:
  void unsafe_arena_set_allocated_contactsarraymessage(
      ::proto::ContactsArrayMessage* contactsarraymessage);
  ::proto::ContactsArrayMessage* unsafe_arena_release_contactsarraymessage();

  // optional .proto.HighlyStructuredMessage highlyStructuredMessage = 14;
  bool has_highlystructuredmessage() const;
  private:
  bool _internal_has_highlystructuredmessage() const;
  public:
  void clear_highlystructuredmessage();
  const ::proto::HighlyStructuredMessage& highlystructuredmessage() const;
  PROTOBUF_NODISCARD ::proto::HighlyStructuredMessage* release_highlystructuredmessage();
  ::proto::HighlyStructuredMessage* mutable_highlystructuredmessage();
  void set_allocated_highlystructuredmessage(::proto::HighlyStructuredMessage* highlystructuredmessage);
  private:
  const ::proto::HighlyStructuredMessage& _internal_highlystructuredmessage() const;
  ::proto::HighlyStructuredMessage* _internal_mutable_highlystructuredmessage();
  public:
  void unsafe_arena_set_allocated_highlystructuredmessage(
      ::proto::HighlyStructuredMessage* highlystructuredmessage);
  ::proto::HighlyStructuredMessage* unsafe_arena_release_highlystructuredmessage();

  // optional .proto.SenderKeyDistributionMessage fastRatchetKeySenderKeyDistributionMessage = 15;
  bool has_fastratchetkeysenderkeydistributionmessage() const;
  private:
  bool _internal_has_fastratchetkeysenderkeydistributionmessage() const;
  public:
  void clear_fastratchetkeysenderkeydistributionmessage();
  const ::proto::SenderKeyDistributionMessage& fastratchetkeysenderkeydistributionmessage() const;
  PROTOBUF_NODISCARD ::proto::SenderKeyDistributionMessage* release_fastratchetkeysenderkeydistributionmessage();
  ::proto::SenderKeyDistributionMessage* mutable_fastratchetkeysenderkeydistributionmessage();
  void set_allocated_fastratchetkeysenderkeydistributionmessage(::proto::SenderKeyDistributionMessage* fastratchetkeysenderkeydistributionmessage);
  private:
  const ::proto::SenderKeyDistributionMessage& _internal_fastratchetkeysenderkeydistributionmessage() const;
  ::proto::SenderKeyDistributionMessage* _internal_mutable_fastratchetkeysenderkeydistributionmessage();
  public:
  void unsafe_arena_set_allocated_fastratchetkeysenderkeydistributionmessage(
      ::proto::SenderKeyDistributionMessage* fastratchetkeysenderkeydistributionmessage);
  ::proto::SenderKeyDistributionMessage* unsafe_arena_release_fastratchetkeysenderkeydistributionmessage();

  // optional .proto.SendPaymentMessage sendPaymentMessage = 16;
  bool has_sendpaymentmessage() const;
  private:
  bool _internal_has_sendpaymentmessage() const;
  public:
  void clear_sendpaymentmessage();
  const ::proto::SendPaymentMessage& sendpaymentmessage() const;
  PROTOBUF_NODISCARD ::proto::SendPaymentMessage* release_sendpaymentmessage();
  ::proto::SendPaymentMessage* mutable_sendpaymentmessage();
  void set_allocated_sendpaymentmessage(::proto::SendPaymentMessage* sendpaymentmessage);
  private:
  const ::proto::SendPaymentMessage& _internal_sendpaymentmessage() const;
  ::proto::SendPaymentMessage* _internal_mutable_sendpaymentmessage();
  public:
  void unsafe_arena_set_allocated_sendpaymentmessage(
      ::proto::SendPaymentMessage* sendpaymentmessage);
  ::proto::SendPaymentMessage* unsafe_arena_release_sendpaymentmessage();

  // optional .proto.LiveLocationMessage liveLocationMessage = 18;
  bool has_livelocationmessage() const;
  private:
  bool _internal_has_livelocationmessage() const;
  public:
  void clear_livelocationmessage();
  const ::proto::LiveLocationMessage& livelocationmessage() const;
  PROTOBUF_NODISCARD ::proto::LiveLocationMessage* release_livelocationmessage();
  ::proto::LiveLocationMessage* mutable_livelocationmessage();
  void set_allocated_livelocationmessage(::proto::LiveLocationMessage* livelocationmessage);
  private:
  const ::proto::LiveLocationMessage& _internal_livelocationmessage() const;
  ::proto::LiveLocationMessage* _internal_mutable_livelocationmessage();
  public:
  void unsafe_arena_set_allocated_livelocationmessage(
      ::proto::LiveLocationMessage* livelocationmessage);
  ::proto::LiveLocationMessage* unsafe_arena_release_livelocationmessage();

  // optional .proto.RequestPaymentMessage requestPaymentMessage = 22;
  bool has_requestpaymentmessage() const;
  private:
  bool _internal_has_requestpaymentmessage() const;
  public:
  void clear_requestpaymentmessage();
  const ::proto::RequestPaymentMessage& requestpaymentmessage() const;
  PROTOBUF_NODISCARD ::proto::RequestPaymentMessage* release_requestpaymentmessage();
  ::proto::RequestPaymentMessage* mutable_requestpaymentmessage();
  void set_allocated_requestpaymentmessage(::proto::RequestPaymentMessage* requestpaymentmessage);
  private:
  const ::proto::RequestPaymentMessage& _internal_requestpaymentmessage() const;
  ::proto::RequestPaymentMessage* _internal_mutable_requestpaymentmessage();
  public:
  void unsafe_arena_set_allocated_requestpaymentmessage(
      ::proto::RequestPaymentMessage* requestpaymentmessage);
  ::proto::RequestPaymentMessage* unsafe_arena_release_requestpaymentmessage();

  // optional .proto.DeclinePaymentRequestMessage declinePaymentRequestMessage = 23;
  bool has_declinepaymentrequestmessage() const;
  private:
  bool _internal_has_declinepaymentrequestmessage() const;
  public:
  void clear_declinepaymentrequestmessage();
  const ::proto::DeclinePaymentRequestMessage& declinepaymentrequestmessage() const;
  PROTOBUF_NODISCARD ::proto::DeclinePaymentRequestMessage* release_declinepaymentrequestmessage();
  ::proto::DeclinePaymentRequestMessage* mutable_declinepaymentrequestmessage();
  void set_allocated_declinepaymentrequestmessage(::proto::DeclinePaymentRequestMessage* declinepaymentrequestmessage);
  private:
  const ::proto::DeclinePaymentRequestMessage& _internal_declinepaymentrequestmessage() const;
  ::proto::DeclinePaymentRequestMessage* _internal_mutable_declinepaymentrequestmessage();
  public:
  void unsafe_arena_set_allocated_declinepaymentrequestmessage(
      ::proto::DeclinePaymentRequestMessage* declinepaymentrequestmessage);
  ::proto::DeclinePaymentRequestMessage* unsafe_arena_release_declinepaymentrequestmessage();

  // optional .proto.CancelPaymentRequestMessage cancelPaymentRequestMessage = 24;
  bool has_cancelpaymentrequestmessage() const;
  private:
  bool _internal_has_cancelpaymentrequestmessage() const;
  public:
  void clear_cancelpaymentrequestmessage();
  const ::proto::CancelPaymentRequestMessage& cancelpaymentrequestmessage() const;
  PROTOBUF_NODISCARD ::proto::CancelPaymentRequestMessage* release_cancelpaymentrequestmessage();
  ::proto::CancelPaymentRequestMessage* mutable_cancelpaymentrequestmessage();
  void set_allocated_cancelpaymentrequestmessage(::proto::CancelPaymentRequestMessage* cancelpaymentrequestmessage);
  private:
  const ::proto::CancelPaymentRequestMessage& _internal_cancelpaymentrequestmessage() const;
  ::proto::CancelPaymentRequestMessage* _internal_mutable_cancelpaymentrequestmessage();
  public:
  void unsafe_arena_set_allocated_cancelpaymentrequestmessage(
      ::proto::CancelPaymentRequestMessage* cancelpaymentrequestmessage);
  ::proto::CancelPaymentRequestMessage* unsafe_arena_release_cancelpaymentrequestmessage();

  // optional .proto.TemplateMessage templateMessage = 25;
  bool has_templatemessage() const;
  private:
  bool _internal_has_templatemessage() const;
  public:
  void clear_templatemessage();
  const ::proto::TemplateMessage& templatemessage() const;
  PROTOBUF_NODISCARD ::proto::TemplateMessage* release_templatemessage();
  ::proto::TemplateMessage* mutable_templatemessage();
  void set_allocated_templatemessage(::proto::TemplateMessage* templatemessage);
  private:
  const ::proto::TemplateMessage& _internal_templatemessage() const;
  ::proto::TemplateMessage* _internal_mutable_templatemessage();
  public:
  void unsafe_arena_set_allocated_templatemessage(
      ::proto::TemplateMessage* templatemessage);
  ::proto::TemplateMessage* unsafe_arena_release_templatemessage();

  // optional .proto.StickerMessage stickerMessage = 26;
  bool has_stickermessage() const;
  private:
  bool _internal_has_stickermessage() const;
  public:
  void clear_stickermessage();
  const ::proto::StickerMessage& stickermessage() const;
  PROTOBUF_NODISCARD ::proto::StickerMessage* release_stickermessage();
  ::proto::StickerMessage* mutable_stickermessage();
  void set_allocated_stickermessage(::proto::StickerMessage* stickermessage);
  private:
  const ::proto::StickerMessage& _internal_stickermessage() const;
  ::proto::StickerMessage* _internal_mutable_stickermessage();
  public:
  void unsafe_arena_set_allocated_stickermessage(
      ::proto::StickerMessage* stickermessage);
  ::proto::StickerMessage* unsafe_arena_release_stickermessage();

  // optional .proto.GroupInviteMessage groupInviteMessage = 28;
  bool has_groupinvitemessage() const;
  private:
  bool _internal_has_groupinvitemessage() const;
  public:
  void clear_groupinvitemessage();
  const ::proto::GroupInviteMessage& groupinvitemessage() const;
  PROTOBUF_NODISCARD ::proto::GroupInviteMessage* release_groupinvitemessage();
  ::proto::GroupInviteMessage* mutable_groupinvitemessage();
  void set_allocated_groupinvitemessage(::proto::GroupInviteMessage* groupinvitemessage);
  private:
  const ::proto::GroupInviteMessage& _internal_groupinvitemessage() const;
  ::proto::GroupInviteMessage* _internal_mutable_groupinvitemessage();
  public:
  void unsafe_arena_set_allocated_groupinvitemessage(
      ::proto::GroupInviteMessage* groupinvitemessage);
  ::proto::GroupInviteMessage* unsafe_arena_release_groupinvitemessage();

  // optional .proto.TemplateButtonReplyMessage templateButtonReplyMessage = 29;
  bool has_templatebuttonreplymessage() const;
  private:
  bool _internal_has_templatebuttonreplymessage() const;
  public:
  void clear_templatebuttonreplymessage();
  const ::proto::TemplateButtonReplyMessage& templatebuttonreplymessage() const;
  PROTOBUF_NODISCARD ::proto::TemplateButtonReplyMessage* release_templatebuttonreplymessage();
  ::proto::TemplateButtonReplyMessage* mutable_templatebuttonreplymessage();
  void set_allocated_templatebuttonreplymessage(::proto::TemplateButtonReplyMessage* templatebuttonreplymessage);
  private:
  const ::proto::TemplateButtonReplyMessage& _internal_templatebuttonreplymessage() const;
  ::proto::TemplateButtonReplyMessage* _internal_mutable_templatebuttonreplymessage();
  public:
  void unsafe_arena_set_allocated_templatebuttonreplymessage(
      ::proto::TemplateButtonReplyMessage* templatebuttonreplymessage);
  ::proto::TemplateButtonReplyMessage* unsafe_arena_release_templatebuttonreplymessage();

  // optional .proto.ProductMessage productMessage = 30;
  bool has_productmessage() const;
  private:
  bool _internal_has_productmessage() const;
  public:
  void clear_productmessage();
  const ::proto::ProductMessage& productmessage() const;
  PROTOBUF_NODISCARD ::proto::ProductMessage* release_productmessage();
  ::proto::ProductMessage* mutable_productmessage();
  void set_allocated_productmessage(::proto::ProductMessage* productmessage);
  private:
  const ::proto::ProductMessage& _internal_productmessage() const;
  ::proto::ProductMessage* _internal_mutable_productmessage();
  public:
  void unsafe_arena_set_allocated_productmessage(
      ::proto::ProductMessage* productmessage);
  ::proto::ProductMessage* unsafe_arena_release_productmessage();

  // optional .proto.DeviceSentMessage deviceSentMessage = 31;
  bool has_devicesentmessage() const;
  private:
  bool _internal_has_devicesentmessage() const;
  public:
  void clear_devicesentmessage();
  const ::proto::DeviceSentMessage& devicesentmessage() const;
  PROTOBUF_NODISCARD ::proto::DeviceSentMessage* release_devicesentmessage();
  ::proto::DeviceSentMessage* mutable_devicesentmessage();
  void set_allocated_devicesentmessage(::proto::DeviceSentMessage* devicesentmessage);
  private:
  const ::proto::DeviceSentMessage& _internal_devicesentmessage() const;
  ::proto::DeviceSentMessage* _internal_mutable_devicesentmessage();
  public:
  void unsafe_arena_set_allocated_devicesentmessage(
      ::proto::DeviceSentMessage* devicesentmessage);
  ::proto::DeviceSentMessage* unsafe_arena_release_devicesentmessage();

  // optional .proto.MessageContextInfo messageContextInfo = 35;
  bool has_messagecontextinfo() const;
  private:
  bool _internal_has_messagecontextinfo() const;
  public:
  void clear_messagecontextinfo();
  const ::proto::MessageContextInfo& messagecontextinfo() const;
  PROTOBUF_NODISCARD ::proto::MessageContextInfo* release_messagecontextinfo();
  ::proto::MessageContextInfo* mutable_messagecontextinfo();
  void set_allocated_messagecontextinfo(::proto::MessageContextInfo* messagecontextinfo);
  private:
  const ::proto::MessageContextInfo& _internal_messagecontextinfo() const;
  ::proto::MessageContextInfo* _internal_mutable_messagecontextinfo();
  public:
  void unsafe_arena_set_allocated_messagecontextinfo(
      ::proto::MessageContextInfo* messagecontextinfo);
  ::proto::MessageContextInfo* unsafe_arena_release_messagecontextinfo();

  // optional .proto.ListMessage listMessage = 36;
  bool has_listmessage() const;
  private:
  bool _internal_has_listmessage() const;
  public:
  void clear_listmessage();
  const ::proto::ListMessage& listmessage() const;
  PROTOBUF_NODISCARD ::proto::ListMessage* release_listmessage();
  ::proto::ListMessage* mutable_listmessage();
  void set_allocated_listmessage(::proto::ListMessage* listmessage);
  private:
  const ::proto::ListMessage& _internal_listmessage() const;
  ::proto::ListMessage* _internal_mutable_listmessage();
  public:
  void unsafe_arena_set_allocated_listmessage(
      ::proto::ListMessage* listmessage);
  ::proto::ListMessage* unsafe_arena_release_listmessage();

  // optional .proto.FutureProofMessage viewOnceMessage = 37;
  bool has_viewoncemessage() const;
  private:
  bool _internal_has_viewoncemessage() const;
  public:
  void clear_viewoncemessage();
  const ::proto::FutureProofMessage& viewoncemessage() const;
  PROTOBUF_NODISCARD ::proto::FutureProofMessage* release_viewoncemessage();
  ::proto::FutureProofMessage* mutable_viewoncemessage();
  void set_allocated_viewoncemessage(::proto::FutureProofMessage* viewoncemessage);
  private:
  const ::proto::FutureProofMessage& _internal_viewoncemessage() const;
  ::proto::FutureProofMessage* _internal_mutable_viewoncemessage();
  public:
  void unsafe_arena_set_allocated_viewoncemessage(
      ::proto::FutureProofMessage* viewoncemessage);
  ::proto::FutureProofMessage* unsafe_arena_release_viewoncemessage();

  // optional .proto.OrderMessage orderMessage = 38;
  bool has_ordermessage() const;
  private:
  bool _internal_has_ordermessage() const;
  public:
  void clear_ordermessage();
  const ::proto::OrderMessage& ordermessage() const;
  PROTOBUF_NODISCARD ::proto::OrderMessage* release_ordermessage();
  ::proto::OrderMessage* mutable_ordermessage();
  void set_allocated_ordermessage(::proto::OrderMessage* ordermessage);
  private:
  const ::proto::OrderMessage& _internal_ordermessage() const;
  ::proto::OrderMessage* _internal_mutable_ordermessage();
  public:
  void unsafe_arena_set_allocated_ordermessage(
      ::proto::OrderMessage* ordermessage);
  ::proto::OrderMessage* unsafe_arena_release_ordermessage();

  // optional .proto.ListResponseMessage listResponseMessage = 39;
  bool has_listresponsemessage() const;
  private:
  bool _internal_has_listresponsemessage() const;
  public:
  void clear_listresponsemessage();
  const ::proto::ListResponseMessage& listresponsemessage() const;
  PROTOBUF_NODISCARD ::proto::ListResponseMessage* release_listresponsemessage();
  ::proto::ListResponseMessage* mutable_listresponsemessage();
  void set_allocated_listresponsemessage(::proto::ListResponseMessage* listresponsemessage);
  private:
  const ::proto::ListResponseMessage& _internal_listresponsemessage() const;
  ::proto::ListResponseMessage* _internal_mutable_listresponsemessage();
  public:
  void unsafe_arena_set_allocated_listresponsemessage(
      ::proto::ListResponseMessage* listresponsemessage);
  ::proto::ListResponseMessage* unsafe_arena_release_listresponsemessage();

  // optional .proto.FutureProofMessage ephemeralMessage = 40;
  bool has_ephemeralmessage() const;
  private:
  bool _internal_has_ephemeralmessage() const;
  public:
  void clear_ephemeralmessage();
  const ::proto::FutureProofMessage& ephemeralmessage() const;
  PROTOBUF_NODISCARD ::proto::FutureProofMessage* release_ephemeralmessage();
  ::proto::FutureProofMessage* mutable_ephemeralmessage();
  void set_allocated_ephemeralmessage(::proto::FutureProofMessage* ephemeralmessage);
  private:
  const ::proto::FutureProofMessage& _internal_ephemeralmessage() const;
  ::proto::FutureProofMessage* _internal_mutable_ephemeralmessage();
  public:
  void unsafe_arena_set_allocated_ephemeralmessage(
      ::proto::FutureProofMessage* ephemeralmessage);
  ::proto::FutureProofMessage* unsafe_arena_release_ephemeralmessage();

  // optional .proto.InvoiceMessage invoiceMessage = 41;
  bool has_invoicemessage() const;
  private:
  bool _internal_has_invoicemessage() const;
  public:
  void clear_invoicemessage();
  const ::proto::InvoiceMessage& invoicemessage() const;
  PROTOBUF_NODISCARD ::proto::InvoiceMessage* release_invoicemessage();
  ::proto::InvoiceMessage* mutable_invoicemessage();
  void set_allocated_invoicemessage(::proto::InvoiceMessage* invoicemessage);
  private:
  const ::proto::InvoiceMessage& _internal_invoicemessage() const;
  ::proto::InvoiceMessage* _internal_mutable_invoicemessage();
  public:
  void unsafe_arena_set_allocated_invoicemessage(
      ::proto::InvoiceMessage* invoicemessage);
  ::proto::InvoiceMessage* unsafe_arena_release_invoicemessage();

  // optional .proto.ButtonsMessage buttonsMessage = 42;
  bool has_buttonsmessage() const;
  private:
  bool _internal_has_buttonsmessage() const;
  public:
  void clear_buttonsmessage();
  const ::proto::ButtonsMessage& buttonsmessage() const;
  PROTOBUF_NODISCARD ::proto::ButtonsMessage* release_buttonsmessage();
  ::proto::ButtonsMessage* mutable_buttonsmessage();
  void set_allocated_buttonsmessage(::proto::ButtonsMessage* buttonsmessage);
  private:
  const ::proto::ButtonsMessage& _internal_buttonsmessage() const;
  ::proto::ButtonsMessage* _internal_mutable_buttonsmessage();
  public:
  void unsafe_arena_set_allocated_buttonsmessage(
      ::proto::ButtonsMessage* buttonsmessage);
  ::proto::ButtonsMessage* unsafe_arena_release_buttonsmessage();

  // optional .proto.ButtonsResponseMessage buttonsResponseMessage = 43;
  bool has_buttonsresponsemessage() const;
  private:
  bool _internal_has_buttonsresponsemessage() const;
  public:
  void clear_buttonsresponsemessage();
  const ::proto::ButtonsResponseMessage& buttonsresponsemessage() const;
  PROTOBUF_NODISCARD ::proto::ButtonsResponseMessage* release_buttonsresponsemessage();
  ::proto::ButtonsResponseMessage* mutable_buttonsresponsemessage();
  void set_allocated_buttonsresponsemessage(::proto::ButtonsResponseMessage* buttonsresponsemessage);
  private:
  const ::proto::ButtonsResponseMessage& _internal_buttonsresponsemessage() const;
  ::proto::ButtonsResponseMessage* _internal_mutable_buttonsresponsemessage();
  public:
  void unsafe_arena_set_allocated_buttonsresponsemessage(
      ::proto::ButtonsResponseMessage* buttonsresponsemessage);
  ::proto::ButtonsResponseMessage* unsafe_arena_release_buttonsresponsemessage();

  // @@protoc_insertion_point(class_scope:proto.Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversation_;
    ::proto::SenderKeyDistributionMessage* senderkeydistributionmessage_;
    ::proto::ImageMessage* imagemessage_;
    ::proto::ContactMessage* contactmessage_;
    ::proto::LocationMessage* locationmessage_;
    ::proto::ExtendedTextMessage* extendedtextmessage_;
    ::proto::DocumentMessage* documentmessage_;
    ::proto::AudioMessage* audiomessage_;
    ::proto::VideoMessage* videomessage_;
    ::proto::Call* call_;
    ::proto::Chat* chat_;
    ::proto::ProtocolMessage* protocolmessage_;
    ::proto::ContactsArrayMessage* contactsarraymessage_;
    ::proto::HighlyStructuredMessage* highlystructuredmessage_;
    ::proto::SenderKeyDistributionMessage* fastratchetkeysenderkeydistributionmessage_;
    ::proto::SendPaymentMessage* sendpaymentmessage_;
    ::proto::LiveLocationMessage* livelocationmessage_;
    ::proto::RequestPaymentMessage* requestpaymentmessage_;
    ::proto::DeclinePaymentRequestMessage* declinepaymentrequestmessage_;
    ::proto::CancelPaymentRequestMessage* cancelpaymentrequestmessage_;
    ::proto::TemplateMessage* templatemessage_;
    ::proto::StickerMessage* stickermessage_;
    ::proto::GroupInviteMessage* groupinvitemessage_;
    ::proto::TemplateButtonReplyMessage* templatebuttonreplymessage_;
    ::proto::ProductMessage* productmessage_;
    ::proto::DeviceSentMessage* devicesentmessage_;
    ::proto::MessageContextInfo* messagecontextinfo_;
    ::proto::ListMessage* listmessage_;
    ::proto::FutureProofMessage* viewoncemessage_;
    ::proto::OrderMessage* ordermessage_;
    ::proto::ListResponseMessage* listresponsemessage_;
    ::proto::FutureProofMessage* ephemeralmessage_;
    ::proto::InvoiceMessage* invoicemessage_;
    ::proto::ButtonsMessage* buttonsmessage_;
    ::proto::ButtonsResponseMessage* buttonsresponsemessage_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class MessageKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.MessageKey) */ {
 public:
  inline MessageKey() : MessageKey(nullptr) {}
  ~MessageKey() override;
  explicit PROTOBUF_CONSTEXPR MessageKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageKey(const MessageKey& from);
  MessageKey(MessageKey&& from) noexcept
    : MessageKey() {
    *this = ::std::move(from);
  }

  inline MessageKey& operator=(const MessageKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageKey& operator=(MessageKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageKey* internal_default_instance() {
    return reinterpret_cast<const MessageKey*>(
               &_MessageKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(MessageKey& a, MessageKey& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageKey& from) {
    MessageKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.MessageKey";
  }
  protected:
  explicit MessageKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteJidFieldNumber = 1,
    kIdFieldNumber = 3,
    kParticipantFieldNumber = 4,
    kFromMeFieldNumber = 2,
  };
  // optional string remoteJid = 1;
  bool has_remotejid() const;
  private:
  bool _internal_has_remotejid() const;
  public:
  void clear_remotejid();
  const std::string& remotejid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remotejid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remotejid();
  PROTOBUF_NODISCARD std::string* release_remotejid();
  void set_allocated_remotejid(std::string* remotejid);
  private:
  const std::string& _internal_remotejid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remotejid(const std::string& value);
  std::string* _internal_mutable_remotejid();
  public:

  // optional string id = 3;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string participant = 4;
  bool has_participant() const;
  private:
  bool _internal_has_participant() const;
  public:
  void clear_participant();
  const std::string& participant() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant();
  PROTOBUF_NODISCARD std::string* release_participant();
  void set_allocated_participant(std::string* participant);
  private:
  const std::string& _internal_participant() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant(const std::string& value);
  std::string* _internal_mutable_participant();
  public:

  // optional bool fromMe = 2;
  bool has_fromme() const;
  private:
  bool _internal_has_fromme() const;
  public:
  void clear_fromme();
  bool fromme() const;
  void set_fromme(bool value);
  private:
  bool _internal_fromme() const;
  void _internal_set_fromme(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.MessageKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remotejid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_;
    bool fromme_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class WebFeatures final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.WebFeatures) */ {
 public:
  inline WebFeatures() : WebFeatures(nullptr) {}
  ~WebFeatures() override;
  explicit PROTOBUF_CONSTEXPR WebFeatures(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WebFeatures(const WebFeatures& from);
  WebFeatures(WebFeatures&& from) noexcept
    : WebFeatures() {
    *this = ::std::move(from);
  }

  inline WebFeatures& operator=(const WebFeatures& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebFeatures& operator=(WebFeatures&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WebFeatures& default_instance() {
    return *internal_default_instance();
  }
  static inline const WebFeatures* internal_default_instance() {
    return reinterpret_cast<const WebFeatures*>(
               &_WebFeatures_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(WebFeatures& a, WebFeatures& b) {
    a.Swap(&b);
  }
  inline void Swap(WebFeatures* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebFeatures* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WebFeatures* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WebFeatures>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WebFeatures& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WebFeatures& from) {
    WebFeatures::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WebFeatures* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.WebFeatures";
  }
  protected:
  explicit WebFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WebFeatures_WebFeaturesFlag WebFeaturesFlag;
  static constexpr WebFeaturesFlag NOT_STARTED =
    WebFeatures_WebFeaturesFlag_NOT_STARTED;
  static constexpr WebFeaturesFlag FORCE_UPGRADE =
    WebFeatures_WebFeaturesFlag_FORCE_UPGRADE;
  static constexpr WebFeaturesFlag DEVELOPMENT =
    WebFeatures_WebFeaturesFlag_DEVELOPMENT;
  static constexpr WebFeaturesFlag PRODUCTION =
    WebFeatures_WebFeaturesFlag_PRODUCTION;
  static inline bool WebFeaturesFlag_IsValid(int value) {
    return WebFeatures_WebFeaturesFlag_IsValid(value);
  }
  static constexpr WebFeaturesFlag WebFeaturesFlag_MIN =
    WebFeatures_WebFeaturesFlag_WebFeaturesFlag_MIN;
  static constexpr WebFeaturesFlag WebFeaturesFlag_MAX =
    WebFeatures_WebFeaturesFlag_WebFeaturesFlag_MAX;
  static constexpr int WebFeaturesFlag_ARRAYSIZE =
    WebFeatures_WebFeaturesFlag_WebFeaturesFlag_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  WebFeaturesFlag_descriptor() {
    return WebFeatures_WebFeaturesFlag_descriptor();
  }
  template<typename T>
  static inline const std::string& WebFeaturesFlag_Name(T enum_t_value) {
    static_assert(::std::is_same<T, WebFeaturesFlag>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function WebFeaturesFlag_Name.");
    return WebFeatures_WebFeaturesFlag_Name(enum_t_value);
  }
  static inline bool WebFeaturesFlag_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      WebFeaturesFlag* value) {
    return WebFeatures_WebFeaturesFlag_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLabelsDisplayFieldNumber = 1,
    kVoipIndividualOutgoingFieldNumber = 2,
    kGroupsV3FieldNumber = 3,
    kGroupsV3CreateFieldNumber = 4,
    kChangeNumberV2FieldNumber = 5,
    kQueryStatusV3ThumbnailFieldNumber = 6,
    kLiveLocationsFieldNumber = 7,
    kQueryVnameFieldNumber = 8,
    kVoipIndividualIncomingFieldNumber = 9,
    kQuickRepliesQueryFieldNumber = 10,
    kPaymentsFieldNumber = 11,
    kStickerPackQueryFieldNumber = 12,
    kLiveLocationsFinalFieldNumber = 13,
    kLabelsEditFieldNumber = 14,
    kMediaUploadFieldNumber = 15,
    kMediaUploadRichQuickRepliesFieldNumber = 18,
    kVnameV2FieldNumber = 19,
    kVideoPlaybackUrlFieldNumber = 20,
    kStatusRankingFieldNumber = 21,
    kVoipIndividualVideoFieldNumber = 22,
    kThirdPartyStickersFieldNumber = 23,
    kFrequentlyForwardedSettingFieldNumber = 24,
    kGroupsV4JoinPermissionFieldNumber = 25,
    kRecentStickersFieldNumber = 26,
    kCatalogFieldNumber = 27,
    kStarredStickersFieldNumber = 28,
    kVoipGroupCallFieldNumber = 29,
    kTemplateMessageFieldNumber = 30,
    kTemplateMessageInteractivityFieldNumber = 31,
    kEphemeralMessagesFieldNumber = 32,
    kE2ENotificationSyncFieldNumber = 33,
    kRecentStickersV2FieldNumber = 34,
    kSyncdRelease1FieldNumber = 35,
    kRecentStickersV3FieldNumber = 36,
    kUserNoticeFieldNumber = 37,
    kSyncdRelease11FieldNumber = 38,
    kSupportFieldNumber = 39,
    kGroupUiiCleanupFieldNumber = 40,
    kGroupDogfoodingInternalOnlyFieldNumber = 41,
    kSettingsSyncFieldNumber = 42,
  };
  // optional .proto.WebFeatures.WebFeaturesFlag labelsDisplay = 1;
  bool has_labelsdisplay() const;
  private:
  bool _internal_has_labelsdisplay() const;
  public:
  void clear_labelsdisplay();
  ::proto::WebFeatures_WebFeaturesFlag labelsdisplay() const;
  void set_labelsdisplay(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_labelsdisplay() const;
  void _internal_set_labelsdisplay(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag voipIndividualOutgoing = 2;
  bool has_voipindividualoutgoing() const;
  private:
  bool _internal_has_voipindividualoutgoing() const;
  public:
  void clear_voipindividualoutgoing();
  ::proto::WebFeatures_WebFeaturesFlag voipindividualoutgoing() const;
  void set_voipindividualoutgoing(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_voipindividualoutgoing() const;
  void _internal_set_voipindividualoutgoing(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag groupsV3 = 3;
  bool has_groupsv3() const;
  private:
  bool _internal_has_groupsv3() const;
  public:
  void clear_groupsv3();
  ::proto::WebFeatures_WebFeaturesFlag groupsv3() const;
  void set_groupsv3(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_groupsv3() const;
  void _internal_set_groupsv3(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag groupsV3Create = 4;
  bool has_groupsv3create() const;
  private:
  bool _internal_has_groupsv3create() const;
  public:
  void clear_groupsv3create();
  ::proto::WebFeatures_WebFeaturesFlag groupsv3create() const;
  void set_groupsv3create(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_groupsv3create() const;
  void _internal_set_groupsv3create(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag changeNumberV2 = 5;
  bool has_changenumberv2() const;
  private:
  bool _internal_has_changenumberv2() const;
  public:
  void clear_changenumberv2();
  ::proto::WebFeatures_WebFeaturesFlag changenumberv2() const;
  void set_changenumberv2(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_changenumberv2() const;
  void _internal_set_changenumberv2(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag queryStatusV3Thumbnail = 6;
  bool has_querystatusv3thumbnail() const;
  private:
  bool _internal_has_querystatusv3thumbnail() const;
  public:
  void clear_querystatusv3thumbnail();
  ::proto::WebFeatures_WebFeaturesFlag querystatusv3thumbnail() const;
  void set_querystatusv3thumbnail(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_querystatusv3thumbnail() const;
  void _internal_set_querystatusv3thumbnail(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag liveLocations = 7;
  bool has_livelocations() const;
  private:
  bool _internal_has_livelocations() const;
  public:
  void clear_livelocations();
  ::proto::WebFeatures_WebFeaturesFlag livelocations() const;
  void set_livelocations(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_livelocations() const;
  void _internal_set_livelocations(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag queryVname = 8;
  bool has_queryvname() const;
  private:
  bool _internal_has_queryvname() const;
  public:
  void clear_queryvname();
  ::proto::WebFeatures_WebFeaturesFlag queryvname() const;
  void set_queryvname(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_queryvname() const;
  void _internal_set_queryvname(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag voipIndividualIncoming = 9;
  bool has_voipindividualincoming() const;
  private:
  bool _internal_has_voipindividualincoming() const;
  public:
  void clear_voipindividualincoming();
  ::proto::WebFeatures_WebFeaturesFlag voipindividualincoming() const;
  void set_voipindividualincoming(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_voipindividualincoming() const;
  void _internal_set_voipindividualincoming(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag quickRepliesQuery = 10;
  bool has_quickrepliesquery() const;
  private:
  bool _internal_has_quickrepliesquery() const;
  public:
  void clear_quickrepliesquery();
  ::proto::WebFeatures_WebFeaturesFlag quickrepliesquery() const;
  void set_quickrepliesquery(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_quickrepliesquery() const;
  void _internal_set_quickrepliesquery(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag payments = 11;
  bool has_payments() const;
  private:
  bool _internal_has_payments() const;
  public:
  void clear_payments();
  ::proto::WebFeatures_WebFeaturesFlag payments() const;
  void set_payments(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_payments() const;
  void _internal_set_payments(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag stickerPackQuery = 12;
  bool has_stickerpackquery() const;
  private:
  bool _internal_has_stickerpackquery() const;
  public:
  void clear_stickerpackquery();
  ::proto::WebFeatures_WebFeaturesFlag stickerpackquery() const;
  void set_stickerpackquery(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_stickerpackquery() const;
  void _internal_set_stickerpackquery(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag liveLocationsFinal = 13;
  bool has_livelocationsfinal() const;
  private:
  bool _internal_has_livelocationsfinal() const;
  public:
  void clear_livelocationsfinal();
  ::proto::WebFeatures_WebFeaturesFlag livelocationsfinal() const;
  void set_livelocationsfinal(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_livelocationsfinal() const;
  void _internal_set_livelocationsfinal(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag labelsEdit = 14;
  bool has_labelsedit() const;
  private:
  bool _internal_has_labelsedit() const;
  public:
  void clear_labelsedit();
  ::proto::WebFeatures_WebFeaturesFlag labelsedit() const;
  void set_labelsedit(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_labelsedit() const;
  void _internal_set_labelsedit(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag mediaUpload = 15;
  bool has_mediaupload() const;
  private:
  bool _internal_has_mediaupload() const;
  public:
  void clear_mediaupload();
  ::proto::WebFeatures_WebFeaturesFlag mediaupload() const;
  void set_mediaupload(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_mediaupload() const;
  void _internal_set_mediaupload(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag mediaUploadRichQuickReplies = 18;
  bool has_mediauploadrichquickreplies() const;
  private:
  bool _internal_has_mediauploadrichquickreplies() const;
  public:
  void clear_mediauploadrichquickreplies();
  ::proto::WebFeatures_WebFeaturesFlag mediauploadrichquickreplies() const;
  void set_mediauploadrichquickreplies(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_mediauploadrichquickreplies() const;
  void _internal_set_mediauploadrichquickreplies(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag vnameV2 = 19;
  bool has_vnamev2() const;
  private:
  bool _internal_has_vnamev2() const;
  public:
  void clear_vnamev2();
  ::proto::WebFeatures_WebFeaturesFlag vnamev2() const;
  void set_vnamev2(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_vnamev2() const;
  void _internal_set_vnamev2(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag videoPlaybackUrl = 20;
  bool has_videoplaybackurl() const;
  private:
  bool _internal_has_videoplaybackurl() const;
  public:
  void clear_videoplaybackurl();
  ::proto::WebFeatures_WebFeaturesFlag videoplaybackurl() const;
  void set_videoplaybackurl(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_videoplaybackurl() const;
  void _internal_set_videoplaybackurl(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag statusRanking = 21;
  bool has_statusranking() const;
  private:
  bool _internal_has_statusranking() const;
  public:
  void clear_statusranking();
  ::proto::WebFeatures_WebFeaturesFlag statusranking() const;
  void set_statusranking(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_statusranking() const;
  void _internal_set_statusranking(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag voipIndividualVideo = 22;
  bool has_voipindividualvideo() const;
  private:
  bool _internal_has_voipindividualvideo() const;
  public:
  void clear_voipindividualvideo();
  ::proto::WebFeatures_WebFeaturesFlag voipindividualvideo() const;
  void set_voipindividualvideo(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_voipindividualvideo() const;
  void _internal_set_voipindividualvideo(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag thirdPartyStickers = 23;
  bool has_thirdpartystickers() const;
  private:
  bool _internal_has_thirdpartystickers() const;
  public:
  void clear_thirdpartystickers();
  ::proto::WebFeatures_WebFeaturesFlag thirdpartystickers() const;
  void set_thirdpartystickers(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_thirdpartystickers() const;
  void _internal_set_thirdpartystickers(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag frequentlyForwardedSetting = 24;
  bool has_frequentlyforwardedsetting() const;
  private:
  bool _internal_has_frequentlyforwardedsetting() const;
  public:
  void clear_frequentlyforwardedsetting();
  ::proto::WebFeatures_WebFeaturesFlag frequentlyforwardedsetting() const;
  void set_frequentlyforwardedsetting(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_frequentlyforwardedsetting() const;
  void _internal_set_frequentlyforwardedsetting(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag groupsV4JoinPermission = 25;
  bool has_groupsv4joinpermission() const;
  private:
  bool _internal_has_groupsv4joinpermission() const;
  public:
  void clear_groupsv4joinpermission();
  ::proto::WebFeatures_WebFeaturesFlag groupsv4joinpermission() const;
  void set_groupsv4joinpermission(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_groupsv4joinpermission() const;
  void _internal_set_groupsv4joinpermission(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag recentStickers = 26;
  bool has_recentstickers() const;
  private:
  bool _internal_has_recentstickers() const;
  public:
  void clear_recentstickers();
  ::proto::WebFeatures_WebFeaturesFlag recentstickers() const;
  void set_recentstickers(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_recentstickers() const;
  void _internal_set_recentstickers(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag catalog = 27;
  bool has_catalog() const;
  private:
  bool _internal_has_catalog() const;
  public:
  void clear_catalog();
  ::proto::WebFeatures_WebFeaturesFlag catalog() const;
  void set_catalog(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_catalog() const;
  void _internal_set_catalog(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag starredStickers = 28;
  bool has_starredstickers() const;
  private:
  bool _internal_has_starredstickers() const;
  public:
  void clear_starredstickers();
  ::proto::WebFeatures_WebFeaturesFlag starredstickers() const;
  void set_starredstickers(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_starredstickers() const;
  void _internal_set_starredstickers(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag voipGroupCall = 29;
  bool has_voipgroupcall() const;
  private:
  bool _internal_has_voipgroupcall() const;
  public:
  void clear_voipgroupcall();
  ::proto::WebFeatures_WebFeaturesFlag voipgroupcall() const;
  void set_voipgroupcall(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_voipgroupcall() const;
  void _internal_set_voipgroupcall(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag templateMessage = 30;
  bool has_templatemessage() const;
  private:
  bool _internal_has_templatemessage() const;
  public:
  void clear_templatemessage();
  ::proto::WebFeatures_WebFeaturesFlag templatemessage() const;
  void set_templatemessage(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_templatemessage() const;
  void _internal_set_templatemessage(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag templateMessageInteractivity = 31;
  bool has_templatemessageinteractivity() const;
  private:
  bool _internal_has_templatemessageinteractivity() const;
  public:
  void clear_templatemessageinteractivity();
  ::proto::WebFeatures_WebFeaturesFlag templatemessageinteractivity() const;
  void set_templatemessageinteractivity(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_templatemessageinteractivity() const;
  void _internal_set_templatemessageinteractivity(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag ephemeralMessages = 32;
  bool has_ephemeralmessages() const;
  private:
  bool _internal_has_ephemeralmessages() const;
  public:
  void clear_ephemeralmessages();
  ::proto::WebFeatures_WebFeaturesFlag ephemeralmessages() const;
  void set_ephemeralmessages(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_ephemeralmessages() const;
  void _internal_set_ephemeralmessages(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag e2ENotificationSync = 33;
  bool has_e2enotificationsync() const;
  private:
  bool _internal_has_e2enotificationsync() const;
  public:
  void clear_e2enotificationsync();
  ::proto::WebFeatures_WebFeaturesFlag e2enotificationsync() const;
  void set_e2enotificationsync(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_e2enotificationsync() const;
  void _internal_set_e2enotificationsync(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag recentStickersV2 = 34;
  bool has_recentstickersv2() const;
  private:
  bool _internal_has_recentstickersv2() const;
  public:
  void clear_recentstickersv2();
  ::proto::WebFeatures_WebFeaturesFlag recentstickersv2() const;
  void set_recentstickersv2(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_recentstickersv2() const;
  void _internal_set_recentstickersv2(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag syncdRelease1 = 35;
  bool has_syncdrelease1() const;
  private:
  bool _internal_has_syncdrelease1() const;
  public:
  void clear_syncdrelease1();
  ::proto::WebFeatures_WebFeaturesFlag syncdrelease1() const;
  void set_syncdrelease1(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_syncdrelease1() const;
  void _internal_set_syncdrelease1(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag recentStickersV3 = 36;
  bool has_recentstickersv3() const;
  private:
  bool _internal_has_recentstickersv3() const;
  public:
  void clear_recentstickersv3();
  ::proto::WebFeatures_WebFeaturesFlag recentstickersv3() const;
  void set_recentstickersv3(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_recentstickersv3() const;
  void _internal_set_recentstickersv3(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag userNotice = 37;
  bool has_usernotice() const;
  private:
  bool _internal_has_usernotice() const;
  public:
  void clear_usernotice();
  ::proto::WebFeatures_WebFeaturesFlag usernotice() const;
  void set_usernotice(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_usernotice() const;
  void _internal_set_usernotice(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag syncdRelease11 = 38;
  bool has_syncdrelease11() const;
  private:
  bool _internal_has_syncdrelease11() const;
  public:
  void clear_syncdrelease11();
  ::proto::WebFeatures_WebFeaturesFlag syncdrelease11() const;
  void set_syncdrelease11(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_syncdrelease11() const;
  void _internal_set_syncdrelease11(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag support = 39;
  bool has_support() const;
  private:
  bool _internal_has_support() const;
  public:
  void clear_support();
  ::proto::WebFeatures_WebFeaturesFlag support() const;
  void set_support(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_support() const;
  void _internal_set_support(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag groupUiiCleanup = 40;
  bool has_groupuiicleanup() const;
  private:
  bool _internal_has_groupuiicleanup() const;
  public:
  void clear_groupuiicleanup();
  ::proto::WebFeatures_WebFeaturesFlag groupuiicleanup() const;
  void set_groupuiicleanup(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_groupuiicleanup() const;
  void _internal_set_groupuiicleanup(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag groupDogfoodingInternalOnly = 41;
  bool has_groupdogfoodinginternalonly() const;
  private:
  bool _internal_has_groupdogfoodinginternalonly() const;
  public:
  void clear_groupdogfoodinginternalonly();
  ::proto::WebFeatures_WebFeaturesFlag groupdogfoodinginternalonly() const;
  void set_groupdogfoodinginternalonly(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_groupdogfoodinginternalonly() const;
  void _internal_set_groupdogfoodinginternalonly(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // optional .proto.WebFeatures.WebFeaturesFlag settingsSync = 42;
  bool has_settingssync() const;
  private:
  bool _internal_has_settingssync() const;
  public:
  void clear_settingssync();
  ::proto::WebFeatures_WebFeaturesFlag settingssync() const;
  void set_settingssync(::proto::WebFeatures_WebFeaturesFlag value);
  private:
  ::proto::WebFeatures_WebFeaturesFlag _internal_settingssync() const;
  void _internal_set_settingssync(::proto::WebFeatures_WebFeaturesFlag value);
  public:

  // @@protoc_insertion_point(class_scope:proto.WebFeatures)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int labelsdisplay_;
    int voipindividualoutgoing_;
    int groupsv3_;
    int groupsv3create_;
    int changenumberv2_;
    int querystatusv3thumbnail_;
    int livelocations_;
    int queryvname_;
    int voipindividualincoming_;
    int quickrepliesquery_;
    int payments_;
    int stickerpackquery_;
    int livelocationsfinal_;
    int labelsedit_;
    int mediaupload_;
    int mediauploadrichquickreplies_;
    int vnamev2_;
    int videoplaybackurl_;
    int statusranking_;
    int voipindividualvideo_;
    int thirdpartystickers_;
    int frequentlyforwardedsetting_;
    int groupsv4joinpermission_;
    int recentstickers_;
    int catalog_;
    int starredstickers_;
    int voipgroupcall_;
    int templatemessage_;
    int templatemessageinteractivity_;
    int ephemeralmessages_;
    int e2enotificationsync_;
    int recentstickersv2_;
    int syncdrelease1_;
    int recentstickersv3_;
    int usernotice_;
    int syncdrelease11_;
    int support_;
    int groupuiicleanup_;
    int groupdogfoodinginternalonly_;
    int settingssync_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class NotificationMessageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.NotificationMessageInfo) */ {
 public:
  inline NotificationMessageInfo() : NotificationMessageInfo(nullptr) {}
  ~NotificationMessageInfo() override;
  explicit PROTOBUF_CONSTEXPR NotificationMessageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotificationMessageInfo(const NotificationMessageInfo& from);
  NotificationMessageInfo(NotificationMessageInfo&& from) noexcept
    : NotificationMessageInfo() {
    *this = ::std::move(from);
  }

  inline NotificationMessageInfo& operator=(const NotificationMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotificationMessageInfo& operator=(NotificationMessageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotificationMessageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotificationMessageInfo* internal_default_instance() {
    return reinterpret_cast<const NotificationMessageInfo*>(
               &_NotificationMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(NotificationMessageInfo& a, NotificationMessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NotificationMessageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotificationMessageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotificationMessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotificationMessageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotificationMessageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotificationMessageInfo& from) {
    NotificationMessageInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotificationMessageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.NotificationMessageInfo";
  }
  protected:
  explicit NotificationMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantFieldNumber = 4,
    kKeyFieldNumber = 1,
    kMessageFieldNumber = 2,
    kMessageTimestampFieldNumber = 3,
  };
  // optional string participant = 4;
  bool has_participant() const;
  private:
  bool _internal_has_participant() const;
  public:
  void clear_participant();
  const std::string& participant() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant();
  PROTOBUF_NODISCARD std::string* release_participant();
  void set_allocated_participant(std::string* participant);
  private:
  const std::string& _internal_participant() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant(const std::string& value);
  std::string* _internal_mutable_participant();
  public:

  // optional .proto.MessageKey key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::proto::MessageKey& key() const;
  PROTOBUF_NODISCARD ::proto::MessageKey* release_key();
  ::proto::MessageKey* mutable_key();
  void set_allocated_key(::proto::MessageKey* key);
  private:
  const ::proto::MessageKey& _internal_key() const;
  ::proto::MessageKey* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::proto::MessageKey* key);
  ::proto::MessageKey* unsafe_arena_release_key();

  // optional .proto.Message message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::proto::Message& message() const;
  PROTOBUF_NODISCARD ::proto::Message* release_message();
  ::proto::Message* mutable_message();
  void set_allocated_message(::proto::Message* message);
  private:
  const ::proto::Message& _internal_message() const;
  ::proto::Message* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::proto::Message* message);
  ::proto::Message* unsafe_arena_release_message();

  // optional uint64 messageTimestamp = 3;
  bool has_messagetimestamp() const;
  private:
  bool _internal_has_messagetimestamp() const;
  public:
  void clear_messagetimestamp();
  uint64_t messagetimestamp() const;
  void set_messagetimestamp(uint64_t value);
  private:
  uint64_t _internal_messagetimestamp() const;
  void _internal_set_messagetimestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.NotificationMessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_;
    ::proto::MessageKey* key_;
    ::proto::Message* message_;
    uint64_t messagetimestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class WebNotificationsInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.WebNotificationsInfo) */ {
 public:
  inline WebNotificationsInfo() : WebNotificationsInfo(nullptr) {}
  ~WebNotificationsInfo() override;
  explicit PROTOBUF_CONSTEXPR WebNotificationsInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WebNotificationsInfo(const WebNotificationsInfo& from);
  WebNotificationsInfo(WebNotificationsInfo&& from) noexcept
    : WebNotificationsInfo() {
    *this = ::std::move(from);
  }

  inline WebNotificationsInfo& operator=(const WebNotificationsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebNotificationsInfo& operator=(WebNotificationsInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WebNotificationsInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WebNotificationsInfo* internal_default_instance() {
    return reinterpret_cast<const WebNotificationsInfo*>(
               &_WebNotificationsInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(WebNotificationsInfo& a, WebNotificationsInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WebNotificationsInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebNotificationsInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WebNotificationsInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WebNotificationsInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WebNotificationsInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WebNotificationsInfo& from) {
    WebNotificationsInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WebNotificationsInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.WebNotificationsInfo";
  }
  protected:
  explicit WebNotificationsInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotifyMessagesFieldNumber = 5,
    kTimestampFieldNumber = 2,
    kUnreadChatsFieldNumber = 3,
    kNotifyMessageCountFieldNumber = 4,
  };
  // repeated .proto.WebMessageInfo notifyMessages = 5;
  int notifymessages_size() const;
  private:
  int _internal_notifymessages_size() const;
  public:
  void clear_notifymessages();
  ::proto::WebMessageInfo* mutable_notifymessages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::WebMessageInfo >*
      mutable_notifymessages();
  private:
  const ::proto::WebMessageInfo& _internal_notifymessages(int index) const;
  ::proto::WebMessageInfo* _internal_add_notifymessages();
  public:
  const ::proto::WebMessageInfo& notifymessages(int index) const;
  ::proto::WebMessageInfo* add_notifymessages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::WebMessageInfo >&
      notifymessages() const;

  // optional uint64 timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // optional uint32 unreadChats = 3;
  bool has_unreadchats() const;
  private:
  bool _internal_has_unreadchats() const;
  public:
  void clear_unreadchats();
  uint32_t unreadchats() const;
  void set_unreadchats(uint32_t value);
  private:
  uint32_t _internal_unreadchats() const;
  void _internal_set_unreadchats(uint32_t value);
  public:

  // optional uint32 notifyMessageCount = 4;
  bool has_notifymessagecount() const;
  private:
  bool _internal_has_notifymessagecount() const;
  public:
  void clear_notifymessagecount();
  uint32_t notifymessagecount() const;
  void set_notifymessagecount(uint32_t value);
  private:
  uint32_t _internal_notifymessagecount() const;
  void _internal_set_notifymessagecount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.WebNotificationsInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::WebMessageInfo > notifymessages_;
    uint64_t timestamp_;
    uint32_t unreadchats_;
    uint32_t notifymessagecount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class PaymentInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.PaymentInfo) */ {
 public:
  inline PaymentInfo() : PaymentInfo(nullptr) {}
  ~PaymentInfo() override;
  explicit PROTOBUF_CONSTEXPR PaymentInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaymentInfo(const PaymentInfo& from);
  PaymentInfo(PaymentInfo&& from) noexcept
    : PaymentInfo() {
    *this = ::std::move(from);
  }

  inline PaymentInfo& operator=(const PaymentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentInfo& operator=(PaymentInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaymentInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaymentInfo* internal_default_instance() {
    return reinterpret_cast<const PaymentInfo*>(
               &_PaymentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(PaymentInfo& a, PaymentInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaymentInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PaymentInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PaymentInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaymentInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PaymentInfo& from) {
    PaymentInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.PaymentInfo";
  }
  protected:
  explicit PaymentInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PaymentInfo_PaymentInfoCurrency PaymentInfoCurrency;
  static constexpr PaymentInfoCurrency UNKNOWN_CURRENCY =
    PaymentInfo_PaymentInfoCurrency_UNKNOWN_CURRENCY;
  static constexpr PaymentInfoCurrency INR =
    PaymentInfo_PaymentInfoCurrency_INR;
  static inline bool PaymentInfoCurrency_IsValid(int value) {
    return PaymentInfo_PaymentInfoCurrency_IsValid(value);
  }
  static constexpr PaymentInfoCurrency PaymentInfoCurrency_MIN =
    PaymentInfo_PaymentInfoCurrency_PaymentInfoCurrency_MIN;
  static constexpr PaymentInfoCurrency PaymentInfoCurrency_MAX =
    PaymentInfo_PaymentInfoCurrency_PaymentInfoCurrency_MAX;
  static constexpr int PaymentInfoCurrency_ARRAYSIZE =
    PaymentInfo_PaymentInfoCurrency_PaymentInfoCurrency_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PaymentInfoCurrency_descriptor() {
    return PaymentInfo_PaymentInfoCurrency_descriptor();
  }
  template<typename T>
  static inline const std::string& PaymentInfoCurrency_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PaymentInfoCurrency>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PaymentInfoCurrency_Name.");
    return PaymentInfo_PaymentInfoCurrency_Name(enum_t_value);
  }
  static inline bool PaymentInfoCurrency_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PaymentInfoCurrency* value) {
    return PaymentInfo_PaymentInfoCurrency_Parse(name, value);
  }

  typedef PaymentInfo_PaymentInfoStatus PaymentInfoStatus;
  static constexpr PaymentInfoStatus UNKNOWN_STATUS =
    PaymentInfo_PaymentInfoStatus_UNKNOWN_STATUS;
  static constexpr PaymentInfoStatus PROCESSING =
    PaymentInfo_PaymentInfoStatus_PROCESSING;
  static constexpr PaymentInfoStatus SENT =
    PaymentInfo_PaymentInfoStatus_SENT;
  static constexpr PaymentInfoStatus NEED_TO_ACCEPT =
    PaymentInfo_PaymentInfoStatus_NEED_TO_ACCEPT;
  static constexpr PaymentInfoStatus COMPLETE =
    PaymentInfo_PaymentInfoStatus_COMPLETE;
  static constexpr PaymentInfoStatus COULD_NOT_COMPLETE =
    PaymentInfo_PaymentInfoStatus_COULD_NOT_COMPLETE;
  static constexpr PaymentInfoStatus REFUNDED =
    PaymentInfo_PaymentInfoStatus_REFUNDED;
  static constexpr PaymentInfoStatus EXPIRED =
    PaymentInfo_PaymentInfoStatus_EXPIRED;
  static constexpr PaymentInfoStatus REJECTED =
    PaymentInfo_PaymentInfoStatus_REJECTED;
  static constexpr PaymentInfoStatus CANCELLED =
    PaymentInfo_PaymentInfoStatus_CANCELLED;
  static constexpr PaymentInfoStatus WAITING_FOR_PAYER =
    PaymentInfo_PaymentInfoStatus_WAITING_FOR_PAYER;
  static constexpr PaymentInfoStatus WAITING =
    PaymentInfo_PaymentInfoStatus_WAITING;
  static inline bool PaymentInfoStatus_IsValid(int value) {
    return PaymentInfo_PaymentInfoStatus_IsValid(value);
  }
  static constexpr PaymentInfoStatus PaymentInfoStatus_MIN =
    PaymentInfo_PaymentInfoStatus_PaymentInfoStatus_MIN;
  static constexpr PaymentInfoStatus PaymentInfoStatus_MAX =
    PaymentInfo_PaymentInfoStatus_PaymentInfoStatus_MAX;
  static constexpr int PaymentInfoStatus_ARRAYSIZE =
    PaymentInfo_PaymentInfoStatus_PaymentInfoStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PaymentInfoStatus_descriptor() {
    return PaymentInfo_PaymentInfoStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& PaymentInfoStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PaymentInfoStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PaymentInfoStatus_Name.");
    return PaymentInfo_PaymentInfoStatus_Name(enum_t_value);
  }
  static inline bool PaymentInfoStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PaymentInfoStatus* value) {
    return PaymentInfo_PaymentInfoStatus_Parse(name, value);
  }

  typedef PaymentInfo_PaymentInfoTxnStatus PaymentInfoTxnStatus;
  static constexpr PaymentInfoTxnStatus UNKNOWN =
    PaymentInfo_PaymentInfoTxnStatus_UNKNOWN;
  static constexpr PaymentInfoTxnStatus PENDING_SETUP =
    PaymentInfo_PaymentInfoTxnStatus_PENDING_SETUP;
  static constexpr PaymentInfoTxnStatus PENDING_RECEIVER_SETUP =
    PaymentInfo_PaymentInfoTxnStatus_PENDING_RECEIVER_SETUP;
  static constexpr PaymentInfoTxnStatus INIT =
    PaymentInfo_PaymentInfoTxnStatus_INIT;
  static constexpr PaymentInfoTxnStatus SUCCESS =
    PaymentInfo_PaymentInfoTxnStatus_SUCCESS;
  static constexpr PaymentInfoTxnStatus COMPLETED =
    PaymentInfo_PaymentInfoTxnStatus_COMPLETED;
  static constexpr PaymentInfoTxnStatus FAILED =
    PaymentInfo_PaymentInfoTxnStatus_FAILED;
  static constexpr PaymentInfoTxnStatus FAILED_RISK =
    PaymentInfo_PaymentInfoTxnStatus_FAILED_RISK;
  static constexpr PaymentInfoTxnStatus FAILED_PROCESSING =
    PaymentInfo_PaymentInfoTxnStatus_FAILED_PROCESSING;
  static constexpr PaymentInfoTxnStatus FAILED_RECEIVER_PROCESSING =
    PaymentInfo_PaymentInfoTxnStatus_FAILED_RECEIVER_PROCESSING;
  static constexpr PaymentInfoTxnStatus FAILED_DA =
    PaymentInfo_PaymentInfoTxnStatus_FAILED_DA;
  static constexpr PaymentInfoTxnStatus FAILED_DA_FINAL =
    PaymentInfo_PaymentInfoTxnStatus_FAILED_DA_FINAL;
  static constexpr PaymentInfoTxnStatus REFUNDED_TXN =
    PaymentInfo_PaymentInfoTxnStatus_REFUNDED_TXN;
  static constexpr PaymentInfoTxnStatus REFUND_FAILED =
    PaymentInfo_PaymentInfoTxnStatus_REFUND_FAILED;
  static constexpr PaymentInfoTxnStatus REFUND_FAILED_PROCESSING =
    PaymentInfo_PaymentInfoTxnStatus_REFUND_FAILED_PROCESSING;
  static constexpr PaymentInfoTxnStatus REFUND_FAILED_DA =
    PaymentInfo_PaymentInfoTxnStatus_REFUND_FAILED_DA;
  static constexpr PaymentInfoTxnStatus EXPIRED_TXN =
    PaymentInfo_PaymentInfoTxnStatus_EXPIRED_TXN;
  static constexpr PaymentInfoTxnStatus AUTH_CANCELED =
    PaymentInfo_PaymentInfoTxnStatus_AUTH_CANCELED;
  static constexpr PaymentInfoTxnStatus AUTH_CANCEL_FAILED_PROCESSING =
    PaymentInfo_PaymentInfoTxnStatus_AUTH_CANCEL_FAILED_PROCESSING;
  static constexpr PaymentInfoTxnStatus AUTH_CANCEL_FAILED =
    PaymentInfo_PaymentInfoTxnStatus_AUTH_CANCEL_FAILED;
  static constexpr PaymentInfoTxnStatus COLLECT_INIT =
    PaymentInfo_PaymentInfoTxnStatus_COLLECT_INIT;
  static constexpr PaymentInfoTxnStatus COLLECT_SUCCESS =
    PaymentInfo_PaymentInfoTxnStatus_COLLECT_SUCCESS;
  static constexpr PaymentInfoTxnStatus COLLECT_FAILED =
    PaymentInfo_PaymentInfoTxnStatus_COLLECT_FAILED;
  static constexpr PaymentInfoTxnStatus COLLECT_FAILED_RISK =
    PaymentInfo_PaymentInfoTxnStatus_COLLECT_FAILED_RISK;
  static constexpr PaymentInfoTxnStatus COLLECT_REJECTED =
    PaymentInfo_PaymentInfoTxnStatus_COLLECT_REJECTED;
  static constexpr PaymentInfoTxnStatus COLLECT_EXPIRED =
    PaymentInfo_PaymentInfoTxnStatus_COLLECT_EXPIRED;
  static constexpr PaymentInfoTxnStatus COLLECT_CANCELED =
    PaymentInfo_PaymentInfoTxnStatus_COLLECT_CANCELED;
  static constexpr PaymentInfoTxnStatus COLLECT_CANCELLING =
    PaymentInfo_PaymentInfoTxnStatus_COLLECT_CANCELLING;
  static inline bool PaymentInfoTxnStatus_IsValid(int value) {
    return PaymentInfo_PaymentInfoTxnStatus_IsValid(value);
  }
  static constexpr PaymentInfoTxnStatus PaymentInfoTxnStatus_MIN =
    PaymentInfo_PaymentInfoTxnStatus_PaymentInfoTxnStatus_MIN;
  static constexpr PaymentInfoTxnStatus PaymentInfoTxnStatus_MAX =
    PaymentInfo_PaymentInfoTxnStatus_PaymentInfoTxnStatus_MAX;
  static constexpr int PaymentInfoTxnStatus_ARRAYSIZE =
    PaymentInfo_PaymentInfoTxnStatus_PaymentInfoTxnStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PaymentInfoTxnStatus_descriptor() {
    return PaymentInfo_PaymentInfoTxnStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& PaymentInfoTxnStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PaymentInfoTxnStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PaymentInfoTxnStatus_Name.");
    return PaymentInfo_PaymentInfoTxnStatus_Name(enum_t_value);
  }
  static inline bool PaymentInfoTxnStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PaymentInfoTxnStatus* value) {
    return PaymentInfo_PaymentInfoTxnStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kReceiverJidFieldNumber = 3,
    kCurrencyFieldNumber = 9,
    kRequestMessageKeyFieldNumber = 6,
    kPrimaryAmountFieldNumber = 12,
    kExchangeAmountFieldNumber = 13,
    kAmount1000FieldNumber = 2,
    kCurrencyDeprecatedFieldNumber = 1,
    kStatusFieldNumber = 4,
    kTransactionTimestampFieldNumber = 5,
    kExpiryTimestampFieldNumber = 7,
    kFutureproofedFieldNumber = 8,
    kUseNoviFiatFormatFieldNumber = 11,
    kTxnStatusFieldNumber = 10,
  };
  // optional string receiverJid = 3;
  bool has_receiverjid() const;
  private:
  bool _internal_has_receiverjid() const;
  public:
  void clear_receiverjid();
  const std::string& receiverjid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receiverjid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receiverjid();
  PROTOBUF_NODISCARD std::string* release_receiverjid();
  void set_allocated_receiverjid(std::string* receiverjid);
  private:
  const std::string& _internal_receiverjid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiverjid(const std::string& value);
  std::string* _internal_mutable_receiverjid();
  public:

  // optional string currency = 9;
  bool has_currency() const;
  private:
  bool _internal_has_currency() const;
  public:
  void clear_currency();
  const std::string& currency() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currency(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currency();
  PROTOBUF_NODISCARD std::string* release_currency();
  void set_allocated_currency(std::string* currency);
  private:
  const std::string& _internal_currency() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currency(const std::string& value);
  std::string* _internal_mutable_currency();
  public:

  // optional .proto.MessageKey requestMessageKey = 6;
  bool has_requestmessagekey() const;
  private:
  bool _internal_has_requestmessagekey() const;
  public:
  void clear_requestmessagekey();
  const ::proto::MessageKey& requestmessagekey() const;
  PROTOBUF_NODISCARD ::proto::MessageKey* release_requestmessagekey();
  ::proto::MessageKey* mutable_requestmessagekey();
  void set_allocated_requestmessagekey(::proto::MessageKey* requestmessagekey);
  private:
  const ::proto::MessageKey& _internal_requestmessagekey() const;
  ::proto::MessageKey* _internal_mutable_requestmessagekey();
  public:
  void unsafe_arena_set_allocated_requestmessagekey(
      ::proto::MessageKey* requestmessagekey);
  ::proto::MessageKey* unsafe_arena_release_requestmessagekey();

  // optional .proto.PaymentMoney primaryAmount = 12;
  bool has_primaryamount() const;
  private:
  bool _internal_has_primaryamount() const;
  public:
  void clear_primaryamount();
  const ::proto::PaymentMoney& primaryamount() const;
  PROTOBUF_NODISCARD ::proto::PaymentMoney* release_primaryamount();
  ::proto::PaymentMoney* mutable_primaryamount();
  void set_allocated_primaryamount(::proto::PaymentMoney* primaryamount);
  private:
  const ::proto::PaymentMoney& _internal_primaryamount() const;
  ::proto::PaymentMoney* _internal_mutable_primaryamount();
  public:
  void unsafe_arena_set_allocated_primaryamount(
      ::proto::PaymentMoney* primaryamount);
  ::proto::PaymentMoney* unsafe_arena_release_primaryamount();

  // optional .proto.PaymentMoney exchangeAmount = 13;
  bool has_exchangeamount() const;
  private:
  bool _internal_has_exchangeamount() const;
  public:
  void clear_exchangeamount();
  const ::proto::PaymentMoney& exchangeamount() const;
  PROTOBUF_NODISCARD ::proto::PaymentMoney* release_exchangeamount();
  ::proto::PaymentMoney* mutable_exchangeamount();
  void set_allocated_exchangeamount(::proto::PaymentMoney* exchangeamount);
  private:
  const ::proto::PaymentMoney& _internal_exchangeamount() const;
  ::proto::PaymentMoney* _internal_mutable_exchangeamount();
  public:
  void unsafe_arena_set_allocated_exchangeamount(
      ::proto::PaymentMoney* exchangeamount);
  ::proto::PaymentMoney* unsafe_arena_release_exchangeamount();

  // optional uint64 amount1000 = 2;
  bool has_amount1000() const;
  private:
  bool _internal_has_amount1000() const;
  public:
  void clear_amount1000();
  uint64_t amount1000() const;
  void set_amount1000(uint64_t value);
  private:
  uint64_t _internal_amount1000() const;
  void _internal_set_amount1000(uint64_t value);
  public:

  // optional .proto.PaymentInfo.PaymentInfoCurrency currencyDeprecated = 1;
  bool has_currencydeprecated() const;
  private:
  bool _internal_has_currencydeprecated() const;
  public:
  void clear_currencydeprecated();
  ::proto::PaymentInfo_PaymentInfoCurrency currencydeprecated() const;
  void set_currencydeprecated(::proto::PaymentInfo_PaymentInfoCurrency value);
  private:
  ::proto::PaymentInfo_PaymentInfoCurrency _internal_currencydeprecated() const;
  void _internal_set_currencydeprecated(::proto::PaymentInfo_PaymentInfoCurrency value);
  public:

  // optional .proto.PaymentInfo.PaymentInfoStatus status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::proto::PaymentInfo_PaymentInfoStatus status() const;
  void set_status(::proto::PaymentInfo_PaymentInfoStatus value);
  private:
  ::proto::PaymentInfo_PaymentInfoStatus _internal_status() const;
  void _internal_set_status(::proto::PaymentInfo_PaymentInfoStatus value);
  public:

  // optional uint64 transactionTimestamp = 5;
  bool has_transactiontimestamp() const;
  private:
  bool _internal_has_transactiontimestamp() const;
  public:
  void clear_transactiontimestamp();
  uint64_t transactiontimestamp() const;
  void set_transactiontimestamp(uint64_t value);
  private:
  uint64_t _internal_transactiontimestamp() const;
  void _internal_set_transactiontimestamp(uint64_t value);
  public:

  // optional uint64 expiryTimestamp = 7;
  bool has_expirytimestamp() const;
  private:
  bool _internal_has_expirytimestamp() const;
  public:
  void clear_expirytimestamp();
  uint64_t expirytimestamp() const;
  void set_expirytimestamp(uint64_t value);
  private:
  uint64_t _internal_expirytimestamp() const;
  void _internal_set_expirytimestamp(uint64_t value);
  public:

  // optional bool futureproofed = 8;
  bool has_futureproofed() const;
  private:
  bool _internal_has_futureproofed() const;
  public:
  void clear_futureproofed();
  bool futureproofed() const;
  void set_futureproofed(bool value);
  private:
  bool _internal_futureproofed() const;
  void _internal_set_futureproofed(bool value);
  public:

  // optional bool useNoviFiatFormat = 11;
  bool has_usenovifiatformat() const;
  private:
  bool _internal_has_usenovifiatformat() const;
  public:
  void clear_usenovifiatformat();
  bool usenovifiatformat() const;
  void set_usenovifiatformat(bool value);
  private:
  bool _internal_usenovifiatformat() const;
  void _internal_set_usenovifiatformat(bool value);
  public:

  // optional .proto.PaymentInfo.PaymentInfoTxnStatus txnStatus = 10;
  bool has_txnstatus() const;
  private:
  bool _internal_has_txnstatus() const;
  public:
  void clear_txnstatus();
  ::proto::PaymentInfo_PaymentInfoTxnStatus txnstatus() const;
  void set_txnstatus(::proto::PaymentInfo_PaymentInfoTxnStatus value);
  private:
  ::proto::PaymentInfo_PaymentInfoTxnStatus _internal_txnstatus() const;
  void _internal_set_txnstatus(::proto::PaymentInfo_PaymentInfoTxnStatus value);
  public:

  // @@protoc_insertion_point(class_scope:proto.PaymentInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiverjid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currency_;
    ::proto::MessageKey* requestmessagekey_;
    ::proto::PaymentMoney* primaryamount_;
    ::proto::PaymentMoney* exchangeamount_;
    uint64_t amount1000_;
    int currencydeprecated_;
    int status_;
    uint64_t transactiontimestamp_;
    uint64_t expirytimestamp_;
    bool futureproofed_;
    bool usenovifiatformat_;
    int txnstatus_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// -------------------------------------------------------------------

class WebMessageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.WebMessageInfo) */ {
 public:
  inline WebMessageInfo() : WebMessageInfo(nullptr) {}
  ~WebMessageInfo() override;
  explicit PROTOBUF_CONSTEXPR WebMessageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WebMessageInfo(const WebMessageInfo& from);
  WebMessageInfo(WebMessageInfo&& from) noexcept
    : WebMessageInfo() {
    *this = ::std::move(from);
  }

  inline WebMessageInfo& operator=(const WebMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebMessageInfo& operator=(WebMessageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WebMessageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WebMessageInfo* internal_default_instance() {
    return reinterpret_cast<const WebMessageInfo*>(
               &_WebMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(WebMessageInfo& a, WebMessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WebMessageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebMessageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WebMessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WebMessageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WebMessageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WebMessageInfo& from) {
    WebMessageInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WebMessageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.WebMessageInfo";
  }
  protected:
  explicit WebMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WebMessageInfo_WebMessageInfoStatus WebMessageInfoStatus;
  static constexpr WebMessageInfoStatus ERROR =
    WebMessageInfo_WebMessageInfoStatus_ERROR;
  static constexpr WebMessageInfoStatus PENDING =
    WebMessageInfo_WebMessageInfoStatus_PENDING;
  static constexpr WebMessageInfoStatus SERVER_ACK =
    WebMessageInfo_WebMessageInfoStatus_SERVER_ACK;
  static constexpr WebMessageInfoStatus DELIVERY_ACK =
    WebMessageInfo_WebMessageInfoStatus_DELIVERY_ACK;
  static constexpr WebMessageInfoStatus READ =
    WebMessageInfo_WebMessageInfoStatus_READ;
  static constexpr WebMessageInfoStatus PLAYED =
    WebMessageInfo_WebMessageInfoStatus_PLAYED;
  static inline bool WebMessageInfoStatus_IsValid(int value) {
    return WebMessageInfo_WebMessageInfoStatus_IsValid(value);
  }
  static constexpr WebMessageInfoStatus WebMessageInfoStatus_MIN =
    WebMessageInfo_WebMessageInfoStatus_WebMessageInfoStatus_MIN;
  static constexpr WebMessageInfoStatus WebMessageInfoStatus_MAX =
    WebMessageInfo_WebMessageInfoStatus_WebMessageInfoStatus_MAX;
  static constexpr int WebMessageInfoStatus_ARRAYSIZE =
    WebMessageInfo_WebMessageInfoStatus_WebMessageInfoStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  WebMessageInfoStatus_descriptor() {
    return WebMessageInfo_WebMessageInfoStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& WebMessageInfoStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, WebMessageInfoStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function WebMessageInfoStatus_Name.");
    return WebMessageInfo_WebMessageInfoStatus_Name(enum_t_value);
  }
  static inline bool WebMessageInfoStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      WebMessageInfoStatus* value) {
    return WebMessageInfo_WebMessageInfoStatus_Parse(name, value);
  }

  typedef WebMessageInfo_WebMessageInfoStubType WebMessageInfoStubType;
  static constexpr WebMessageInfoStubType UNKNOWN =
    WebMessageInfo_WebMessageInfoStubType_UNKNOWN;
  static constexpr WebMessageInfoStubType REVOKE =
    WebMessageInfo_WebMessageInfoStubType_REVOKE;
  static constexpr WebMessageInfoStubType CIPHERTEXT =
    WebMessageInfo_WebMessageInfoStubType_CIPHERTEXT;
  static constexpr WebMessageInfoStubType FUTUREPROOF =
    WebMessageInfo_WebMessageInfoStubType_FUTUREPROOF;
  static constexpr WebMessageInfoStubType NON_VERIFIED_TRANSITION =
    WebMessageInfo_WebMessageInfoStubType_NON_VERIFIED_TRANSITION;
  static constexpr WebMessageInfoStubType UNVERIFIED_TRANSITION =
    WebMessageInfo_WebMessageInfoStubType_UNVERIFIED_TRANSITION;
  static constexpr WebMessageInfoStubType VERIFIED_TRANSITION =
    WebMessageInfo_WebMessageInfoStubType_VERIFIED_TRANSITION;
  static constexpr WebMessageInfoStubType VERIFIED_LOW_UNKNOWN =
    WebMessageInfo_WebMessageInfoStubType_VERIFIED_LOW_UNKNOWN;
  static constexpr WebMessageInfoStubType VERIFIED_HIGH =
    WebMessageInfo_WebMessageInfoStubType_VERIFIED_HIGH;
  static constexpr WebMessageInfoStubType VERIFIED_INITIAL_UNKNOWN =
    WebMessageInfo_WebMessageInfoStubType_VERIFIED_INITIAL_UNKNOWN;
  static constexpr WebMessageInfoStubType VERIFIED_INITIAL_LOW =
    WebMessageInfo_WebMessageInfoStubType_VERIFIED_INITIAL_LOW;
  static constexpr WebMessageInfoStubType VERIFIED_INITIAL_HIGH =
    WebMessageInfo_WebMessageInfoStubType_VERIFIED_INITIAL_HIGH;
  static constexpr WebMessageInfoStubType VERIFIED_TRANSITION_ANY_TO_NONE =
    WebMessageInfo_WebMessageInfoStubType_VERIFIED_TRANSITION_ANY_TO_NONE;
  static constexpr WebMessageInfoStubType VERIFIED_TRANSITION_ANY_TO_HIGH =
    WebMessageInfo_WebMessageInfoStubType_VERIFIED_TRANSITION_ANY_TO_HIGH;
  static constexpr WebMessageInfoStubType VERIFIED_TRANSITION_HIGH_TO_LOW =
    WebMessageInfo_WebMessageInfoStubType_VERIFIED_TRANSITION_HIGH_TO_LOW;
  static constexpr WebMessageInfoStubType VERIFIED_TRANSITION_HIGH_TO_UNKNOWN =
    WebMessageInfo_WebMessageInfoStubType_VERIFIED_TRANSITION_HIGH_TO_UNKNOWN;
  static constexpr WebMessageInfoStubType VERIFIED_TRANSITION_UNKNOWN_TO_LOW =
    WebMessageInfo_WebMessageInfoStubType_VERIFIED_TRANSITION_UNKNOWN_TO_LOW;
  static constexpr WebMessageInfoStubType VERIFIED_TRANSITION_LOW_TO_UNKNOWN =
    WebMessageInfo_WebMessageInfoStubType_VERIFIED_TRANSITION_LOW_TO_UNKNOWN;
  static constexpr WebMessageInfoStubType VERIFIED_TRANSITION_NONE_TO_LOW =
    WebMessageInfo_WebMessageInfoStubType_VERIFIED_TRANSITION_NONE_TO_LOW;
  static constexpr WebMessageInfoStubType VERIFIED_TRANSITION_NONE_TO_UNKNOWN =
    WebMessageInfo_WebMessageInfoStubType_VERIFIED_TRANSITION_NONE_TO_UNKNOWN;
  static constexpr WebMessageInfoStubType GROUP_CREATE =
    WebMessageInfo_WebMessageInfoStubType_GROUP_CREATE;
  static constexpr WebMessageInfoStubType GROUP_CHANGE_SUBJECT =
    WebMessageInfo_WebMessageInfoStubType_GROUP_CHANGE_SUBJECT;
  static constexpr WebMessageInfoStubType GROUP_CHANGE_ICON =
    WebMessageInfo_WebMessageInfoStubType_GROUP_CHANGE_ICON;
  static constexpr WebMessageInfoStubType GROUP_CHANGE_INVITE_LINK =
    WebMessageInfo_WebMessageInfoStubType_GROUP_CHANGE_INVITE_LINK;
  static constexpr WebMessageInfoStubType GROUP_CHANGE_DESCRIPTION =
    WebMessageInfo_WebMessageInfoStubType_GROUP_CHANGE_DESCRIPTION;
  static constexpr WebMessageInfoStubType GROUP_CHANGE_RESTRICT =
    WebMessageInfo_WebMessageInfoStubType_GROUP_CHANGE_RESTRICT;
  static constexpr WebMessageInfoStubType GROUP_CHANGE_ANNOUNCE =
    WebMessageInfo_WebMessageInfoStubType_GROUP_CHANGE_ANNOUNCE;
  static constexpr WebMessageInfoStubType GROUP_PARTICIPANT_ADD =
    WebMessageInfo_WebMessageInfoStubType_GROUP_PARTICIPANT_ADD;
  static constexpr WebMessageInfoStubType GROUP_PARTICIPANT_REMOVE =
    WebMessageInfo_WebMessageInfoStubType_GROUP_PARTICIPANT_REMOVE;
  static constexpr WebMessageInfoStubType GROUP_PARTICIPANT_PROMOTE =
    WebMessageInfo_WebMessageInfoStubType_GROUP_PARTICIPANT_PROMOTE;
  static constexpr WebMessageInfoStubType GROUP_PARTICIPANT_DEMOTE =
    WebMessageInfo_WebMessageInfoStubType_GROUP_PARTICIPANT_DEMOTE;
  static constexpr WebMessageInfoStubType GROUP_PARTICIPANT_INVITE =
    WebMessageInfo_WebMessageInfoStubType_GROUP_PARTICIPANT_INVITE;
  static constexpr WebMessageInfoStubType GROUP_PARTICIPANT_LEAVE =
    WebMessageInfo_WebMessageInfoStubType_GROUP_PARTICIPANT_LEAVE;
  static constexpr WebMessageInfoStubType GROUP_PARTICIPANT_CHANGE_NUMBER =
    WebMessageInfo_WebMessageInfoStubType_GROUP_PARTICIPANT_CHANGE_NUMBER;
  static constexpr WebMessageInfoStubType BROADCAST_CREATE =
    WebMessageInfo_WebMessageInfoStubType_BROADCAST_CREATE;
  static constexpr WebMessageInfoStubType BROADCAST_ADD =
    WebMessageInfo_WebMessageInfoStubType_BROADCAST_ADD;
  static constexpr WebMessageInfoStubType BROADCAST_REMOVE =
    WebMessageInfo_WebMessageInfoStubType_BROADCAST_REMOVE;
  static constexpr WebMessageInfoStubType GENERIC_NOTIFICATION =
    WebMessageInfo_WebMessageInfoStubType_GENERIC_NOTIFICATION;
  static constexpr WebMessageInfoStubType E2E_IDENTITY_CHANGED =
    WebMessageInfo_WebMessageInfoStubType_E2E_IDENTITY_CHANGED;
  static constexpr WebMessageInfoStubType E2E_ENCRYPTED =
    WebMessageInfo_WebMessageInfoStubType_E2E_ENCRYPTED;
  static constexpr WebMessageInfoStubType CALL_MISSED_VOICE =
    WebMessageInfo_WebMessageInfoStubType_CALL_MISSED_VOICE;
  static constexpr WebMessageInfoStubType CALL_MISSED_VIDEO =
    WebMessageInfo_WebMessageInfoStubType_CALL_MISSED_VIDEO;
  static constexpr WebMessageInfoStubType INDIVIDUAL_CHANGE_NUMBER =
    WebMessageInfo_WebMessageInfoStubType_INDIVIDUAL_CHANGE_NUMBER;
  static constexpr WebMessageInfoStubType GROUP_DELETE =
    WebMessageInfo_WebMessageInfoStubType_GROUP_DELETE;
  static constexpr WebMessageInfoStubType GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE =
    WebMessageInfo_WebMessageInfoStubType_GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE;
  static constexpr WebMessageInfoStubType CALL_MISSED_GROUP_VOICE =
    WebMessageInfo_WebMessageInfoStubType_CALL_MISSED_GROUP_VOICE;
  static constexpr WebMessageInfoStubType CALL_MISSED_GROUP_VIDEO =
    WebMessageInfo_WebMessageInfoStubType_CALL_MISSED_GROUP_VIDEO;
  static constexpr WebMessageInfoStubType PAYMENT_CIPHERTEXT =
    WebMessageInfo_WebMessageInfoStubType_PAYMENT_CIPHERTEXT;
  static constexpr WebMessageInfoStubType PAYMENT_FUTUREPROOF =
    WebMessageInfo_WebMessageInfoStubType_PAYMENT_FUTUREPROOF;
  static constexpr WebMessageInfoStubType PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED =
    WebMessageInfo_WebMessageInfoStubType_PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED;
  static constexpr WebMessageInfoStubType PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED =
    WebMessageInfo_WebMessageInfoStubType_PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED;
  static constexpr WebMessageInfoStubType PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED =
    WebMessageInfo_WebMessageInfoStubType_PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED;
  static constexpr WebMessageInfoStubType PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP =
    WebMessageInfo_WebMessageInfoStubType_PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP;
  static constexpr WebMessageInfoStubType PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP =
    WebMessageInfo_WebMessageInfoStubType_PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP;
  static constexpr WebMessageInfoStubType PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER =
    WebMessageInfo_WebMessageInfoStubType_PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER;
  static constexpr WebMessageInfoStubType PAYMENT_ACTION_SEND_PAYMENT_REMINDER =
    WebMessageInfo_WebMessageInfoStubType_PAYMENT_ACTION_SEND_PAYMENT_REMINDER;
  static constexpr WebMessageInfoStubType PAYMENT_ACTION_SEND_PAYMENT_INVITATION =
    WebMessageInfo_WebMessageInfoStubType_PAYMENT_ACTION_SEND_PAYMENT_INVITATION;
  static constexpr WebMessageInfoStubType PAYMENT_ACTION_REQUEST_DECLINED =
    WebMessageInfo_WebMessageInfoStubType_PAYMENT_ACTION_REQUEST_DECLINED;
  static constexpr WebMessageInfoStubType PAYMENT_ACTION_REQUEST_EXPIRED =
    WebMessageInfo_WebMessageInfoStubType_PAYMENT_ACTION_REQUEST_EXPIRED;
  static constexpr WebMessageInfoStubType PAYMENT_ACTION_REQUEST_CANCELLED =
    WebMessageInfo_WebMessageInfoStubType_PAYMENT_ACTION_REQUEST_CANCELLED;
  static constexpr WebMessageInfoStubType BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM =
    WebMessageInfo_WebMessageInfoStubType_BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM;
  static constexpr WebMessageInfoStubType BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP =
    WebMessageInfo_WebMessageInfoStubType_BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP;
  static constexpr WebMessageInfoStubType BIZ_INTRO_TOP =
    WebMessageInfo_WebMessageInfoStubType_BIZ_INTRO_TOP;
  static constexpr WebMessageInfoStubType BIZ_INTRO_BOTTOM =
    WebMessageInfo_WebMessageInfoStubType_BIZ_INTRO_BOTTOM;
  static constexpr WebMessageInfoStubType BIZ_NAME_CHANGE =
    WebMessageInfo_WebMessageInfoStubType_BIZ_NAME_CHANGE;
  static constexpr WebMessageInfoStubType BIZ_MOVE_TO_CONSUMER_APP =
    WebMessageInfo_WebMessageInfoStubType_BIZ_MOVE_TO_CONSUMER_APP;
  static constexpr WebMessageInfoStubType BIZ_TWO_TIER_MIGRATION_TOP =
    WebMessageInfo_WebMessageInfoStubType_BIZ_TWO_TIER_MIGRATION_TOP;
  static constexpr WebMessageInfoStubType BIZ_TWO_TIER_MIGRATION_BOTTOM =
    WebMessageInfo_WebMessageInfoStubType_BIZ_TWO_TIER_MIGRATION_BOTTOM;
  static constexpr WebMessageInfoStubType OVERSIZED =
    WebMessageInfo_WebMessageInfoStubType_OVERSIZED;
  static constexpr WebMessageInfoStubType GROUP_CHANGE_NO_FREQUENTLY_FORWARDED =
    WebMessageInfo_WebMessageInfoStubType_GROUP_CHANGE_NO_FREQUENTLY_FORWARDED;
  static constexpr WebMessageInfoStubType GROUP_V4_ADD_INVITE_SENT =
    WebMessageInfo_WebMessageInfoStubType_GROUP_V4_ADD_INVITE_SENT;
  static constexpr WebMessageInfoStubType GROUP_PARTICIPANT_ADD_REQUEST_JOIN =
    WebMessageInfo_WebMessageInfoStubType_GROUP_PARTICIPANT_ADD_REQUEST_JOIN;
  static constexpr WebMessageInfoStubType CHANGE_EPHEMERAL_SETTING =
    WebMessageInfo_WebMessageInfoStubType_CHANGE_EPHEMERAL_SETTING;
  static constexpr WebMessageInfoStubType E2E_DEVICE_CHANGED =
    WebMessageInfo_WebMessageInfoStubType_E2E_DEVICE_CHANGED;
  static constexpr WebMessageInfoStubType VIEWED_ONCE =
    WebMessageInfo_WebMessageInfoStubType_VIEWED_ONCE;
  static constexpr WebMessageInfoStubType E2E_ENCRYPTED_NOW =
    WebMessageInfo_WebMessageInfoStubType_E2E_ENCRYPTED_NOW;
  static constexpr WebMessageInfoStubType BLUE_MSG_BSP_FB_TO_BSP_PREMISE =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_TO_BSP_PREMISE;
  static constexpr WebMessageInfoStubType BLUE_MSG_BSP_FB_TO_SELF_FB =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_TO_SELF_FB;
  static constexpr WebMessageInfoStubType BLUE_MSG_BSP_FB_TO_SELF_PREMISE =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_TO_SELF_PREMISE;
  static constexpr WebMessageInfoStubType BLUE_MSG_BSP_FB_UNVERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_UNVERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_BSP_FB_VERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_VERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE;
  static constexpr WebMessageInfoStubType BLUE_MSG_BSP_PREMISE_UNVERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_PREMISE_UNVERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_BSP_PREMISE_VERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_PREMISE_VERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_SELF_FB_TO_BSP_PREMISE =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_FB_TO_BSP_PREMISE;
  static constexpr WebMessageInfoStubType BLUE_MSG_SELF_FB_TO_SELF_PREMISE =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_FB_TO_SELF_PREMISE;
  static constexpr WebMessageInfoStubType BLUE_MSG_SELF_FB_UNVERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_FB_UNVERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_SELF_FB_VERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_FB_VERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_SELF_PREMISE_TO_BSP_PREMISE =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_PREMISE_TO_BSP_PREMISE;
  static constexpr WebMessageInfoStubType BLUE_MSG_SELF_PREMISE_UNVERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_PREMISE_UNVERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_SELF_PREMISE_VERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_PREMISE_VERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_TO_BSP_FB =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_TO_BSP_FB;
  static constexpr WebMessageInfoStubType BLUE_MSG_TO_CONSUMER =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_TO_CONSUMER;
  static constexpr WebMessageInfoStubType BLUE_MSG_TO_SELF_FB =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_TO_SELF_FB;
  static constexpr WebMessageInfoStubType BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_UNVERIFIED_TO_VERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_UNVERIFIED_TO_VERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_VERIFIED_TO_UNVERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_VERIFIED_TO_UNVERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED;
  static constexpr WebMessageInfoStubType BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED =
    WebMessageInfo_WebMessageInfoStubType_BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED;
  static constexpr WebMessageInfoStubType E2E_IDENTITY_UNAVAILABLE =
    WebMessageInfo_WebMessageInfoStubType_E2E_IDENTITY_UNAVAILABLE;
  static inline bool WebMessageInfoStubType_IsValid(int value) {
    return WebMessageInfo_WebMessageInfoStubType_IsValid(value);
  }
  static constexpr WebMessageInfoStubType WebMessageInfoStubType_MIN =
    WebMessageInfo_WebMessageInfoStubType_WebMessageInfoStubType_MIN;
  static constexpr WebMessageInfoStubType WebMessageInfoStubType_MAX =
    WebMessageInfo_WebMessageInfoStubType_WebMessageInfoStubType_MAX;
  static constexpr int WebMessageInfoStubType_ARRAYSIZE =
    WebMessageInfo_WebMessageInfoStubType_WebMessageInfoStubType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  WebMessageInfoStubType_descriptor() {
    return WebMessageInfo_WebMessageInfoStubType_descriptor();
  }
  template<typename T>
  static inline const std::string& WebMessageInfoStubType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, WebMessageInfoStubType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function WebMessageInfoStubType_Name.");
    return WebMessageInfo_WebMessageInfoStubType_Name(enum_t_value);
  }
  static inline bool WebMessageInfoStubType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      WebMessageInfoStubType* value) {
    return WebMessageInfo_WebMessageInfoStubType_Parse(name, value);
  }

  typedef WebMessageInfo_WebMessageInfoBizPrivacyStatus WebMessageInfoBizPrivacyStatus;
  static constexpr WebMessageInfoBizPrivacyStatus E2EE =
    WebMessageInfo_WebMessageInfoBizPrivacyStatus_E2EE;
  static constexpr WebMessageInfoBizPrivacyStatus FB =
    WebMessageInfo_WebMessageInfoBizPrivacyStatus_FB;
  static constexpr WebMessageInfoBizPrivacyStatus BSP =
    WebMessageInfo_WebMessageInfoBizPrivacyStatus_BSP;
  static constexpr WebMessageInfoBizPrivacyStatus BSP_AND_FB =
    WebMessageInfo_WebMessageInfoBizPrivacyStatus_BSP_AND_FB;
  static inline bool WebMessageInfoBizPrivacyStatus_IsValid(int value) {
    return WebMessageInfo_WebMessageInfoBizPrivacyStatus_IsValid(value);
  }
  static constexpr WebMessageInfoBizPrivacyStatus WebMessageInfoBizPrivacyStatus_MIN =
    WebMessageInfo_WebMessageInfoBizPrivacyStatus_WebMessageInfoBizPrivacyStatus_MIN;
  static constexpr WebMessageInfoBizPrivacyStatus WebMessageInfoBizPrivacyStatus_MAX =
    WebMessageInfo_WebMessageInfoBizPrivacyStatus_WebMessageInfoBizPrivacyStatus_MAX;
  static constexpr int WebMessageInfoBizPrivacyStatus_ARRAYSIZE =
    WebMessageInfo_WebMessageInfoBizPrivacyStatus_WebMessageInfoBizPrivacyStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  WebMessageInfoBizPrivacyStatus_descriptor() {
    return WebMessageInfo_WebMessageInfoBizPrivacyStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& WebMessageInfoBizPrivacyStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, WebMessageInfoBizPrivacyStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function WebMessageInfoBizPrivacyStatus_Name.");
    return WebMessageInfo_WebMessageInfoBizPrivacyStatus_Name(enum_t_value);
  }
  static inline bool WebMessageInfoBizPrivacyStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      WebMessageInfoBizPrivacyStatus* value) {
    return WebMessageInfo_WebMessageInfoBizPrivacyStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageStubParametersFieldNumber = 26,
    kLabelsFieldNumber = 28,
    kParticipantFieldNumber = 5,
    kPushNameFieldNumber = 19,
    kMediaCiphertextSha256FieldNumber = 20,
    kVerifiedBizNameFieldNumber = 37,
    kKeyFieldNumber = 1,
    kMessageFieldNumber = 2,
    kPaymentInfoFieldNumber = 29,
    kFinalLiveLocationFieldNumber = 30,
    kQuotedPaymentInfoFieldNumber = 31,
    kMessageTimestampFieldNumber = 3,
    kStatusFieldNumber = 4,
    kIgnoreFieldNumber = 16,
    kStarredFieldNumber = 17,
    kBroadcastFieldNumber = 18,
    kMulticastFieldNumber = 21,
    kMessageStubTypeFieldNumber = 24,
    kUrlTextFieldNumber = 22,
    kUrlNumberFieldNumber = 23,
    kClearMediaFieldNumber = 25,
    kEphemeralOffToOnFieldNumber = 34,
    kDurationFieldNumber = 27,
    kEphemeralDurationFieldNumber = 33,
    kEphemeralStartTimestampFieldNumber = 32,
    kEphemeralOutOfSyncFieldNumber = 35,
    kBizPrivacyStatusFieldNumber = 36,
  };
  // repeated string messageStubParameters = 26;
  int messagestubparameters_size() const;
  private:
  int _internal_messagestubparameters_size() const;
  public:
  void clear_messagestubparameters();
  const std::string& messagestubparameters(int index) const;
  std::string* mutable_messagestubparameters(int index);
  void set_messagestubparameters(int index, const std::string& value);
  void set_messagestubparameters(int index, std::string&& value);
  void set_messagestubparameters(int index, const char* value);
  void set_messagestubparameters(int index, const char* value, size_t size);
  std::string* add_messagestubparameters();
  void add_messagestubparameters(const std::string& value);
  void add_messagestubparameters(std::string&& value);
  void add_messagestubparameters(const char* value);
  void add_messagestubparameters(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& messagestubparameters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_messagestubparameters();
  private:
  const std::string& _internal_messagestubparameters(int index) const;
  std::string* _internal_add_messagestubparameters();
  public:

  // repeated string labels = 28;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  const std::string& labels(int index) const;
  std::string* mutable_labels(int index);
  void set_labels(int index, const std::string& value);
  void set_labels(int index, std::string&& value);
  void set_labels(int index, const char* value);
  void set_labels(int index, const char* value, size_t size);
  std::string* add_labels();
  void add_labels(const std::string& value);
  void add_labels(std::string&& value);
  void add_labels(const char* value);
  void add_labels(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& labels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_labels();
  private:
  const std::string& _internal_labels(int index) const;
  std::string* _internal_add_labels();
  public:

  // optional string participant = 5;
  bool has_participant() const;
  private:
  bool _internal_has_participant() const;
  public:
  void clear_participant();
  const std::string& participant() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant();
  PROTOBUF_NODISCARD std::string* release_participant();
  void set_allocated_participant(std::string* participant);
  private:
  const std::string& _internal_participant() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant(const std::string& value);
  std::string* _internal_mutable_participant();
  public:

  // optional string pushName = 19;
  bool has_pushname() const;
  private:
  bool _internal_has_pushname() const;
  public:
  void clear_pushname();
  const std::string& pushname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pushname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pushname();
  PROTOBUF_NODISCARD std::string* release_pushname();
  void set_allocated_pushname(std::string* pushname);
  private:
  const std::string& _internal_pushname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pushname(const std::string& value);
  std::string* _internal_mutable_pushname();
  public:

  // optional bytes mediaCiphertextSha256 = 20;
  bool has_mediaciphertextsha256() const;
  private:
  bool _internal_has_mediaciphertextsha256() const;
  public:
  void clear_mediaciphertextsha256();
  const std::string& mediaciphertextsha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mediaciphertextsha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mediaciphertextsha256();
  PROTOBUF_NODISCARD std::string* release_mediaciphertextsha256();
  void set_allocated_mediaciphertextsha256(std::string* mediaciphertextsha256);
  private:
  const std::string& _internal_mediaciphertextsha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mediaciphertextsha256(const std::string& value);
  std::string* _internal_mutable_mediaciphertextsha256();
  public:

  // optional string verifiedBizName = 37;
  bool has_verifiedbizname() const;
  private:
  bool _internal_has_verifiedbizname() const;
  public:
  void clear_verifiedbizname();
  const std::string& verifiedbizname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verifiedbizname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verifiedbizname();
  PROTOBUF_NODISCARD std::string* release_verifiedbizname();
  void set_allocated_verifiedbizname(std::string* verifiedbizname);
  private:
  const std::string& _internal_verifiedbizname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verifiedbizname(const std::string& value);
  std::string* _internal_mutable_verifiedbizname();
  public:

  // required .proto.MessageKey key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::proto::MessageKey& key() const;
  PROTOBUF_NODISCARD ::proto::MessageKey* release_key();
  ::proto::MessageKey* mutable_key();
  void set_allocated_key(::proto::MessageKey* key);
  private:
  const ::proto::MessageKey& _internal_key() const;
  ::proto::MessageKey* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::proto::MessageKey* key);
  ::proto::MessageKey* unsafe_arena_release_key();

  // optional .proto.Message message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::proto::Message& message() const;
  PROTOBUF_NODISCARD ::proto::Message* release_message();
  ::proto::Message* mutable_message();
  void set_allocated_message(::proto::Message* message);
  private:
  const ::proto::Message& _internal_message() const;
  ::proto::Message* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::proto::Message* message);
  ::proto::Message* unsafe_arena_release_message();

  // optional .proto.PaymentInfo paymentInfo = 29;
  bool has_paymentinfo() const;
  private:
  bool _internal_has_paymentinfo() const;
  public:
  void clear_paymentinfo();
  const ::proto::PaymentInfo& paymentinfo() const;
  PROTOBUF_NODISCARD ::proto::PaymentInfo* release_paymentinfo();
  ::proto::PaymentInfo* mutable_paymentinfo();
  void set_allocated_paymentinfo(::proto::PaymentInfo* paymentinfo);
  private:
  const ::proto::PaymentInfo& _internal_paymentinfo() const;
  ::proto::PaymentInfo* _internal_mutable_paymentinfo();
  public:
  void unsafe_arena_set_allocated_paymentinfo(
      ::proto::PaymentInfo* paymentinfo);
  ::proto::PaymentInfo* unsafe_arena_release_paymentinfo();

  // optional .proto.LiveLocationMessage finalLiveLocation = 30;
  bool has_finallivelocation() const;
  private:
  bool _internal_has_finallivelocation() const;
  public:
  void clear_finallivelocation();
  const ::proto::LiveLocationMessage& finallivelocation() const;
  PROTOBUF_NODISCARD ::proto::LiveLocationMessage* release_finallivelocation();
  ::proto::LiveLocationMessage* mutable_finallivelocation();
  void set_allocated_finallivelocation(::proto::LiveLocationMessage* finallivelocation);
  private:
  const ::proto::LiveLocationMessage& _internal_finallivelocation() const;
  ::proto::LiveLocationMessage* _internal_mutable_finallivelocation();
  public:
  void unsafe_arena_set_allocated_finallivelocation(
      ::proto::LiveLocationMessage* finallivelocation);
  ::proto::LiveLocationMessage* unsafe_arena_release_finallivelocation();

  // optional .proto.PaymentInfo quotedPaymentInfo = 31;
  bool has_quotedpaymentinfo() const;
  private:
  bool _internal_has_quotedpaymentinfo() const;
  public:
  void clear_quotedpaymentinfo();
  const ::proto::PaymentInfo& quotedpaymentinfo() const;
  PROTOBUF_NODISCARD ::proto::PaymentInfo* release_quotedpaymentinfo();
  ::proto::PaymentInfo* mutable_quotedpaymentinfo();
  void set_allocated_quotedpaymentinfo(::proto::PaymentInfo* quotedpaymentinfo);
  private:
  const ::proto::PaymentInfo& _internal_quotedpaymentinfo() const;
  ::proto::PaymentInfo* _internal_mutable_quotedpaymentinfo();
  public:
  void unsafe_arena_set_allocated_quotedpaymentinfo(
      ::proto::PaymentInfo* quotedpaymentinfo);
  ::proto::PaymentInfo* unsafe_arena_release_quotedpaymentinfo();

  // optional uint64 messageTimestamp = 3;
  bool has_messagetimestamp() const;
  private:
  bool _internal_has_messagetimestamp() const;
  public:
  void clear_messagetimestamp();
  uint64_t messagetimestamp() const;
  void set_messagetimestamp(uint64_t value);
  private:
  uint64_t _internal_messagetimestamp() const;
  void _internal_set_messagetimestamp(uint64_t value);
  public:

  // optional .proto.WebMessageInfo.WebMessageInfoStatus status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::proto::WebMessageInfo_WebMessageInfoStatus status() const;
  void set_status(::proto::WebMessageInfo_WebMessageInfoStatus value);
  private:
  ::proto::WebMessageInfo_WebMessageInfoStatus _internal_status() const;
  void _internal_set_status(::proto::WebMessageInfo_WebMessageInfoStatus value);
  public:

  // optional bool ignore = 16;
  bool has_ignore() const;
  private:
  bool _internal_has_ignore() const;
  public:
  void clear_ignore();
  bool ignore() const;
  void set_ignore(bool value);
  private:
  bool _internal_ignore() const;
  void _internal_set_ignore(bool value);
  public:

  // optional bool starred = 17;
  bool has_starred() const;
  private:
  bool _internal_has_starred() const;
  public:
  void clear_starred();
  bool starred() const;
  void set_starred(bool value);
  private:
  bool _internal_starred() const;
  void _internal_set_starred(bool value);
  public:

  // optional bool broadcast = 18;
  bool has_broadcast() const;
  private:
  bool _internal_has_broadcast() const;
  public:
  void clear_broadcast();
  bool broadcast() const;
  void set_broadcast(bool value);
  private:
  bool _internal_broadcast() const;
  void _internal_set_broadcast(bool value);
  public:

  // optional bool multicast = 21;
  bool has_multicast() const;
  private:
  bool _internal_has_multicast() const;
  public:
  void clear_multicast();
  bool multicast() const;
  void set_multicast(bool value);
  private:
  bool _internal_multicast() const;
  void _internal_set_multicast(bool value);
  public:

  // optional .proto.WebMessageInfo.WebMessageInfoStubType messageStubType = 24;
  bool has_messagestubtype() const;
  private:
  bool _internal_has_messagestubtype() const;
  public:
  void clear_messagestubtype();
  ::proto::WebMessageInfo_WebMessageInfoStubType messagestubtype() const;
  void set_messagestubtype(::proto::WebMessageInfo_WebMessageInfoStubType value);
  private:
  ::proto::WebMessageInfo_WebMessageInfoStubType _internal_messagestubtype() const;
  void _internal_set_messagestubtype(::proto::WebMessageInfo_WebMessageInfoStubType value);
  public:

  // optional bool urlText = 22;
  bool has_urltext() const;
  private:
  bool _internal_has_urltext() const;
  public:
  void clear_urltext();
  bool urltext() const;
  void set_urltext(bool value);
  private:
  bool _internal_urltext() const;
  void _internal_set_urltext(bool value);
  public:

  // optional bool urlNumber = 23;
  bool has_urlnumber() const;
  private:
  bool _internal_has_urlnumber() const;
  public:
  void clear_urlnumber();
  bool urlnumber() const;
  void set_urlnumber(bool value);
  private:
  bool _internal_urlnumber() const;
  void _internal_set_urlnumber(bool value);
  public:

  // optional bool clearMedia = 25;
  bool has_clearmedia() const;
  private:
  bool _internal_has_clearmedia() const;
  public:
  void clear_clearmedia();
  bool clearmedia() const;
  void set_clearmedia(bool value);
  private:
  bool _internal_clearmedia() const;
  void _internal_set_clearmedia(bool value);
  public:

  // optional bool ephemeralOffToOn = 34;
  bool has_ephemeralofftoon() const;
  private:
  bool _internal_has_ephemeralofftoon() const;
  public:
  void clear_ephemeralofftoon();
  bool ephemeralofftoon() const;
  void set_ephemeralofftoon(bool value);
  private:
  bool _internal_ephemeralofftoon() const;
  void _internal_set_ephemeralofftoon(bool value);
  public:

  // optional uint32 duration = 27;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  uint32_t duration() const;
  void set_duration(uint32_t value);
  private:
  uint32_t _internal_duration() const;
  void _internal_set_duration(uint32_t value);
  public:

  // optional uint32 ephemeralDuration = 33;
  bool has_ephemeralduration() const;
  private:
  bool _internal_has_ephemeralduration() const;
  public:
  void clear_ephemeralduration();
  uint32_t ephemeralduration() const;
  void set_ephemeralduration(uint32_t value);
  private:
  uint32_t _internal_ephemeralduration() const;
  void _internal_set_ephemeralduration(uint32_t value);
  public:

  // optional uint64 ephemeralStartTimestamp = 32;
  bool has_ephemeralstarttimestamp() const;
  private:
  bool _internal_has_ephemeralstarttimestamp() const;
  public:
  void clear_ephemeralstarttimestamp();
  uint64_t ephemeralstarttimestamp() const;
  void set_ephemeralstarttimestamp(uint64_t value);
  private:
  uint64_t _internal_ephemeralstarttimestamp() const;
  void _internal_set_ephemeralstarttimestamp(uint64_t value);
  public:

  // optional bool ephemeralOutOfSync = 35;
  bool has_ephemeraloutofsync() const;
  private:
  bool _internal_has_ephemeraloutofsync() const;
  public:
  void clear_ephemeraloutofsync();
  bool ephemeraloutofsync() const;
  void set_ephemeraloutofsync(bool value);
  private:
  bool _internal_ephemeraloutofsync() const;
  void _internal_set_ephemeraloutofsync(bool value);
  public:

  // optional .proto.WebMessageInfo.WebMessageInfoBizPrivacyStatus bizPrivacyStatus = 36;
  bool has_bizprivacystatus() const;
  private:
  bool _internal_has_bizprivacystatus() const;
  public:
  void clear_bizprivacystatus();
  ::proto::WebMessageInfo_WebMessageInfoBizPrivacyStatus bizprivacystatus() const;
  void set_bizprivacystatus(::proto::WebMessageInfo_WebMessageInfoBizPrivacyStatus value);
  private:
  ::proto::WebMessageInfo_WebMessageInfoBizPrivacyStatus _internal_bizprivacystatus() const;
  void _internal_set_bizprivacystatus(::proto::WebMessageInfo_WebMessageInfoBizPrivacyStatus value);
  public:

  // @@protoc_insertion_point(class_scope:proto.WebMessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> messagestubparameters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pushname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mediaciphertextsha256_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verifiedbizname_;
    ::proto::MessageKey* key_;
    ::proto::Message* message_;
    ::proto::PaymentInfo* paymentinfo_;
    ::proto::LiveLocationMessage* finallivelocation_;
    ::proto::PaymentInfo* quotedpaymentinfo_;
    uint64_t messagetimestamp_;
    int status_;
    bool ignore_;
    bool starred_;
    bool broadcast_;
    bool multicast_;
    int messagestubtype_;
    bool urltext_;
    bool urlnumber_;
    bool clearmedia_;
    bool ephemeralofftoon_;
    uint32_t duration_;
    uint32_t ephemeralduration_;
    uint64_t ephemeralstarttimestamp_;
    bool ephemeraloutofsync_;
    int bizprivacystatus_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pmsg_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PaymentMoney

// optional int64 value = 1;
inline bool PaymentMoney::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PaymentMoney::has_value() const {
  return _internal_has_value();
}
inline void PaymentMoney::clear_value() {
  _impl_.value_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t PaymentMoney::_internal_value() const {
  return _impl_.value_;
}
inline int64_t PaymentMoney::value() const {
  // @@protoc_insertion_point(field_get:proto.PaymentMoney.value)
  return _internal_value();
}
inline void PaymentMoney::_internal_set_value(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_ = value;
}
inline void PaymentMoney::set_value(int64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:proto.PaymentMoney.value)
}

// optional uint32 offset = 2;
inline bool PaymentMoney::_internal_has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PaymentMoney::has_offset() const {
  return _internal_has_offset();
}
inline void PaymentMoney::clear_offset() {
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t PaymentMoney::_internal_offset() const {
  return _impl_.offset_;
}
inline uint32_t PaymentMoney::offset() const {
  // @@protoc_insertion_point(field_get:proto.PaymentMoney.offset)
  return _internal_offset();
}
inline void PaymentMoney::_internal_set_offset(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.offset_ = value;
}
inline void PaymentMoney::set_offset(uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:proto.PaymentMoney.offset)
}

// optional string currencyCode = 3;
inline bool PaymentMoney::_internal_has_currencycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PaymentMoney::has_currencycode() const {
  return _internal_has_currencycode();
}
inline void PaymentMoney::clear_currencycode() {
  _impl_.currencycode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PaymentMoney::currencycode() const {
  // @@protoc_insertion_point(field_get:proto.PaymentMoney.currencyCode)
  return _internal_currencycode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentMoney::set_currencycode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.currencycode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.PaymentMoney.currencyCode)
}
inline std::string* PaymentMoney::mutable_currencycode() {
  std::string* _s = _internal_mutable_currencycode();
  // @@protoc_insertion_point(field_mutable:proto.PaymentMoney.currencyCode)
  return _s;
}
inline const std::string& PaymentMoney::_internal_currencycode() const {
  return _impl_.currencycode_.Get();
}
inline void PaymentMoney::_internal_set_currencycode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.currencycode_.Set(value, GetArenaForAllocation());
}
inline std::string* PaymentMoney::_internal_mutable_currencycode() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.currencycode_.Mutable(GetArenaForAllocation());
}
inline std::string* PaymentMoney::release_currencycode() {
  // @@protoc_insertion_point(field_release:proto.PaymentMoney.currencyCode)
  if (!_internal_has_currencycode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.currencycode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currencycode_.IsDefault()) {
    _impl_.currencycode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaymentMoney::set_allocated_currencycode(std::string* currencycode) {
  if (currencycode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.currencycode_.SetAllocated(currencycode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currencycode_.IsDefault()) {
    _impl_.currencycode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.PaymentMoney.currencyCode)
}

// -------------------------------------------------------------------

// HydratedQuickReplyButton

// optional string displayText = 1;
inline bool HydratedQuickReplyButton::_internal_has_displaytext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HydratedQuickReplyButton::has_displaytext() const {
  return _internal_has_displaytext();
}
inline void HydratedQuickReplyButton::clear_displaytext() {
  _impl_.displaytext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HydratedQuickReplyButton::displaytext() const {
  // @@protoc_insertion_point(field_get:proto.HydratedQuickReplyButton.displayText)
  return _internal_displaytext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HydratedQuickReplyButton::set_displaytext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.displaytext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HydratedQuickReplyButton.displayText)
}
inline std::string* HydratedQuickReplyButton::mutable_displaytext() {
  std::string* _s = _internal_mutable_displaytext();
  // @@protoc_insertion_point(field_mutable:proto.HydratedQuickReplyButton.displayText)
  return _s;
}
inline const std::string& HydratedQuickReplyButton::_internal_displaytext() const {
  return _impl_.displaytext_.Get();
}
inline void HydratedQuickReplyButton::_internal_set_displaytext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.displaytext_.Set(value, GetArenaForAllocation());
}
inline std::string* HydratedQuickReplyButton::_internal_mutable_displaytext() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.displaytext_.Mutable(GetArenaForAllocation());
}
inline std::string* HydratedQuickReplyButton::release_displaytext() {
  // @@protoc_insertion_point(field_release:proto.HydratedQuickReplyButton.displayText)
  if (!_internal_has_displaytext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.displaytext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displaytext_.IsDefault()) {
    _impl_.displaytext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HydratedQuickReplyButton::set_allocated_displaytext(std::string* displaytext) {
  if (displaytext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.displaytext_.SetAllocated(displaytext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displaytext_.IsDefault()) {
    _impl_.displaytext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HydratedQuickReplyButton.displayText)
}

// optional string id = 2;
inline bool HydratedQuickReplyButton::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HydratedQuickReplyButton::has_id() const {
  return _internal_has_id();
}
inline void HydratedQuickReplyButton::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HydratedQuickReplyButton::id() const {
  // @@protoc_insertion_point(field_get:proto.HydratedQuickReplyButton.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HydratedQuickReplyButton::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HydratedQuickReplyButton.id)
}
inline std::string* HydratedQuickReplyButton::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:proto.HydratedQuickReplyButton.id)
  return _s;
}
inline const std::string& HydratedQuickReplyButton::_internal_id() const {
  return _impl_.id_.Get();
}
inline void HydratedQuickReplyButton::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* HydratedQuickReplyButton::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* HydratedQuickReplyButton::release_id() {
  // @@protoc_insertion_point(field_release:proto.HydratedQuickReplyButton.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HydratedQuickReplyButton::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HydratedQuickReplyButton.id)
}

// -------------------------------------------------------------------

// HydratedURLButton

// optional string displayText = 1;
inline bool HydratedURLButton::_internal_has_displaytext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HydratedURLButton::has_displaytext() const {
  return _internal_has_displaytext();
}
inline void HydratedURLButton::clear_displaytext() {
  _impl_.displaytext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HydratedURLButton::displaytext() const {
  // @@protoc_insertion_point(field_get:proto.HydratedURLButton.displayText)
  return _internal_displaytext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HydratedURLButton::set_displaytext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.displaytext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HydratedURLButton.displayText)
}
inline std::string* HydratedURLButton::mutable_displaytext() {
  std::string* _s = _internal_mutable_displaytext();
  // @@protoc_insertion_point(field_mutable:proto.HydratedURLButton.displayText)
  return _s;
}
inline const std::string& HydratedURLButton::_internal_displaytext() const {
  return _impl_.displaytext_.Get();
}
inline void HydratedURLButton::_internal_set_displaytext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.displaytext_.Set(value, GetArenaForAllocation());
}
inline std::string* HydratedURLButton::_internal_mutable_displaytext() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.displaytext_.Mutable(GetArenaForAllocation());
}
inline std::string* HydratedURLButton::release_displaytext() {
  // @@protoc_insertion_point(field_release:proto.HydratedURLButton.displayText)
  if (!_internal_has_displaytext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.displaytext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displaytext_.IsDefault()) {
    _impl_.displaytext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HydratedURLButton::set_allocated_displaytext(std::string* displaytext) {
  if (displaytext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.displaytext_.SetAllocated(displaytext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displaytext_.IsDefault()) {
    _impl_.displaytext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HydratedURLButton.displayText)
}

// optional string url = 2;
inline bool HydratedURLButton::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HydratedURLButton::has_url() const {
  return _internal_has_url();
}
inline void HydratedURLButton::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HydratedURLButton::url() const {
  // @@protoc_insertion_point(field_get:proto.HydratedURLButton.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HydratedURLButton::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HydratedURLButton.url)
}
inline std::string* HydratedURLButton::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:proto.HydratedURLButton.url)
  return _s;
}
inline const std::string& HydratedURLButton::_internal_url() const {
  return _impl_.url_.Get();
}
inline void HydratedURLButton::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* HydratedURLButton::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* HydratedURLButton::release_url() {
  // @@protoc_insertion_point(field_release:proto.HydratedURLButton.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HydratedURLButton::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HydratedURLButton.url)
}

// -------------------------------------------------------------------

// HydratedCallButton

// optional string displayText = 1;
inline bool HydratedCallButton::_internal_has_displaytext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HydratedCallButton::has_displaytext() const {
  return _internal_has_displaytext();
}
inline void HydratedCallButton::clear_displaytext() {
  _impl_.displaytext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HydratedCallButton::displaytext() const {
  // @@protoc_insertion_point(field_get:proto.HydratedCallButton.displayText)
  return _internal_displaytext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HydratedCallButton::set_displaytext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.displaytext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HydratedCallButton.displayText)
}
inline std::string* HydratedCallButton::mutable_displaytext() {
  std::string* _s = _internal_mutable_displaytext();
  // @@protoc_insertion_point(field_mutable:proto.HydratedCallButton.displayText)
  return _s;
}
inline const std::string& HydratedCallButton::_internal_displaytext() const {
  return _impl_.displaytext_.Get();
}
inline void HydratedCallButton::_internal_set_displaytext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.displaytext_.Set(value, GetArenaForAllocation());
}
inline std::string* HydratedCallButton::_internal_mutable_displaytext() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.displaytext_.Mutable(GetArenaForAllocation());
}
inline std::string* HydratedCallButton::release_displaytext() {
  // @@protoc_insertion_point(field_release:proto.HydratedCallButton.displayText)
  if (!_internal_has_displaytext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.displaytext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displaytext_.IsDefault()) {
    _impl_.displaytext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HydratedCallButton::set_allocated_displaytext(std::string* displaytext) {
  if (displaytext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.displaytext_.SetAllocated(displaytext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displaytext_.IsDefault()) {
    _impl_.displaytext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HydratedCallButton.displayText)
}

// optional string phoneNumber = 2;
inline bool HydratedCallButton::_internal_has_phonenumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HydratedCallButton::has_phonenumber() const {
  return _internal_has_phonenumber();
}
inline void HydratedCallButton::clear_phonenumber() {
  _impl_.phonenumber_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HydratedCallButton::phonenumber() const {
  // @@protoc_insertion_point(field_get:proto.HydratedCallButton.phoneNumber)
  return _internal_phonenumber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HydratedCallButton::set_phonenumber(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.phonenumber_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HydratedCallButton.phoneNumber)
}
inline std::string* HydratedCallButton::mutable_phonenumber() {
  std::string* _s = _internal_mutable_phonenumber();
  // @@protoc_insertion_point(field_mutable:proto.HydratedCallButton.phoneNumber)
  return _s;
}
inline const std::string& HydratedCallButton::_internal_phonenumber() const {
  return _impl_.phonenumber_.Get();
}
inline void HydratedCallButton::_internal_set_phonenumber(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.phonenumber_.Set(value, GetArenaForAllocation());
}
inline std::string* HydratedCallButton::_internal_mutable_phonenumber() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.phonenumber_.Mutable(GetArenaForAllocation());
}
inline std::string* HydratedCallButton::release_phonenumber() {
  // @@protoc_insertion_point(field_release:proto.HydratedCallButton.phoneNumber)
  if (!_internal_has_phonenumber()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.phonenumber_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phonenumber_.IsDefault()) {
    _impl_.phonenumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HydratedCallButton::set_allocated_phonenumber(std::string* phonenumber) {
  if (phonenumber != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.phonenumber_.SetAllocated(phonenumber, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phonenumber_.IsDefault()) {
    _impl_.phonenumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HydratedCallButton.phoneNumber)
}

// -------------------------------------------------------------------

// HydratedTemplateButton

// optional uint32 index = 4;
inline bool HydratedTemplateButton::_internal_has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HydratedTemplateButton::has_index() const {
  return _internal_has_index();
}
inline void HydratedTemplateButton::clear_index() {
  _impl_.index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t HydratedTemplateButton::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t HydratedTemplateButton::index() const {
  // @@protoc_insertion_point(field_get:proto.HydratedTemplateButton.index)
  return _internal_index();
}
inline void HydratedTemplateButton::_internal_set_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.index_ = value;
}
inline void HydratedTemplateButton::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:proto.HydratedTemplateButton.index)
}

// .proto.HydratedQuickReplyButton quickReplyButton = 1;
inline bool HydratedTemplateButton::_internal_has_quickreplybutton() const {
  return hydratedButton_case() == kQuickReplyButton;
}
inline bool HydratedTemplateButton::has_quickreplybutton() const {
  return _internal_has_quickreplybutton();
}
inline void HydratedTemplateButton::set_has_quickreplybutton() {
  _impl_._oneof_case_[0] = kQuickReplyButton;
}
inline void HydratedTemplateButton::clear_quickreplybutton() {
  if (_internal_has_quickreplybutton()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.hydratedButton_.quickreplybutton_;
    }
    clear_has_hydratedButton();
  }
}
inline ::proto::HydratedQuickReplyButton* HydratedTemplateButton::release_quickreplybutton() {
  // @@protoc_insertion_point(field_release:proto.HydratedTemplateButton.quickReplyButton)
  if (_internal_has_quickreplybutton()) {
    clear_has_hydratedButton();
    ::proto::HydratedQuickReplyButton* temp = _impl_.hydratedButton_.quickreplybutton_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.hydratedButton_.quickreplybutton_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::HydratedQuickReplyButton& HydratedTemplateButton::_internal_quickreplybutton() const {
  return _internal_has_quickreplybutton()
      ? *_impl_.hydratedButton_.quickreplybutton_
      : reinterpret_cast< ::proto::HydratedQuickReplyButton&>(::proto::_HydratedQuickReplyButton_default_instance_);
}
inline const ::proto::HydratedQuickReplyButton& HydratedTemplateButton::quickreplybutton() const {
  // @@protoc_insertion_point(field_get:proto.HydratedTemplateButton.quickReplyButton)
  return _internal_quickreplybutton();
}
inline ::proto::HydratedQuickReplyButton* HydratedTemplateButton::unsafe_arena_release_quickreplybutton() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.HydratedTemplateButton.quickReplyButton)
  if (_internal_has_quickreplybutton()) {
    clear_has_hydratedButton();
    ::proto::HydratedQuickReplyButton* temp = _impl_.hydratedButton_.quickreplybutton_;
    _impl_.hydratedButton_.quickreplybutton_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HydratedTemplateButton::unsafe_arena_set_allocated_quickreplybutton(::proto::HydratedQuickReplyButton* quickreplybutton) {
  clear_hydratedButton();
  if (quickreplybutton) {
    set_has_quickreplybutton();
    _impl_.hydratedButton_.quickreplybutton_ = quickreplybutton;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HydratedTemplateButton.quickReplyButton)
}
inline ::proto::HydratedQuickReplyButton* HydratedTemplateButton::_internal_mutable_quickreplybutton() {
  if (!_internal_has_quickreplybutton()) {
    clear_hydratedButton();
    set_has_quickreplybutton();
    _impl_.hydratedButton_.quickreplybutton_ = CreateMaybeMessage< ::proto::HydratedQuickReplyButton >(GetArenaForAllocation());
  }
  return _impl_.hydratedButton_.quickreplybutton_;
}
inline ::proto::HydratedQuickReplyButton* HydratedTemplateButton::mutable_quickreplybutton() {
  ::proto::HydratedQuickReplyButton* _msg = _internal_mutable_quickreplybutton();
  // @@protoc_insertion_point(field_mutable:proto.HydratedTemplateButton.quickReplyButton)
  return _msg;
}

// .proto.HydratedURLButton urlButton = 2;
inline bool HydratedTemplateButton::_internal_has_urlbutton() const {
  return hydratedButton_case() == kUrlButton;
}
inline bool HydratedTemplateButton::has_urlbutton() const {
  return _internal_has_urlbutton();
}
inline void HydratedTemplateButton::set_has_urlbutton() {
  _impl_._oneof_case_[0] = kUrlButton;
}
inline void HydratedTemplateButton::clear_urlbutton() {
  if (_internal_has_urlbutton()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.hydratedButton_.urlbutton_;
    }
    clear_has_hydratedButton();
  }
}
inline ::proto::HydratedURLButton* HydratedTemplateButton::release_urlbutton() {
  // @@protoc_insertion_point(field_release:proto.HydratedTemplateButton.urlButton)
  if (_internal_has_urlbutton()) {
    clear_has_hydratedButton();
    ::proto::HydratedURLButton* temp = _impl_.hydratedButton_.urlbutton_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.hydratedButton_.urlbutton_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::HydratedURLButton& HydratedTemplateButton::_internal_urlbutton() const {
  return _internal_has_urlbutton()
      ? *_impl_.hydratedButton_.urlbutton_
      : reinterpret_cast< ::proto::HydratedURLButton&>(::proto::_HydratedURLButton_default_instance_);
}
inline const ::proto::HydratedURLButton& HydratedTemplateButton::urlbutton() const {
  // @@protoc_insertion_point(field_get:proto.HydratedTemplateButton.urlButton)
  return _internal_urlbutton();
}
inline ::proto::HydratedURLButton* HydratedTemplateButton::unsafe_arena_release_urlbutton() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.HydratedTemplateButton.urlButton)
  if (_internal_has_urlbutton()) {
    clear_has_hydratedButton();
    ::proto::HydratedURLButton* temp = _impl_.hydratedButton_.urlbutton_;
    _impl_.hydratedButton_.urlbutton_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HydratedTemplateButton::unsafe_arena_set_allocated_urlbutton(::proto::HydratedURLButton* urlbutton) {
  clear_hydratedButton();
  if (urlbutton) {
    set_has_urlbutton();
    _impl_.hydratedButton_.urlbutton_ = urlbutton;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HydratedTemplateButton.urlButton)
}
inline ::proto::HydratedURLButton* HydratedTemplateButton::_internal_mutable_urlbutton() {
  if (!_internal_has_urlbutton()) {
    clear_hydratedButton();
    set_has_urlbutton();
    _impl_.hydratedButton_.urlbutton_ = CreateMaybeMessage< ::proto::HydratedURLButton >(GetArenaForAllocation());
  }
  return _impl_.hydratedButton_.urlbutton_;
}
inline ::proto::HydratedURLButton* HydratedTemplateButton::mutable_urlbutton() {
  ::proto::HydratedURLButton* _msg = _internal_mutable_urlbutton();
  // @@protoc_insertion_point(field_mutable:proto.HydratedTemplateButton.urlButton)
  return _msg;
}

// .proto.HydratedCallButton callButton = 3;
inline bool HydratedTemplateButton::_internal_has_callbutton() const {
  return hydratedButton_case() == kCallButton;
}
inline bool HydratedTemplateButton::has_callbutton() const {
  return _internal_has_callbutton();
}
inline void HydratedTemplateButton::set_has_callbutton() {
  _impl_._oneof_case_[0] = kCallButton;
}
inline void HydratedTemplateButton::clear_callbutton() {
  if (_internal_has_callbutton()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.hydratedButton_.callbutton_;
    }
    clear_has_hydratedButton();
  }
}
inline ::proto::HydratedCallButton* HydratedTemplateButton::release_callbutton() {
  // @@protoc_insertion_point(field_release:proto.HydratedTemplateButton.callButton)
  if (_internal_has_callbutton()) {
    clear_has_hydratedButton();
    ::proto::HydratedCallButton* temp = _impl_.hydratedButton_.callbutton_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.hydratedButton_.callbutton_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::HydratedCallButton& HydratedTemplateButton::_internal_callbutton() const {
  return _internal_has_callbutton()
      ? *_impl_.hydratedButton_.callbutton_
      : reinterpret_cast< ::proto::HydratedCallButton&>(::proto::_HydratedCallButton_default_instance_);
}
inline const ::proto::HydratedCallButton& HydratedTemplateButton::callbutton() const {
  // @@protoc_insertion_point(field_get:proto.HydratedTemplateButton.callButton)
  return _internal_callbutton();
}
inline ::proto::HydratedCallButton* HydratedTemplateButton::unsafe_arena_release_callbutton() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.HydratedTemplateButton.callButton)
  if (_internal_has_callbutton()) {
    clear_has_hydratedButton();
    ::proto::HydratedCallButton* temp = _impl_.hydratedButton_.callbutton_;
    _impl_.hydratedButton_.callbutton_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HydratedTemplateButton::unsafe_arena_set_allocated_callbutton(::proto::HydratedCallButton* callbutton) {
  clear_hydratedButton();
  if (callbutton) {
    set_has_callbutton();
    _impl_.hydratedButton_.callbutton_ = callbutton;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HydratedTemplateButton.callButton)
}
inline ::proto::HydratedCallButton* HydratedTemplateButton::_internal_mutable_callbutton() {
  if (!_internal_has_callbutton()) {
    clear_hydratedButton();
    set_has_callbutton();
    _impl_.hydratedButton_.callbutton_ = CreateMaybeMessage< ::proto::HydratedCallButton >(GetArenaForAllocation());
  }
  return _impl_.hydratedButton_.callbutton_;
}
inline ::proto::HydratedCallButton* HydratedTemplateButton::mutable_callbutton() {
  ::proto::HydratedCallButton* _msg = _internal_mutable_callbutton();
  // @@protoc_insertion_point(field_mutable:proto.HydratedTemplateButton.callButton)
  return _msg;
}

inline bool HydratedTemplateButton::has_hydratedButton() const {
  return hydratedButton_case() != HYDRATEDBUTTON_NOT_SET;
}
inline void HydratedTemplateButton::clear_has_hydratedButton() {
  _impl_._oneof_case_[0] = HYDRATEDBUTTON_NOT_SET;
}
inline HydratedTemplateButton::HydratedButtonCase HydratedTemplateButton::hydratedButton_case() const {
  return HydratedTemplateButton::HydratedButtonCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// QuickReplyButton

// optional .proto.HighlyStructuredMessage displayText = 1;
inline bool QuickReplyButton::_internal_has_displaytext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.displaytext_ != nullptr);
  return value;
}
inline bool QuickReplyButton::has_displaytext() const {
  return _internal_has_displaytext();
}
inline void QuickReplyButton::clear_displaytext() {
  if (_impl_.displaytext_ != nullptr) _impl_.displaytext_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::HighlyStructuredMessage& QuickReplyButton::_internal_displaytext() const {
  const ::proto::HighlyStructuredMessage* p = _impl_.displaytext_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::HighlyStructuredMessage&>(
      ::proto::_HighlyStructuredMessage_default_instance_);
}
inline const ::proto::HighlyStructuredMessage& QuickReplyButton::displaytext() const {
  // @@protoc_insertion_point(field_get:proto.QuickReplyButton.displayText)
  return _internal_displaytext();
}
inline void QuickReplyButton::unsafe_arena_set_allocated_displaytext(
    ::proto::HighlyStructuredMessage* displaytext) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.displaytext_);
  }
  _impl_.displaytext_ = displaytext;
  if (displaytext) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.QuickReplyButton.displayText)
}
inline ::proto::HighlyStructuredMessage* QuickReplyButton::release_displaytext() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::HighlyStructuredMessage* temp = _impl_.displaytext_;
  _impl_.displaytext_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::HighlyStructuredMessage* QuickReplyButton::unsafe_arena_release_displaytext() {
  // @@protoc_insertion_point(field_release:proto.QuickReplyButton.displayText)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::HighlyStructuredMessage* temp = _impl_.displaytext_;
  _impl_.displaytext_ = nullptr;
  return temp;
}
inline ::proto::HighlyStructuredMessage* QuickReplyButton::_internal_mutable_displaytext() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.displaytext_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::HighlyStructuredMessage>(GetArenaForAllocation());
    _impl_.displaytext_ = p;
  }
  return _impl_.displaytext_;
}
inline ::proto::HighlyStructuredMessage* QuickReplyButton::mutable_displaytext() {
  ::proto::HighlyStructuredMessage* _msg = _internal_mutable_displaytext();
  // @@protoc_insertion_point(field_mutable:proto.QuickReplyButton.displayText)
  return _msg;
}
inline void QuickReplyButton::set_allocated_displaytext(::proto::HighlyStructuredMessage* displaytext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.displaytext_;
  }
  if (displaytext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(displaytext);
    if (message_arena != submessage_arena) {
      displaytext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, displaytext, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.displaytext_ = displaytext;
  // @@protoc_insertion_point(field_set_allocated:proto.QuickReplyButton.displayText)
}

// optional string id = 2;
inline bool QuickReplyButton::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QuickReplyButton::has_id() const {
  return _internal_has_id();
}
inline void QuickReplyButton::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QuickReplyButton::id() const {
  // @@protoc_insertion_point(field_get:proto.QuickReplyButton.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QuickReplyButton::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.QuickReplyButton.id)
}
inline std::string* QuickReplyButton::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:proto.QuickReplyButton.id)
  return _s;
}
inline const std::string& QuickReplyButton::_internal_id() const {
  return _impl_.id_.Get();
}
inline void QuickReplyButton::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* QuickReplyButton::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* QuickReplyButton::release_id() {
  // @@protoc_insertion_point(field_release:proto.QuickReplyButton.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QuickReplyButton::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.QuickReplyButton.id)
}

// -------------------------------------------------------------------

// URLButton

// optional .proto.HighlyStructuredMessage displayText = 1;
inline bool URLButton::_internal_has_displaytext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.displaytext_ != nullptr);
  return value;
}
inline bool URLButton::has_displaytext() const {
  return _internal_has_displaytext();
}
inline void URLButton::clear_displaytext() {
  if (_impl_.displaytext_ != nullptr) _impl_.displaytext_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::HighlyStructuredMessage& URLButton::_internal_displaytext() const {
  const ::proto::HighlyStructuredMessage* p = _impl_.displaytext_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::HighlyStructuredMessage&>(
      ::proto::_HighlyStructuredMessage_default_instance_);
}
inline const ::proto::HighlyStructuredMessage& URLButton::displaytext() const {
  // @@protoc_insertion_point(field_get:proto.URLButton.displayText)
  return _internal_displaytext();
}
inline void URLButton::unsafe_arena_set_allocated_displaytext(
    ::proto::HighlyStructuredMessage* displaytext) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.displaytext_);
  }
  _impl_.displaytext_ = displaytext;
  if (displaytext) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.URLButton.displayText)
}
inline ::proto::HighlyStructuredMessage* URLButton::release_displaytext() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::HighlyStructuredMessage* temp = _impl_.displaytext_;
  _impl_.displaytext_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::HighlyStructuredMessage* URLButton::unsafe_arena_release_displaytext() {
  // @@protoc_insertion_point(field_release:proto.URLButton.displayText)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::HighlyStructuredMessage* temp = _impl_.displaytext_;
  _impl_.displaytext_ = nullptr;
  return temp;
}
inline ::proto::HighlyStructuredMessage* URLButton::_internal_mutable_displaytext() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.displaytext_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::HighlyStructuredMessage>(GetArenaForAllocation());
    _impl_.displaytext_ = p;
  }
  return _impl_.displaytext_;
}
inline ::proto::HighlyStructuredMessage* URLButton::mutable_displaytext() {
  ::proto::HighlyStructuredMessage* _msg = _internal_mutable_displaytext();
  // @@protoc_insertion_point(field_mutable:proto.URLButton.displayText)
  return _msg;
}
inline void URLButton::set_allocated_displaytext(::proto::HighlyStructuredMessage* displaytext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.displaytext_;
  }
  if (displaytext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(displaytext);
    if (message_arena != submessage_arena) {
      displaytext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, displaytext, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.displaytext_ = displaytext;
  // @@protoc_insertion_point(field_set_allocated:proto.URLButton.displayText)
}

// optional .proto.HighlyStructuredMessage url = 2;
inline bool URLButton::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.url_ != nullptr);
  return value;
}
inline bool URLButton::has_url() const {
  return _internal_has_url();
}
inline void URLButton::clear_url() {
  if (_impl_.url_ != nullptr) _impl_.url_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::HighlyStructuredMessage& URLButton::_internal_url() const {
  const ::proto::HighlyStructuredMessage* p = _impl_.url_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::HighlyStructuredMessage&>(
      ::proto::_HighlyStructuredMessage_default_instance_);
}
inline const ::proto::HighlyStructuredMessage& URLButton::url() const {
  // @@protoc_insertion_point(field_get:proto.URLButton.url)
  return _internal_url();
}
inline void URLButton::unsafe_arena_set_allocated_url(
    ::proto::HighlyStructuredMessage* url) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.url_);
  }
  _impl_.url_ = url;
  if (url) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.URLButton.url)
}
inline ::proto::HighlyStructuredMessage* URLButton::release_url() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::HighlyStructuredMessage* temp = _impl_.url_;
  _impl_.url_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::HighlyStructuredMessage* URLButton::unsafe_arena_release_url() {
  // @@protoc_insertion_point(field_release:proto.URLButton.url)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::HighlyStructuredMessage* temp = _impl_.url_;
  _impl_.url_ = nullptr;
  return temp;
}
inline ::proto::HighlyStructuredMessage* URLButton::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.url_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::HighlyStructuredMessage>(GetArenaForAllocation());
    _impl_.url_ = p;
  }
  return _impl_.url_;
}
inline ::proto::HighlyStructuredMessage* URLButton::mutable_url() {
  ::proto::HighlyStructuredMessage* _msg = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:proto.URLButton.url)
  return _msg;
}
inline void URLButton::set_allocated_url(::proto::HighlyStructuredMessage* url) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.url_;
  }
  if (url) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(url);
    if (message_arena != submessage_arena) {
      url = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, url, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.url_ = url;
  // @@protoc_insertion_point(field_set_allocated:proto.URLButton.url)
}

// -------------------------------------------------------------------

// CallButton

// optional .proto.HighlyStructuredMessage displayText = 1;
inline bool CallButton::_internal_has_displaytext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.displaytext_ != nullptr);
  return value;
}
inline bool CallButton::has_displaytext() const {
  return _internal_has_displaytext();
}
inline void CallButton::clear_displaytext() {
  if (_impl_.displaytext_ != nullptr) _impl_.displaytext_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::HighlyStructuredMessage& CallButton::_internal_displaytext() const {
  const ::proto::HighlyStructuredMessage* p = _impl_.displaytext_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::HighlyStructuredMessage&>(
      ::proto::_HighlyStructuredMessage_default_instance_);
}
inline const ::proto::HighlyStructuredMessage& CallButton::displaytext() const {
  // @@protoc_insertion_point(field_get:proto.CallButton.displayText)
  return _internal_displaytext();
}
inline void CallButton::unsafe_arena_set_allocated_displaytext(
    ::proto::HighlyStructuredMessage* displaytext) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.displaytext_);
  }
  _impl_.displaytext_ = displaytext;
  if (displaytext) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.CallButton.displayText)
}
inline ::proto::HighlyStructuredMessage* CallButton::release_displaytext() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::HighlyStructuredMessage* temp = _impl_.displaytext_;
  _impl_.displaytext_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::HighlyStructuredMessage* CallButton::unsafe_arena_release_displaytext() {
  // @@protoc_insertion_point(field_release:proto.CallButton.displayText)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::HighlyStructuredMessage* temp = _impl_.displaytext_;
  _impl_.displaytext_ = nullptr;
  return temp;
}
inline ::proto::HighlyStructuredMessage* CallButton::_internal_mutable_displaytext() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.displaytext_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::HighlyStructuredMessage>(GetArenaForAllocation());
    _impl_.displaytext_ = p;
  }
  return _impl_.displaytext_;
}
inline ::proto::HighlyStructuredMessage* CallButton::mutable_displaytext() {
  ::proto::HighlyStructuredMessage* _msg = _internal_mutable_displaytext();
  // @@protoc_insertion_point(field_mutable:proto.CallButton.displayText)
  return _msg;
}
inline void CallButton::set_allocated_displaytext(::proto::HighlyStructuredMessage* displaytext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.displaytext_;
  }
  if (displaytext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(displaytext);
    if (message_arena != submessage_arena) {
      displaytext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, displaytext, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.displaytext_ = displaytext;
  // @@protoc_insertion_point(field_set_allocated:proto.CallButton.displayText)
}

// optional .proto.HighlyStructuredMessage phoneNumber = 2;
inline bool CallButton::_internal_has_phonenumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.phonenumber_ != nullptr);
  return value;
}
inline bool CallButton::has_phonenumber() const {
  return _internal_has_phonenumber();
}
inline void CallButton::clear_phonenumber() {
  if (_impl_.phonenumber_ != nullptr) _impl_.phonenumber_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::HighlyStructuredMessage& CallButton::_internal_phonenumber() const {
  const ::proto::HighlyStructuredMessage* p = _impl_.phonenumber_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::HighlyStructuredMessage&>(
      ::proto::_HighlyStructuredMessage_default_instance_);
}
inline const ::proto::HighlyStructuredMessage& CallButton::phonenumber() const {
  // @@protoc_insertion_point(field_get:proto.CallButton.phoneNumber)
  return _internal_phonenumber();
}
inline void CallButton::unsafe_arena_set_allocated_phonenumber(
    ::proto::HighlyStructuredMessage* phonenumber) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phonenumber_);
  }
  _impl_.phonenumber_ = phonenumber;
  if (phonenumber) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.CallButton.phoneNumber)
}
inline ::proto::HighlyStructuredMessage* CallButton::release_phonenumber() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::HighlyStructuredMessage* temp = _impl_.phonenumber_;
  _impl_.phonenumber_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::HighlyStructuredMessage* CallButton::unsafe_arena_release_phonenumber() {
  // @@protoc_insertion_point(field_release:proto.CallButton.phoneNumber)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::HighlyStructuredMessage* temp = _impl_.phonenumber_;
  _impl_.phonenumber_ = nullptr;
  return temp;
}
inline ::proto::HighlyStructuredMessage* CallButton::_internal_mutable_phonenumber() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.phonenumber_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::HighlyStructuredMessage>(GetArenaForAllocation());
    _impl_.phonenumber_ = p;
  }
  return _impl_.phonenumber_;
}
inline ::proto::HighlyStructuredMessage* CallButton::mutable_phonenumber() {
  ::proto::HighlyStructuredMessage* _msg = _internal_mutable_phonenumber();
  // @@protoc_insertion_point(field_mutable:proto.CallButton.phoneNumber)
  return _msg;
}
inline void CallButton::set_allocated_phonenumber(::proto::HighlyStructuredMessage* phonenumber) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phonenumber_;
  }
  if (phonenumber) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phonenumber);
    if (message_arena != submessage_arena) {
      phonenumber = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phonenumber, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.phonenumber_ = phonenumber;
  // @@protoc_insertion_point(field_set_allocated:proto.CallButton.phoneNumber)
}

// -------------------------------------------------------------------

// TemplateButton

// optional uint32 index = 4;
inline bool TemplateButton::_internal_has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TemplateButton::has_index() const {
  return _internal_has_index();
}
inline void TemplateButton::clear_index() {
  _impl_.index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t TemplateButton::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t TemplateButton::index() const {
  // @@protoc_insertion_point(field_get:proto.TemplateButton.index)
  return _internal_index();
}
inline void TemplateButton::_internal_set_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.index_ = value;
}
inline void TemplateButton::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:proto.TemplateButton.index)
}

// .proto.QuickReplyButton quickReplyButton = 1;
inline bool TemplateButton::_internal_has_quickreplybutton() const {
  return button_case() == kQuickReplyButton;
}
inline bool TemplateButton::has_quickreplybutton() const {
  return _internal_has_quickreplybutton();
}
inline void TemplateButton::set_has_quickreplybutton() {
  _impl_._oneof_case_[0] = kQuickReplyButton;
}
inline void TemplateButton::clear_quickreplybutton() {
  if (_internal_has_quickreplybutton()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.button_.quickreplybutton_;
    }
    clear_has_button();
  }
}
inline ::proto::QuickReplyButton* TemplateButton::release_quickreplybutton() {
  // @@protoc_insertion_point(field_release:proto.TemplateButton.quickReplyButton)
  if (_internal_has_quickreplybutton()) {
    clear_has_button();
    ::proto::QuickReplyButton* temp = _impl_.button_.quickreplybutton_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.button_.quickreplybutton_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::QuickReplyButton& TemplateButton::_internal_quickreplybutton() const {
  return _internal_has_quickreplybutton()
      ? *_impl_.button_.quickreplybutton_
      : reinterpret_cast< ::proto::QuickReplyButton&>(::proto::_QuickReplyButton_default_instance_);
}
inline const ::proto::QuickReplyButton& TemplateButton::quickreplybutton() const {
  // @@protoc_insertion_point(field_get:proto.TemplateButton.quickReplyButton)
  return _internal_quickreplybutton();
}
inline ::proto::QuickReplyButton* TemplateButton::unsafe_arena_release_quickreplybutton() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TemplateButton.quickReplyButton)
  if (_internal_has_quickreplybutton()) {
    clear_has_button();
    ::proto::QuickReplyButton* temp = _impl_.button_.quickreplybutton_;
    _impl_.button_.quickreplybutton_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TemplateButton::unsafe_arena_set_allocated_quickreplybutton(::proto::QuickReplyButton* quickreplybutton) {
  clear_button();
  if (quickreplybutton) {
    set_has_quickreplybutton();
    _impl_.button_.quickreplybutton_ = quickreplybutton;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TemplateButton.quickReplyButton)
}
inline ::proto::QuickReplyButton* TemplateButton::_internal_mutable_quickreplybutton() {
  if (!_internal_has_quickreplybutton()) {
    clear_button();
    set_has_quickreplybutton();
    _impl_.button_.quickreplybutton_ = CreateMaybeMessage< ::proto::QuickReplyButton >(GetArenaForAllocation());
  }
  return _impl_.button_.quickreplybutton_;
}
inline ::proto::QuickReplyButton* TemplateButton::mutable_quickreplybutton() {
  ::proto::QuickReplyButton* _msg = _internal_mutable_quickreplybutton();
  // @@protoc_insertion_point(field_mutable:proto.TemplateButton.quickReplyButton)
  return _msg;
}

// .proto.URLButton urlButton = 2;
inline bool TemplateButton::_internal_has_urlbutton() const {
  return button_case() == kUrlButton;
}
inline bool TemplateButton::has_urlbutton() const {
  return _internal_has_urlbutton();
}
inline void TemplateButton::set_has_urlbutton() {
  _impl_._oneof_case_[0] = kUrlButton;
}
inline void TemplateButton::clear_urlbutton() {
  if (_internal_has_urlbutton()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.button_.urlbutton_;
    }
    clear_has_button();
  }
}
inline ::proto::URLButton* TemplateButton::release_urlbutton() {
  // @@protoc_insertion_point(field_release:proto.TemplateButton.urlButton)
  if (_internal_has_urlbutton()) {
    clear_has_button();
    ::proto::URLButton* temp = _impl_.button_.urlbutton_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.button_.urlbutton_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::URLButton& TemplateButton::_internal_urlbutton() const {
  return _internal_has_urlbutton()
      ? *_impl_.button_.urlbutton_
      : reinterpret_cast< ::proto::URLButton&>(::proto::_URLButton_default_instance_);
}
inline const ::proto::URLButton& TemplateButton::urlbutton() const {
  // @@protoc_insertion_point(field_get:proto.TemplateButton.urlButton)
  return _internal_urlbutton();
}
inline ::proto::URLButton* TemplateButton::unsafe_arena_release_urlbutton() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TemplateButton.urlButton)
  if (_internal_has_urlbutton()) {
    clear_has_button();
    ::proto::URLButton* temp = _impl_.button_.urlbutton_;
    _impl_.button_.urlbutton_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TemplateButton::unsafe_arena_set_allocated_urlbutton(::proto::URLButton* urlbutton) {
  clear_button();
  if (urlbutton) {
    set_has_urlbutton();
    _impl_.button_.urlbutton_ = urlbutton;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TemplateButton.urlButton)
}
inline ::proto::URLButton* TemplateButton::_internal_mutable_urlbutton() {
  if (!_internal_has_urlbutton()) {
    clear_button();
    set_has_urlbutton();
    _impl_.button_.urlbutton_ = CreateMaybeMessage< ::proto::URLButton >(GetArenaForAllocation());
  }
  return _impl_.button_.urlbutton_;
}
inline ::proto::URLButton* TemplateButton::mutable_urlbutton() {
  ::proto::URLButton* _msg = _internal_mutable_urlbutton();
  // @@protoc_insertion_point(field_mutable:proto.TemplateButton.urlButton)
  return _msg;
}

// .proto.CallButton callButton = 3;
inline bool TemplateButton::_internal_has_callbutton() const {
  return button_case() == kCallButton;
}
inline bool TemplateButton::has_callbutton() const {
  return _internal_has_callbutton();
}
inline void TemplateButton::set_has_callbutton() {
  _impl_._oneof_case_[0] = kCallButton;
}
inline void TemplateButton::clear_callbutton() {
  if (_internal_has_callbutton()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.button_.callbutton_;
    }
    clear_has_button();
  }
}
inline ::proto::CallButton* TemplateButton::release_callbutton() {
  // @@protoc_insertion_point(field_release:proto.TemplateButton.callButton)
  if (_internal_has_callbutton()) {
    clear_has_button();
    ::proto::CallButton* temp = _impl_.button_.callbutton_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.button_.callbutton_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CallButton& TemplateButton::_internal_callbutton() const {
  return _internal_has_callbutton()
      ? *_impl_.button_.callbutton_
      : reinterpret_cast< ::proto::CallButton&>(::proto::_CallButton_default_instance_);
}
inline const ::proto::CallButton& TemplateButton::callbutton() const {
  // @@protoc_insertion_point(field_get:proto.TemplateButton.callButton)
  return _internal_callbutton();
}
inline ::proto::CallButton* TemplateButton::unsafe_arena_release_callbutton() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TemplateButton.callButton)
  if (_internal_has_callbutton()) {
    clear_has_button();
    ::proto::CallButton* temp = _impl_.button_.callbutton_;
    _impl_.button_.callbutton_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TemplateButton::unsafe_arena_set_allocated_callbutton(::proto::CallButton* callbutton) {
  clear_button();
  if (callbutton) {
    set_has_callbutton();
    _impl_.button_.callbutton_ = callbutton;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TemplateButton.callButton)
}
inline ::proto::CallButton* TemplateButton::_internal_mutable_callbutton() {
  if (!_internal_has_callbutton()) {
    clear_button();
    set_has_callbutton();
    _impl_.button_.callbutton_ = CreateMaybeMessage< ::proto::CallButton >(GetArenaForAllocation());
  }
  return _impl_.button_.callbutton_;
}
inline ::proto::CallButton* TemplateButton::mutable_callbutton() {
  ::proto::CallButton* _msg = _internal_mutable_callbutton();
  // @@protoc_insertion_point(field_mutable:proto.TemplateButton.callButton)
  return _msg;
}

inline bool TemplateButton::has_button() const {
  return button_case() != BUTTON_NOT_SET;
}
inline void TemplateButton::clear_has_button() {
  _impl_._oneof_case_[0] = BUTTON_NOT_SET;
}
inline TemplateButton::ButtonCase TemplateButton::button_case() const {
  return TemplateButton::ButtonCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Location

// optional double degreesLatitude = 1;
inline bool Location::_internal_has_degreeslatitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Location::has_degreeslatitude() const {
  return _internal_has_degreeslatitude();
}
inline void Location::clear_degreeslatitude() {
  _impl_.degreeslatitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Location::_internal_degreeslatitude() const {
  return _impl_.degreeslatitude_;
}
inline double Location::degreeslatitude() const {
  // @@protoc_insertion_point(field_get:proto.Location.degreesLatitude)
  return _internal_degreeslatitude();
}
inline void Location::_internal_set_degreeslatitude(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.degreeslatitude_ = value;
}
inline void Location::set_degreeslatitude(double value) {
  _internal_set_degreeslatitude(value);
  // @@protoc_insertion_point(field_set:proto.Location.degreesLatitude)
}

// optional double degreesLongitude = 2;
inline bool Location::_internal_has_degreeslongitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Location::has_degreeslongitude() const {
  return _internal_has_degreeslongitude();
}
inline void Location::clear_degreeslongitude() {
  _impl_.degreeslongitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Location::_internal_degreeslongitude() const {
  return _impl_.degreeslongitude_;
}
inline double Location::degreeslongitude() const {
  // @@protoc_insertion_point(field_get:proto.Location.degreesLongitude)
  return _internal_degreeslongitude();
}
inline void Location::_internal_set_degreeslongitude(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.degreeslongitude_ = value;
}
inline void Location::set_degreeslongitude(double value) {
  _internal_set_degreeslongitude(value);
  // @@protoc_insertion_point(field_set:proto.Location.degreesLongitude)
}

// optional string name = 3;
inline bool Location::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Location::has_name() const {
  return _internal_has_name();
}
inline void Location::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Location::name() const {
  // @@protoc_insertion_point(field_get:proto.Location.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Location.name)
}
inline std::string* Location::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.Location.name)
  return _s;
}
inline const std::string& Location::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Location::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Location::release_name() {
  // @@protoc_insertion_point(field_release:proto.Location.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Location::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Location.name)
}

// -------------------------------------------------------------------

// Point

// optional int32 xDeprecated = 1;
inline bool Point::_internal_has_xdeprecated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Point::has_xdeprecated() const {
  return _internal_has_xdeprecated();
}
inline void Point::clear_xdeprecated() {
  _impl_.xdeprecated_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Point::_internal_xdeprecated() const {
  return _impl_.xdeprecated_;
}
inline int32_t Point::xdeprecated() const {
  // @@protoc_insertion_point(field_get:proto.Point.xDeprecated)
  return _internal_xdeprecated();
}
inline void Point::_internal_set_xdeprecated(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.xdeprecated_ = value;
}
inline void Point::set_xdeprecated(int32_t value) {
  _internal_set_xdeprecated(value);
  // @@protoc_insertion_point(field_set:proto.Point.xDeprecated)
}

// optional int32 yDeprecated = 2;
inline bool Point::_internal_has_ydeprecated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Point::has_ydeprecated() const {
  return _internal_has_ydeprecated();
}
inline void Point::clear_ydeprecated() {
  _impl_.ydeprecated_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Point::_internal_ydeprecated() const {
  return _impl_.ydeprecated_;
}
inline int32_t Point::ydeprecated() const {
  // @@protoc_insertion_point(field_get:proto.Point.yDeprecated)
  return _internal_ydeprecated();
}
inline void Point::_internal_set_ydeprecated(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ydeprecated_ = value;
}
inline void Point::set_ydeprecated(int32_t value) {
  _internal_set_ydeprecated(value);
  // @@protoc_insertion_point(field_set:proto.Point.yDeprecated)
}

// optional double x = 3;
inline bool Point::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Point::has_x() const {
  return _internal_has_x();
}
inline void Point::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Point::_internal_x() const {
  return _impl_.x_;
}
inline double Point::x() const {
  // @@protoc_insertion_point(field_get:proto.Point.x)
  return _internal_x();
}
inline void Point::_internal_set_x(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.x_ = value;
}
inline void Point::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:proto.Point.x)
}

// optional double y = 4;
inline bool Point::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Point::has_y() const {
  return _internal_has_y();
}
inline void Point::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double Point::_internal_y() const {
  return _impl_.y_;
}
inline double Point::y() const {
  // @@protoc_insertion_point(field_get:proto.Point.y)
  return _internal_y();
}
inline void Point::_internal_set_y(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.y_ = value;
}
inline void Point::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:proto.Point.y)
}

// -------------------------------------------------------------------

// InteractiveAnnotation

// repeated .proto.Point polygonVertices = 1;
inline int InteractiveAnnotation::_internal_polygonvertices_size() const {
  return _impl_.polygonvertices_.size();
}
inline int InteractiveAnnotation::polygonvertices_size() const {
  return _internal_polygonvertices_size();
}
inline void InteractiveAnnotation::clear_polygonvertices() {
  _impl_.polygonvertices_.Clear();
}
inline ::proto::Point* InteractiveAnnotation::mutable_polygonvertices(int index) {
  // @@protoc_insertion_point(field_mutable:proto.InteractiveAnnotation.polygonVertices)
  return _impl_.polygonvertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Point >*
InteractiveAnnotation::mutable_polygonvertices() {
  // @@protoc_insertion_point(field_mutable_list:proto.InteractiveAnnotation.polygonVertices)
  return &_impl_.polygonvertices_;
}
inline const ::proto::Point& InteractiveAnnotation::_internal_polygonvertices(int index) const {
  return _impl_.polygonvertices_.Get(index);
}
inline const ::proto::Point& InteractiveAnnotation::polygonvertices(int index) const {
  // @@protoc_insertion_point(field_get:proto.InteractiveAnnotation.polygonVertices)
  return _internal_polygonvertices(index);
}
inline ::proto::Point* InteractiveAnnotation::_internal_add_polygonvertices() {
  return _impl_.polygonvertices_.Add();
}
inline ::proto::Point* InteractiveAnnotation::add_polygonvertices() {
  ::proto::Point* _add = _internal_add_polygonvertices();
  // @@protoc_insertion_point(field_add:proto.InteractiveAnnotation.polygonVertices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Point >&
InteractiveAnnotation::polygonvertices() const {
  // @@protoc_insertion_point(field_list:proto.InteractiveAnnotation.polygonVertices)
  return _impl_.polygonvertices_;
}

// .proto.Location location = 2;
inline bool InteractiveAnnotation::_internal_has_location() const {
  return action_case() == kLocation;
}
inline bool InteractiveAnnotation::has_location() const {
  return _internal_has_location();
}
inline void InteractiveAnnotation::set_has_location() {
  _impl_._oneof_case_[0] = kLocation;
}
inline void InteractiveAnnotation::clear_location() {
  if (_internal_has_location()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.location_;
    }
    clear_has_action();
  }
}
inline ::proto::Location* InteractiveAnnotation::release_location() {
  // @@protoc_insertion_point(field_release:proto.InteractiveAnnotation.location)
  if (_internal_has_location()) {
    clear_has_action();
    ::proto::Location* temp = _impl_.action_.location_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.location_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::Location& InteractiveAnnotation::_internal_location() const {
  return _internal_has_location()
      ? *_impl_.action_.location_
      : reinterpret_cast< ::proto::Location&>(::proto::_Location_default_instance_);
}
inline const ::proto::Location& InteractiveAnnotation::location() const {
  // @@protoc_insertion_point(field_get:proto.InteractiveAnnotation.location)
  return _internal_location();
}
inline ::proto::Location* InteractiveAnnotation::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.InteractiveAnnotation.location)
  if (_internal_has_location()) {
    clear_has_action();
    ::proto::Location* temp = _impl_.action_.location_;
    _impl_.action_.location_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InteractiveAnnotation::unsafe_arena_set_allocated_location(::proto::Location* location) {
  clear_action();
  if (location) {
    set_has_location();
    _impl_.action_.location_ = location;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.InteractiveAnnotation.location)
}
inline ::proto::Location* InteractiveAnnotation::_internal_mutable_location() {
  if (!_internal_has_location()) {
    clear_action();
    set_has_location();
    _impl_.action_.location_ = CreateMaybeMessage< ::proto::Location >(GetArenaForAllocation());
  }
  return _impl_.action_.location_;
}
inline ::proto::Location* InteractiveAnnotation::mutable_location() {
  ::proto::Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:proto.InteractiveAnnotation.location)
  return _msg;
}

inline bool InteractiveAnnotation::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void InteractiveAnnotation::clear_has_action() {
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline InteractiveAnnotation::ActionCase InteractiveAnnotation::action_case() const {
  return InteractiveAnnotation::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DeviceListMetadata

// optional bytes senderKeyHash = 1;
inline bool DeviceListMetadata::_internal_has_senderkeyhash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceListMetadata::has_senderkeyhash() const {
  return _internal_has_senderkeyhash();
}
inline void DeviceListMetadata::clear_senderkeyhash() {
  _impl_.senderkeyhash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceListMetadata::senderkeyhash() const {
  // @@protoc_insertion_point(field_get:proto.DeviceListMetadata.senderKeyHash)
  return _internal_senderkeyhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceListMetadata::set_senderkeyhash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.senderkeyhash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DeviceListMetadata.senderKeyHash)
}
inline std::string* DeviceListMetadata::mutable_senderkeyhash() {
  std::string* _s = _internal_mutable_senderkeyhash();
  // @@protoc_insertion_point(field_mutable:proto.DeviceListMetadata.senderKeyHash)
  return _s;
}
inline const std::string& DeviceListMetadata::_internal_senderkeyhash() const {
  return _impl_.senderkeyhash_.Get();
}
inline void DeviceListMetadata::_internal_set_senderkeyhash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.senderkeyhash_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceListMetadata::_internal_mutable_senderkeyhash() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.senderkeyhash_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceListMetadata::release_senderkeyhash() {
  // @@protoc_insertion_point(field_release:proto.DeviceListMetadata.senderKeyHash)
  if (!_internal_has_senderkeyhash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.senderkeyhash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.senderkeyhash_.IsDefault()) {
    _impl_.senderkeyhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceListMetadata::set_allocated_senderkeyhash(std::string* senderkeyhash) {
  if (senderkeyhash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.senderkeyhash_.SetAllocated(senderkeyhash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.senderkeyhash_.IsDefault()) {
    _impl_.senderkeyhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DeviceListMetadata.senderKeyHash)
}

// optional uint64 senderTimestamp = 2;
inline bool DeviceListMetadata::_internal_has_sendertimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceListMetadata::has_sendertimestamp() const {
  return _internal_has_sendertimestamp();
}
inline void DeviceListMetadata::clear_sendertimestamp() {
  _impl_.sendertimestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t DeviceListMetadata::_internal_sendertimestamp() const {
  return _impl_.sendertimestamp_;
}
inline uint64_t DeviceListMetadata::sendertimestamp() const {
  // @@protoc_insertion_point(field_get:proto.DeviceListMetadata.senderTimestamp)
  return _internal_sendertimestamp();
}
inline void DeviceListMetadata::_internal_set_sendertimestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sendertimestamp_ = value;
}
inline void DeviceListMetadata::set_sendertimestamp(uint64_t value) {
  _internal_set_sendertimestamp(value);
  // @@protoc_insertion_point(field_set:proto.DeviceListMetadata.senderTimestamp)
}

// optional bytes recipientKeyHash = 8;
inline bool DeviceListMetadata::_internal_has_recipientkeyhash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceListMetadata::has_recipientkeyhash() const {
  return _internal_has_recipientkeyhash();
}
inline void DeviceListMetadata::clear_recipientkeyhash() {
  _impl_.recipientkeyhash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceListMetadata::recipientkeyhash() const {
  // @@protoc_insertion_point(field_get:proto.DeviceListMetadata.recipientKeyHash)
  return _internal_recipientkeyhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceListMetadata::set_recipientkeyhash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.recipientkeyhash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DeviceListMetadata.recipientKeyHash)
}
inline std::string* DeviceListMetadata::mutable_recipientkeyhash() {
  std::string* _s = _internal_mutable_recipientkeyhash();
  // @@protoc_insertion_point(field_mutable:proto.DeviceListMetadata.recipientKeyHash)
  return _s;
}
inline const std::string& DeviceListMetadata::_internal_recipientkeyhash() const {
  return _impl_.recipientkeyhash_.Get();
}
inline void DeviceListMetadata::_internal_set_recipientkeyhash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.recipientkeyhash_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceListMetadata::_internal_mutable_recipientkeyhash() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.recipientkeyhash_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceListMetadata::release_recipientkeyhash() {
  // @@protoc_insertion_point(field_release:proto.DeviceListMetadata.recipientKeyHash)
  if (!_internal_has_recipientkeyhash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.recipientkeyhash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recipientkeyhash_.IsDefault()) {
    _impl_.recipientkeyhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceListMetadata::set_allocated_recipientkeyhash(std::string* recipientkeyhash) {
  if (recipientkeyhash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.recipientkeyhash_.SetAllocated(recipientkeyhash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recipientkeyhash_.IsDefault()) {
    _impl_.recipientkeyhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DeviceListMetadata.recipientKeyHash)
}

// optional uint64 recipientTimestamp = 9;
inline bool DeviceListMetadata::_internal_has_recipienttimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DeviceListMetadata::has_recipienttimestamp() const {
  return _internal_has_recipienttimestamp();
}
inline void DeviceListMetadata::clear_recipienttimestamp() {
  _impl_.recipienttimestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t DeviceListMetadata::_internal_recipienttimestamp() const {
  return _impl_.recipienttimestamp_;
}
inline uint64_t DeviceListMetadata::recipienttimestamp() const {
  // @@protoc_insertion_point(field_get:proto.DeviceListMetadata.recipientTimestamp)
  return _internal_recipienttimestamp();
}
inline void DeviceListMetadata::_internal_set_recipienttimestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.recipienttimestamp_ = value;
}
inline void DeviceListMetadata::set_recipienttimestamp(uint64_t value) {
  _internal_set_recipienttimestamp(value);
  // @@protoc_insertion_point(field_set:proto.DeviceListMetadata.recipientTimestamp)
}

// -------------------------------------------------------------------

// MessageContextInfo

// optional .proto.DeviceListMetadata deviceListMetadata = 1;
inline bool MessageContextInfo::_internal_has_devicelistmetadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.devicelistmetadata_ != nullptr);
  return value;
}
inline bool MessageContextInfo::has_devicelistmetadata() const {
  return _internal_has_devicelistmetadata();
}
inline void MessageContextInfo::clear_devicelistmetadata() {
  if (_impl_.devicelistmetadata_ != nullptr) _impl_.devicelistmetadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::DeviceListMetadata& MessageContextInfo::_internal_devicelistmetadata() const {
  const ::proto::DeviceListMetadata* p = _impl_.devicelistmetadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::DeviceListMetadata&>(
      ::proto::_DeviceListMetadata_default_instance_);
}
inline const ::proto::DeviceListMetadata& MessageContextInfo::devicelistmetadata() const {
  // @@protoc_insertion_point(field_get:proto.MessageContextInfo.deviceListMetadata)
  return _internal_devicelistmetadata();
}
inline void MessageContextInfo::unsafe_arena_set_allocated_devicelistmetadata(
    ::proto::DeviceListMetadata* devicelistmetadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.devicelistmetadata_);
  }
  _impl_.devicelistmetadata_ = devicelistmetadata;
  if (devicelistmetadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.MessageContextInfo.deviceListMetadata)
}
inline ::proto::DeviceListMetadata* MessageContextInfo::release_devicelistmetadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::DeviceListMetadata* temp = _impl_.devicelistmetadata_;
  _impl_.devicelistmetadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::DeviceListMetadata* MessageContextInfo::unsafe_arena_release_devicelistmetadata() {
  // @@protoc_insertion_point(field_release:proto.MessageContextInfo.deviceListMetadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::DeviceListMetadata* temp = _impl_.devicelistmetadata_;
  _impl_.devicelistmetadata_ = nullptr;
  return temp;
}
inline ::proto::DeviceListMetadata* MessageContextInfo::_internal_mutable_devicelistmetadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.devicelistmetadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::DeviceListMetadata>(GetArenaForAllocation());
    _impl_.devicelistmetadata_ = p;
  }
  return _impl_.devicelistmetadata_;
}
inline ::proto::DeviceListMetadata* MessageContextInfo::mutable_devicelistmetadata() {
  ::proto::DeviceListMetadata* _msg = _internal_mutable_devicelistmetadata();
  // @@protoc_insertion_point(field_mutable:proto.MessageContextInfo.deviceListMetadata)
  return _msg;
}
inline void MessageContextInfo::set_allocated_devicelistmetadata(::proto::DeviceListMetadata* devicelistmetadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.devicelistmetadata_;
  }
  if (devicelistmetadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(devicelistmetadata);
    if (message_arena != submessage_arena) {
      devicelistmetadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, devicelistmetadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.devicelistmetadata_ = devicelistmetadata;
  // @@protoc_insertion_point(field_set_allocated:proto.MessageContextInfo.deviceListMetadata)
}

// -------------------------------------------------------------------

// AdReplyInfo

// optional string advertiserName = 1;
inline bool AdReplyInfo::_internal_has_advertisername() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AdReplyInfo::has_advertisername() const {
  return _internal_has_advertisername();
}
inline void AdReplyInfo::clear_advertisername() {
  _impl_.advertisername_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AdReplyInfo::advertisername() const {
  // @@protoc_insertion_point(field_get:proto.AdReplyInfo.advertiserName)
  return _internal_advertisername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdReplyInfo::set_advertisername(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.advertisername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.AdReplyInfo.advertiserName)
}
inline std::string* AdReplyInfo::mutable_advertisername() {
  std::string* _s = _internal_mutable_advertisername();
  // @@protoc_insertion_point(field_mutable:proto.AdReplyInfo.advertiserName)
  return _s;
}
inline const std::string& AdReplyInfo::_internal_advertisername() const {
  return _impl_.advertisername_.Get();
}
inline void AdReplyInfo::_internal_set_advertisername(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.advertisername_.Set(value, GetArenaForAllocation());
}
inline std::string* AdReplyInfo::_internal_mutable_advertisername() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.advertisername_.Mutable(GetArenaForAllocation());
}
inline std::string* AdReplyInfo::release_advertisername() {
  // @@protoc_insertion_point(field_release:proto.AdReplyInfo.advertiserName)
  if (!_internal_has_advertisername()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.advertisername_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.advertisername_.IsDefault()) {
    _impl_.advertisername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdReplyInfo::set_allocated_advertisername(std::string* advertisername) {
  if (advertisername != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.advertisername_.SetAllocated(advertisername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.advertisername_.IsDefault()) {
    _impl_.advertisername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.AdReplyInfo.advertiserName)
}

// optional .proto.AdReplyInfo.AdReplyInfoMediaType mediaType = 2;
inline bool AdReplyInfo::_internal_has_mediatype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AdReplyInfo::has_mediatype() const {
  return _internal_has_mediatype();
}
inline void AdReplyInfo::clear_mediatype() {
  _impl_.mediatype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::proto::AdReplyInfo_AdReplyInfoMediaType AdReplyInfo::_internal_mediatype() const {
  return static_cast< ::proto::AdReplyInfo_AdReplyInfoMediaType >(_impl_.mediatype_);
}
inline ::proto::AdReplyInfo_AdReplyInfoMediaType AdReplyInfo::mediatype() const {
  // @@protoc_insertion_point(field_get:proto.AdReplyInfo.mediaType)
  return _internal_mediatype();
}
inline void AdReplyInfo::_internal_set_mediatype(::proto::AdReplyInfo_AdReplyInfoMediaType value) {
  assert(::proto::AdReplyInfo_AdReplyInfoMediaType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mediatype_ = value;
}
inline void AdReplyInfo::set_mediatype(::proto::AdReplyInfo_AdReplyInfoMediaType value) {
  _internal_set_mediatype(value);
  // @@protoc_insertion_point(field_set:proto.AdReplyInfo.mediaType)
}

// optional bytes jpegThumbnail = 16;
inline bool AdReplyInfo::_internal_has_jpegthumbnail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AdReplyInfo::has_jpegthumbnail() const {
  return _internal_has_jpegthumbnail();
}
inline void AdReplyInfo::clear_jpegthumbnail() {
  _impl_.jpegthumbnail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AdReplyInfo::jpegthumbnail() const {
  // @@protoc_insertion_point(field_get:proto.AdReplyInfo.jpegThumbnail)
  return _internal_jpegthumbnail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdReplyInfo::set_jpegthumbnail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.jpegthumbnail_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.AdReplyInfo.jpegThumbnail)
}
inline std::string* AdReplyInfo::mutable_jpegthumbnail() {
  std::string* _s = _internal_mutable_jpegthumbnail();
  // @@protoc_insertion_point(field_mutable:proto.AdReplyInfo.jpegThumbnail)
  return _s;
}
inline const std::string& AdReplyInfo::_internal_jpegthumbnail() const {
  return _impl_.jpegthumbnail_.Get();
}
inline void AdReplyInfo::_internal_set_jpegthumbnail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.jpegthumbnail_.Set(value, GetArenaForAllocation());
}
inline std::string* AdReplyInfo::_internal_mutable_jpegthumbnail() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.jpegthumbnail_.Mutable(GetArenaForAllocation());
}
inline std::string* AdReplyInfo::release_jpegthumbnail() {
  // @@protoc_insertion_point(field_release:proto.AdReplyInfo.jpegThumbnail)
  if (!_internal_has_jpegthumbnail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.jpegthumbnail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jpegthumbnail_.IsDefault()) {
    _impl_.jpegthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdReplyInfo::set_allocated_jpegthumbnail(std::string* jpegthumbnail) {
  if (jpegthumbnail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.jpegthumbnail_.SetAllocated(jpegthumbnail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jpegthumbnail_.IsDefault()) {
    _impl_.jpegthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.AdReplyInfo.jpegThumbnail)
}

// optional string caption = 17;
inline bool AdReplyInfo::_internal_has_caption() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AdReplyInfo::has_caption() const {
  return _internal_has_caption();
}
inline void AdReplyInfo::clear_caption() {
  _impl_.caption_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AdReplyInfo::caption() const {
  // @@protoc_insertion_point(field_get:proto.AdReplyInfo.caption)
  return _internal_caption();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdReplyInfo::set_caption(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.caption_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.AdReplyInfo.caption)
}
inline std::string* AdReplyInfo::mutable_caption() {
  std::string* _s = _internal_mutable_caption();
  // @@protoc_insertion_point(field_mutable:proto.AdReplyInfo.caption)
  return _s;
}
inline const std::string& AdReplyInfo::_internal_caption() const {
  return _impl_.caption_.Get();
}
inline void AdReplyInfo::_internal_set_caption(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.caption_.Set(value, GetArenaForAllocation());
}
inline std::string* AdReplyInfo::_internal_mutable_caption() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.caption_.Mutable(GetArenaForAllocation());
}
inline std::string* AdReplyInfo::release_caption() {
  // @@protoc_insertion_point(field_release:proto.AdReplyInfo.caption)
  if (!_internal_has_caption()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.caption_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caption_.IsDefault()) {
    _impl_.caption_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdReplyInfo::set_allocated_caption(std::string* caption) {
  if (caption != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.caption_.SetAllocated(caption, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caption_.IsDefault()) {
    _impl_.caption_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.AdReplyInfo.caption)
}

// -------------------------------------------------------------------

// ExternalAdReplyInfo

// optional string title = 1;
inline bool ExternalAdReplyInfo::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExternalAdReplyInfo::has_title() const {
  return _internal_has_title();
}
inline void ExternalAdReplyInfo::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExternalAdReplyInfo::title() const {
  // @@protoc_insertion_point(field_get:proto.ExternalAdReplyInfo.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExternalAdReplyInfo::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ExternalAdReplyInfo.title)
}
inline std::string* ExternalAdReplyInfo::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:proto.ExternalAdReplyInfo.title)
  return _s;
}
inline const std::string& ExternalAdReplyInfo::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ExternalAdReplyInfo::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ExternalAdReplyInfo::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* ExternalAdReplyInfo::release_title() {
  // @@protoc_insertion_point(field_release:proto.ExternalAdReplyInfo.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExternalAdReplyInfo::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ExternalAdReplyInfo.title)
}

// optional string body = 2;
inline bool ExternalAdReplyInfo::_internal_has_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExternalAdReplyInfo::has_body() const {
  return _internal_has_body();
}
inline void ExternalAdReplyInfo::clear_body() {
  _impl_.body_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ExternalAdReplyInfo::body() const {
  // @@protoc_insertion_point(field_get:proto.ExternalAdReplyInfo.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExternalAdReplyInfo::set_body(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.body_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ExternalAdReplyInfo.body)
}
inline std::string* ExternalAdReplyInfo::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:proto.ExternalAdReplyInfo.body)
  return _s;
}
inline const std::string& ExternalAdReplyInfo::_internal_body() const {
  return _impl_.body_.Get();
}
inline void ExternalAdReplyInfo::_internal_set_body(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.body_.Set(value, GetArenaForAllocation());
}
inline std::string* ExternalAdReplyInfo::_internal_mutable_body() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.body_.Mutable(GetArenaForAllocation());
}
inline std::string* ExternalAdReplyInfo::release_body() {
  // @@protoc_insertion_point(field_release:proto.ExternalAdReplyInfo.body)
  if (!_internal_has_body()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.body_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExternalAdReplyInfo::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ExternalAdReplyInfo.body)
}

// optional .proto.ExternalAdReplyInfo.ExternalAdReplyInfoMediaType mediaType = 3;
inline bool ExternalAdReplyInfo::_internal_has_mediatype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ExternalAdReplyInfo::has_mediatype() const {
  return _internal_has_mediatype();
}
inline void ExternalAdReplyInfo::clear_mediatype() {
  _impl_.mediatype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::proto::ExternalAdReplyInfo_ExternalAdReplyInfoMediaType ExternalAdReplyInfo::_internal_mediatype() const {
  return static_cast< ::proto::ExternalAdReplyInfo_ExternalAdReplyInfoMediaType >(_impl_.mediatype_);
}
inline ::proto::ExternalAdReplyInfo_ExternalAdReplyInfoMediaType ExternalAdReplyInfo::mediatype() const {
  // @@protoc_insertion_point(field_get:proto.ExternalAdReplyInfo.mediaType)
  return _internal_mediatype();
}
inline void ExternalAdReplyInfo::_internal_set_mediatype(::proto::ExternalAdReplyInfo_ExternalAdReplyInfoMediaType value) {
  assert(::proto::ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.mediatype_ = value;
}
inline void ExternalAdReplyInfo::set_mediatype(::proto::ExternalAdReplyInfo_ExternalAdReplyInfoMediaType value) {
  _internal_set_mediatype(value);
  // @@protoc_insertion_point(field_set:proto.ExternalAdReplyInfo.mediaType)
}

// optional string thumbnailUrl = 4;
inline bool ExternalAdReplyInfo::_internal_has_thumbnailurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExternalAdReplyInfo::has_thumbnailurl() const {
  return _internal_has_thumbnailurl();
}
inline void ExternalAdReplyInfo::clear_thumbnailurl() {
  _impl_.thumbnailurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ExternalAdReplyInfo::thumbnailurl() const {
  // @@protoc_insertion_point(field_get:proto.ExternalAdReplyInfo.thumbnailUrl)
  return _internal_thumbnailurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExternalAdReplyInfo::set_thumbnailurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.thumbnailurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ExternalAdReplyInfo.thumbnailUrl)
}
inline std::string* ExternalAdReplyInfo::mutable_thumbnailurl() {
  std::string* _s = _internal_mutable_thumbnailurl();
  // @@protoc_insertion_point(field_mutable:proto.ExternalAdReplyInfo.thumbnailUrl)
  return _s;
}
inline const std::string& ExternalAdReplyInfo::_internal_thumbnailurl() const {
  return _impl_.thumbnailurl_.Get();
}
inline void ExternalAdReplyInfo::_internal_set_thumbnailurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.thumbnailurl_.Set(value, GetArenaForAllocation());
}
inline std::string* ExternalAdReplyInfo::_internal_mutable_thumbnailurl() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.thumbnailurl_.Mutable(GetArenaForAllocation());
}
inline std::string* ExternalAdReplyInfo::release_thumbnailurl() {
  // @@protoc_insertion_point(field_release:proto.ExternalAdReplyInfo.thumbnailUrl)
  if (!_internal_has_thumbnailurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.thumbnailurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailurl_.IsDefault()) {
    _impl_.thumbnailurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExternalAdReplyInfo::set_allocated_thumbnailurl(std::string* thumbnailurl) {
  if (thumbnailurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.thumbnailurl_.SetAllocated(thumbnailurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailurl_.IsDefault()) {
    _impl_.thumbnailurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ExternalAdReplyInfo.thumbnailUrl)
}

// optional string mediaUrl = 5;
inline bool ExternalAdReplyInfo::_internal_has_mediaurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ExternalAdReplyInfo::has_mediaurl() const {
  return _internal_has_mediaurl();
}
inline void ExternalAdReplyInfo::clear_mediaurl() {
  _impl_.mediaurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ExternalAdReplyInfo::mediaurl() const {
  // @@protoc_insertion_point(field_get:proto.ExternalAdReplyInfo.mediaUrl)
  return _internal_mediaurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExternalAdReplyInfo::set_mediaurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.mediaurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ExternalAdReplyInfo.mediaUrl)
}
inline std::string* ExternalAdReplyInfo::mutable_mediaurl() {
  std::string* _s = _internal_mutable_mediaurl();
  // @@protoc_insertion_point(field_mutable:proto.ExternalAdReplyInfo.mediaUrl)
  return _s;
}
inline const std::string& ExternalAdReplyInfo::_internal_mediaurl() const {
  return _impl_.mediaurl_.Get();
}
inline void ExternalAdReplyInfo::_internal_set_mediaurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mediaurl_.Set(value, GetArenaForAllocation());
}
inline std::string* ExternalAdReplyInfo::_internal_mutable_mediaurl() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.mediaurl_.Mutable(GetArenaForAllocation());
}
inline std::string* ExternalAdReplyInfo::release_mediaurl() {
  // @@protoc_insertion_point(field_release:proto.ExternalAdReplyInfo.mediaUrl)
  if (!_internal_has_mediaurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.mediaurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mediaurl_.IsDefault()) {
    _impl_.mediaurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExternalAdReplyInfo::set_allocated_mediaurl(std::string* mediaurl) {
  if (mediaurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.mediaurl_.SetAllocated(mediaurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mediaurl_.IsDefault()) {
    _impl_.mediaurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ExternalAdReplyInfo.mediaUrl)
}

// optional bytes thumbnail = 6;
inline bool ExternalAdReplyInfo::_internal_has_thumbnail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ExternalAdReplyInfo::has_thumbnail() const {
  return _internal_has_thumbnail();
}
inline void ExternalAdReplyInfo::clear_thumbnail() {
  _impl_.thumbnail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ExternalAdReplyInfo::thumbnail() const {
  // @@protoc_insertion_point(field_get:proto.ExternalAdReplyInfo.thumbnail)
  return _internal_thumbnail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExternalAdReplyInfo::set_thumbnail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.thumbnail_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ExternalAdReplyInfo.thumbnail)
}
inline std::string* ExternalAdReplyInfo::mutable_thumbnail() {
  std::string* _s = _internal_mutable_thumbnail();
  // @@protoc_insertion_point(field_mutable:proto.ExternalAdReplyInfo.thumbnail)
  return _s;
}
inline const std::string& ExternalAdReplyInfo::_internal_thumbnail() const {
  return _impl_.thumbnail_.Get();
}
inline void ExternalAdReplyInfo::_internal_set_thumbnail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.thumbnail_.Set(value, GetArenaForAllocation());
}
inline std::string* ExternalAdReplyInfo::_internal_mutable_thumbnail() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.thumbnail_.Mutable(GetArenaForAllocation());
}
inline std::string* ExternalAdReplyInfo::release_thumbnail() {
  // @@protoc_insertion_point(field_release:proto.ExternalAdReplyInfo.thumbnail)
  if (!_internal_has_thumbnail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.thumbnail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnail_.IsDefault()) {
    _impl_.thumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExternalAdReplyInfo::set_allocated_thumbnail(std::string* thumbnail) {
  if (thumbnail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.thumbnail_.SetAllocated(thumbnail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnail_.IsDefault()) {
    _impl_.thumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ExternalAdReplyInfo.thumbnail)
}

// optional string sourceType = 7;
inline bool ExternalAdReplyInfo::_internal_has_sourcetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ExternalAdReplyInfo::has_sourcetype() const {
  return _internal_has_sourcetype();
}
inline void ExternalAdReplyInfo::clear_sourcetype() {
  _impl_.sourcetype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ExternalAdReplyInfo::sourcetype() const {
  // @@protoc_insertion_point(field_get:proto.ExternalAdReplyInfo.sourceType)
  return _internal_sourcetype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExternalAdReplyInfo::set_sourcetype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.sourcetype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ExternalAdReplyInfo.sourceType)
}
inline std::string* ExternalAdReplyInfo::mutable_sourcetype() {
  std::string* _s = _internal_mutable_sourcetype();
  // @@protoc_insertion_point(field_mutable:proto.ExternalAdReplyInfo.sourceType)
  return _s;
}
inline const std::string& ExternalAdReplyInfo::_internal_sourcetype() const {
  return _impl_.sourcetype_.Get();
}
inline void ExternalAdReplyInfo::_internal_set_sourcetype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sourcetype_.Set(value, GetArenaForAllocation());
}
inline std::string* ExternalAdReplyInfo::_internal_mutable_sourcetype() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.sourcetype_.Mutable(GetArenaForAllocation());
}
inline std::string* ExternalAdReplyInfo::release_sourcetype() {
  // @@protoc_insertion_point(field_release:proto.ExternalAdReplyInfo.sourceType)
  if (!_internal_has_sourcetype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.sourcetype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcetype_.IsDefault()) {
    _impl_.sourcetype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExternalAdReplyInfo::set_allocated_sourcetype(std::string* sourcetype) {
  if (sourcetype != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.sourcetype_.SetAllocated(sourcetype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcetype_.IsDefault()) {
    _impl_.sourcetype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ExternalAdReplyInfo.sourceType)
}

// optional string sourceId = 8;
inline bool ExternalAdReplyInfo::_internal_has_sourceid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ExternalAdReplyInfo::has_sourceid() const {
  return _internal_has_sourceid();
}
inline void ExternalAdReplyInfo::clear_sourceid() {
  _impl_.sourceid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ExternalAdReplyInfo::sourceid() const {
  // @@protoc_insertion_point(field_get:proto.ExternalAdReplyInfo.sourceId)
  return _internal_sourceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExternalAdReplyInfo::set_sourceid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.sourceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ExternalAdReplyInfo.sourceId)
}
inline std::string* ExternalAdReplyInfo::mutable_sourceid() {
  std::string* _s = _internal_mutable_sourceid();
  // @@protoc_insertion_point(field_mutable:proto.ExternalAdReplyInfo.sourceId)
  return _s;
}
inline const std::string& ExternalAdReplyInfo::_internal_sourceid() const {
  return _impl_.sourceid_.Get();
}
inline void ExternalAdReplyInfo::_internal_set_sourceid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.sourceid_.Set(value, GetArenaForAllocation());
}
inline std::string* ExternalAdReplyInfo::_internal_mutable_sourceid() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.sourceid_.Mutable(GetArenaForAllocation());
}
inline std::string* ExternalAdReplyInfo::release_sourceid() {
  // @@protoc_insertion_point(field_release:proto.ExternalAdReplyInfo.sourceId)
  if (!_internal_has_sourceid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.sourceid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourceid_.IsDefault()) {
    _impl_.sourceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExternalAdReplyInfo::set_allocated_sourceid(std::string* sourceid) {
  if (sourceid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.sourceid_.SetAllocated(sourceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourceid_.IsDefault()) {
    _impl_.sourceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ExternalAdReplyInfo.sourceId)
}

// optional string sourceUrl = 9;
inline bool ExternalAdReplyInfo::_internal_has_sourceurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ExternalAdReplyInfo::has_sourceurl() const {
  return _internal_has_sourceurl();
}
inline void ExternalAdReplyInfo::clear_sourceurl() {
  _impl_.sourceurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ExternalAdReplyInfo::sourceurl() const {
  // @@protoc_insertion_point(field_get:proto.ExternalAdReplyInfo.sourceUrl)
  return _internal_sourceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExternalAdReplyInfo::set_sourceurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.sourceurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ExternalAdReplyInfo.sourceUrl)
}
inline std::string* ExternalAdReplyInfo::mutable_sourceurl() {
  std::string* _s = _internal_mutable_sourceurl();
  // @@protoc_insertion_point(field_mutable:proto.ExternalAdReplyInfo.sourceUrl)
  return _s;
}
inline const std::string& ExternalAdReplyInfo::_internal_sourceurl() const {
  return _impl_.sourceurl_.Get();
}
inline void ExternalAdReplyInfo::_internal_set_sourceurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.sourceurl_.Set(value, GetArenaForAllocation());
}
inline std::string* ExternalAdReplyInfo::_internal_mutable_sourceurl() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.sourceurl_.Mutable(GetArenaForAllocation());
}
inline std::string* ExternalAdReplyInfo::release_sourceurl() {
  // @@protoc_insertion_point(field_release:proto.ExternalAdReplyInfo.sourceUrl)
  if (!_internal_has_sourceurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.sourceurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourceurl_.IsDefault()) {
    _impl_.sourceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExternalAdReplyInfo::set_allocated_sourceurl(std::string* sourceurl) {
  if (sourceurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.sourceurl_.SetAllocated(sourceurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourceurl_.IsDefault()) {
    _impl_.sourceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ExternalAdReplyInfo.sourceUrl)
}

// -------------------------------------------------------------------

// ContextInfo

// optional string stanzaId = 1;
inline bool ContextInfo::_internal_has_stanzaid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContextInfo::has_stanzaid() const {
  return _internal_has_stanzaid();
}
inline void ContextInfo::clear_stanzaid() {
  _impl_.stanzaid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContextInfo::stanzaid() const {
  // @@protoc_insertion_point(field_get:proto.ContextInfo.stanzaId)
  return _internal_stanzaid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextInfo::set_stanzaid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stanzaid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ContextInfo.stanzaId)
}
inline std::string* ContextInfo::mutable_stanzaid() {
  std::string* _s = _internal_mutable_stanzaid();
  // @@protoc_insertion_point(field_mutable:proto.ContextInfo.stanzaId)
  return _s;
}
inline const std::string& ContextInfo::_internal_stanzaid() const {
  return _impl_.stanzaid_.Get();
}
inline void ContextInfo::_internal_set_stanzaid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stanzaid_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextInfo::_internal_mutable_stanzaid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stanzaid_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextInfo::release_stanzaid() {
  // @@protoc_insertion_point(field_release:proto.ContextInfo.stanzaId)
  if (!_internal_has_stanzaid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stanzaid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stanzaid_.IsDefault()) {
    _impl_.stanzaid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContextInfo::set_allocated_stanzaid(std::string* stanzaid) {
  if (stanzaid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stanzaid_.SetAllocated(stanzaid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stanzaid_.IsDefault()) {
    _impl_.stanzaid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ContextInfo.stanzaId)
}

// optional string participant = 2;
inline bool ContextInfo::_internal_has_participant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContextInfo::has_participant() const {
  return _internal_has_participant();
}
inline void ContextInfo::clear_participant() {
  _impl_.participant_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContextInfo::participant() const {
  // @@protoc_insertion_point(field_get:proto.ContextInfo.participant)
  return _internal_participant();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextInfo::set_participant(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.participant_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ContextInfo.participant)
}
inline std::string* ContextInfo::mutable_participant() {
  std::string* _s = _internal_mutable_participant();
  // @@protoc_insertion_point(field_mutable:proto.ContextInfo.participant)
  return _s;
}
inline const std::string& ContextInfo::_internal_participant() const {
  return _impl_.participant_.Get();
}
inline void ContextInfo::_internal_set_participant(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.participant_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextInfo::_internal_mutable_participant() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.participant_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextInfo::release_participant() {
  // @@protoc_insertion_point(field_release:proto.ContextInfo.participant)
  if (!_internal_has_participant()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.participant_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_.IsDefault()) {
    _impl_.participant_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContextInfo::set_allocated_participant(std::string* participant) {
  if (participant != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.participant_.SetAllocated(participant, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_.IsDefault()) {
    _impl_.participant_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ContextInfo.participant)
}

// optional .proto.Message quotedMessage = 3;
inline bool ContextInfo::_internal_has_quotedmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.quotedmessage_ != nullptr);
  return value;
}
inline bool ContextInfo::has_quotedmessage() const {
  return _internal_has_quotedmessage();
}
inline void ContextInfo::clear_quotedmessage() {
  if (_impl_.quotedmessage_ != nullptr) _impl_.quotedmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::proto::Message& ContextInfo::_internal_quotedmessage() const {
  const ::proto::Message* p = _impl_.quotedmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Message&>(
      ::proto::_Message_default_instance_);
}
inline const ::proto::Message& ContextInfo::quotedmessage() const {
  // @@protoc_insertion_point(field_get:proto.ContextInfo.quotedMessage)
  return _internal_quotedmessage();
}
inline void ContextInfo::unsafe_arena_set_allocated_quotedmessage(
    ::proto::Message* quotedmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.quotedmessage_);
  }
  _impl_.quotedmessage_ = quotedmessage;
  if (quotedmessage) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ContextInfo.quotedMessage)
}
inline ::proto::Message* ContextInfo::release_quotedmessage() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::proto::Message* temp = _impl_.quotedmessage_;
  _impl_.quotedmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Message* ContextInfo::unsafe_arena_release_quotedmessage() {
  // @@protoc_insertion_point(field_release:proto.ContextInfo.quotedMessage)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::proto::Message* temp = _impl_.quotedmessage_;
  _impl_.quotedmessage_ = nullptr;
  return temp;
}
inline ::proto::Message* ContextInfo::_internal_mutable_quotedmessage() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.quotedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Message>(GetArenaForAllocation());
    _impl_.quotedmessage_ = p;
  }
  return _impl_.quotedmessage_;
}
inline ::proto::Message* ContextInfo::mutable_quotedmessage() {
  ::proto::Message* _msg = _internal_mutable_quotedmessage();
  // @@protoc_insertion_point(field_mutable:proto.ContextInfo.quotedMessage)
  return _msg;
}
inline void ContextInfo::set_allocated_quotedmessage(::proto::Message* quotedmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.quotedmessage_;
  }
  if (quotedmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(quotedmessage);
    if (message_arena != submessage_arena) {
      quotedmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quotedmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.quotedmessage_ = quotedmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.ContextInfo.quotedMessage)
}

// optional string remoteJid = 4;
inline bool ContextInfo::_internal_has_remotejid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContextInfo::has_remotejid() const {
  return _internal_has_remotejid();
}
inline void ContextInfo::clear_remotejid() {
  _impl_.remotejid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ContextInfo::remotejid() const {
  // @@protoc_insertion_point(field_get:proto.ContextInfo.remoteJid)
  return _internal_remotejid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextInfo::set_remotejid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.remotejid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ContextInfo.remoteJid)
}
inline std::string* ContextInfo::mutable_remotejid() {
  std::string* _s = _internal_mutable_remotejid();
  // @@protoc_insertion_point(field_mutable:proto.ContextInfo.remoteJid)
  return _s;
}
inline const std::string& ContextInfo::_internal_remotejid() const {
  return _impl_.remotejid_.Get();
}
inline void ContextInfo::_internal_set_remotejid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.remotejid_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextInfo::_internal_mutable_remotejid() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.remotejid_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextInfo::release_remotejid() {
  // @@protoc_insertion_point(field_release:proto.ContextInfo.remoteJid)
  if (!_internal_has_remotejid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.remotejid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remotejid_.IsDefault()) {
    _impl_.remotejid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContextInfo::set_allocated_remotejid(std::string* remotejid) {
  if (remotejid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.remotejid_.SetAllocated(remotejid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remotejid_.IsDefault()) {
    _impl_.remotejid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ContextInfo.remoteJid)
}

// repeated string mentionedJid = 15;
inline int ContextInfo::_internal_mentionedjid_size() const {
  return _impl_.mentionedjid_.size();
}
inline int ContextInfo::mentionedjid_size() const {
  return _internal_mentionedjid_size();
}
inline void ContextInfo::clear_mentionedjid() {
  _impl_.mentionedjid_.Clear();
}
inline std::string* ContextInfo::add_mentionedjid() {
  std::string* _s = _internal_add_mentionedjid();
  // @@protoc_insertion_point(field_add_mutable:proto.ContextInfo.mentionedJid)
  return _s;
}
inline const std::string& ContextInfo::_internal_mentionedjid(int index) const {
  return _impl_.mentionedjid_.Get(index);
}
inline const std::string& ContextInfo::mentionedjid(int index) const {
  // @@protoc_insertion_point(field_get:proto.ContextInfo.mentionedJid)
  return _internal_mentionedjid(index);
}
inline std::string* ContextInfo::mutable_mentionedjid(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ContextInfo.mentionedJid)
  return _impl_.mentionedjid_.Mutable(index);
}
inline void ContextInfo::set_mentionedjid(int index, const std::string& value) {
  _impl_.mentionedjid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.ContextInfo.mentionedJid)
}
inline void ContextInfo::set_mentionedjid(int index, std::string&& value) {
  _impl_.mentionedjid_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.ContextInfo.mentionedJid)
}
inline void ContextInfo::set_mentionedjid(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.mentionedjid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.ContextInfo.mentionedJid)
}
inline void ContextInfo::set_mentionedjid(int index, const char* value, size_t size) {
  _impl_.mentionedjid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.ContextInfo.mentionedJid)
}
inline std::string* ContextInfo::_internal_add_mentionedjid() {
  return _impl_.mentionedjid_.Add();
}
inline void ContextInfo::add_mentionedjid(const std::string& value) {
  _impl_.mentionedjid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.ContextInfo.mentionedJid)
}
inline void ContextInfo::add_mentionedjid(std::string&& value) {
  _impl_.mentionedjid_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.ContextInfo.mentionedJid)
}
inline void ContextInfo::add_mentionedjid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.mentionedjid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.ContextInfo.mentionedJid)
}
inline void ContextInfo::add_mentionedjid(const char* value, size_t size) {
  _impl_.mentionedjid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.ContextInfo.mentionedJid)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ContextInfo::mentionedjid() const {
  // @@protoc_insertion_point(field_list:proto.ContextInfo.mentionedJid)
  return _impl_.mentionedjid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ContextInfo::mutable_mentionedjid() {
  // @@protoc_insertion_point(field_mutable_list:proto.ContextInfo.mentionedJid)
  return &_impl_.mentionedjid_;
}

// optional string conversionSource = 18;
inline bool ContextInfo::_internal_has_conversionsource() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ContextInfo::has_conversionsource() const {
  return _internal_has_conversionsource();
}
inline void ContextInfo::clear_conversionsource() {
  _impl_.conversionsource_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ContextInfo::conversionsource() const {
  // @@protoc_insertion_point(field_get:proto.ContextInfo.conversionSource)
  return _internal_conversionsource();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextInfo::set_conversionsource(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.conversionsource_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ContextInfo.conversionSource)
}
inline std::string* ContextInfo::mutable_conversionsource() {
  std::string* _s = _internal_mutable_conversionsource();
  // @@protoc_insertion_point(field_mutable:proto.ContextInfo.conversionSource)
  return _s;
}
inline const std::string& ContextInfo::_internal_conversionsource() const {
  return _impl_.conversionsource_.Get();
}
inline void ContextInfo::_internal_set_conversionsource(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.conversionsource_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextInfo::_internal_mutable_conversionsource() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.conversionsource_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextInfo::release_conversionsource() {
  // @@protoc_insertion_point(field_release:proto.ContextInfo.conversionSource)
  if (!_internal_has_conversionsource()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.conversionsource_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversionsource_.IsDefault()) {
    _impl_.conversionsource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContextInfo::set_allocated_conversionsource(std::string* conversionsource) {
  if (conversionsource != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.conversionsource_.SetAllocated(conversionsource, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversionsource_.IsDefault()) {
    _impl_.conversionsource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ContextInfo.conversionSource)
}

// optional bytes conversionData = 19;
inline bool ContextInfo::_internal_has_conversiondata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ContextInfo::has_conversiondata() const {
  return _internal_has_conversiondata();
}
inline void ContextInfo::clear_conversiondata() {
  _impl_.conversiondata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ContextInfo::conversiondata() const {
  // @@protoc_insertion_point(field_get:proto.ContextInfo.conversionData)
  return _internal_conversiondata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextInfo::set_conversiondata(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.conversiondata_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ContextInfo.conversionData)
}
inline std::string* ContextInfo::mutable_conversiondata() {
  std::string* _s = _internal_mutable_conversiondata();
  // @@protoc_insertion_point(field_mutable:proto.ContextInfo.conversionData)
  return _s;
}
inline const std::string& ContextInfo::_internal_conversiondata() const {
  return _impl_.conversiondata_.Get();
}
inline void ContextInfo::_internal_set_conversiondata(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.conversiondata_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextInfo::_internal_mutable_conversiondata() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.conversiondata_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextInfo::release_conversiondata() {
  // @@protoc_insertion_point(field_release:proto.ContextInfo.conversionData)
  if (!_internal_has_conversiondata()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.conversiondata_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversiondata_.IsDefault()) {
    _impl_.conversiondata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContextInfo::set_allocated_conversiondata(std::string* conversiondata) {
  if (conversiondata != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.conversiondata_.SetAllocated(conversiondata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversiondata_.IsDefault()) {
    _impl_.conversiondata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ContextInfo.conversionData)
}

// optional uint32 conversionDelaySeconds = 20;
inline bool ContextInfo::_internal_has_conversiondelayseconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ContextInfo::has_conversiondelayseconds() const {
  return _internal_has_conversiondelayseconds();
}
inline void ContextInfo::clear_conversiondelayseconds() {
  _impl_.conversiondelayseconds_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint32_t ContextInfo::_internal_conversiondelayseconds() const {
  return _impl_.conversiondelayseconds_;
}
inline uint32_t ContextInfo::conversiondelayseconds() const {
  // @@protoc_insertion_point(field_get:proto.ContextInfo.conversionDelaySeconds)
  return _internal_conversiondelayseconds();
}
inline void ContextInfo::_internal_set_conversiondelayseconds(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.conversiondelayseconds_ = value;
}
inline void ContextInfo::set_conversiondelayseconds(uint32_t value) {
  _internal_set_conversiondelayseconds(value);
  // @@protoc_insertion_point(field_set:proto.ContextInfo.conversionDelaySeconds)
}

// optional uint32 forwardingScore = 21;
inline bool ContextInfo::_internal_has_forwardingscore() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ContextInfo::has_forwardingscore() const {
  return _internal_has_forwardingscore();
}
inline void ContextInfo::clear_forwardingscore() {
  _impl_.forwardingscore_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint32_t ContextInfo::_internal_forwardingscore() const {
  return _impl_.forwardingscore_;
}
inline uint32_t ContextInfo::forwardingscore() const {
  // @@protoc_insertion_point(field_get:proto.ContextInfo.forwardingScore)
  return _internal_forwardingscore();
}
inline void ContextInfo::_internal_set_forwardingscore(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.forwardingscore_ = value;
}
inline void ContextInfo::set_forwardingscore(uint32_t value) {
  _internal_set_forwardingscore(value);
  // @@protoc_insertion_point(field_set:proto.ContextInfo.forwardingScore)
}

// optional bool isForwarded = 22;
inline bool ContextInfo::_internal_has_isforwarded() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ContextInfo::has_isforwarded() const {
  return _internal_has_isforwarded();
}
inline void ContextInfo::clear_isforwarded() {
  _impl_.isforwarded_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool ContextInfo::_internal_isforwarded() const {
  return _impl_.isforwarded_;
}
inline bool ContextInfo::isforwarded() const {
  // @@protoc_insertion_point(field_get:proto.ContextInfo.isForwarded)
  return _internal_isforwarded();
}
inline void ContextInfo::_internal_set_isforwarded(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.isforwarded_ = value;
}
inline void ContextInfo::set_isforwarded(bool value) {
  _internal_set_isforwarded(value);
  // @@protoc_insertion_point(field_set:proto.ContextInfo.isForwarded)
}

// optional .proto.AdReplyInfo quotedAd = 23;
inline bool ContextInfo::_internal_has_quotedad() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.quotedad_ != nullptr);
  return value;
}
inline bool ContextInfo::has_quotedad() const {
  return _internal_has_quotedad();
}
inline void ContextInfo::clear_quotedad() {
  if (_impl_.quotedad_ != nullptr) _impl_.quotedad_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::proto::AdReplyInfo& ContextInfo::_internal_quotedad() const {
  const ::proto::AdReplyInfo* p = _impl_.quotedad_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AdReplyInfo&>(
      ::proto::_AdReplyInfo_default_instance_);
}
inline const ::proto::AdReplyInfo& ContextInfo::quotedad() const {
  // @@protoc_insertion_point(field_get:proto.ContextInfo.quotedAd)
  return _internal_quotedad();
}
inline void ContextInfo::unsafe_arena_set_allocated_quotedad(
    ::proto::AdReplyInfo* quotedad) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.quotedad_);
  }
  _impl_.quotedad_ = quotedad;
  if (quotedad) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ContextInfo.quotedAd)
}
inline ::proto::AdReplyInfo* ContextInfo::release_quotedad() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::proto::AdReplyInfo* temp = _impl_.quotedad_;
  _impl_.quotedad_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AdReplyInfo* ContextInfo::unsafe_arena_release_quotedad() {
  // @@protoc_insertion_point(field_release:proto.ContextInfo.quotedAd)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::proto::AdReplyInfo* temp = _impl_.quotedad_;
  _impl_.quotedad_ = nullptr;
  return temp;
}
inline ::proto::AdReplyInfo* ContextInfo::_internal_mutable_quotedad() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.quotedad_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AdReplyInfo>(GetArenaForAllocation());
    _impl_.quotedad_ = p;
  }
  return _impl_.quotedad_;
}
inline ::proto::AdReplyInfo* ContextInfo::mutable_quotedad() {
  ::proto::AdReplyInfo* _msg = _internal_mutable_quotedad();
  // @@protoc_insertion_point(field_mutable:proto.ContextInfo.quotedAd)
  return _msg;
}
inline void ContextInfo::set_allocated_quotedad(::proto::AdReplyInfo* quotedad) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.quotedad_;
  }
  if (quotedad) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(quotedad);
    if (message_arena != submessage_arena) {
      quotedad = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quotedad, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.quotedad_ = quotedad;
  // @@protoc_insertion_point(field_set_allocated:proto.ContextInfo.quotedAd)
}

// optional .proto.MessageKey placeholderKey = 24;
inline bool ContextInfo::_internal_has_placeholderkey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.placeholderkey_ != nullptr);
  return value;
}
inline bool ContextInfo::has_placeholderkey() const {
  return _internal_has_placeholderkey();
}
inline void ContextInfo::clear_placeholderkey() {
  if (_impl_.placeholderkey_ != nullptr) _impl_.placeholderkey_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::proto::MessageKey& ContextInfo::_internal_placeholderkey() const {
  const ::proto::MessageKey* p = _impl_.placeholderkey_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::MessageKey&>(
      ::proto::_MessageKey_default_instance_);
}
inline const ::proto::MessageKey& ContextInfo::placeholderkey() const {
  // @@protoc_insertion_point(field_get:proto.ContextInfo.placeholderKey)
  return _internal_placeholderkey();
}
inline void ContextInfo::unsafe_arena_set_allocated_placeholderkey(
    ::proto::MessageKey* placeholderkey) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.placeholderkey_);
  }
  _impl_.placeholderkey_ = placeholderkey;
  if (placeholderkey) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ContextInfo.placeholderKey)
}
inline ::proto::MessageKey* ContextInfo::release_placeholderkey() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::proto::MessageKey* temp = _impl_.placeholderkey_;
  _impl_.placeholderkey_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::MessageKey* ContextInfo::unsafe_arena_release_placeholderkey() {
  // @@protoc_insertion_point(field_release:proto.ContextInfo.placeholderKey)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::proto::MessageKey* temp = _impl_.placeholderkey_;
  _impl_.placeholderkey_ = nullptr;
  return temp;
}
inline ::proto::MessageKey* ContextInfo::_internal_mutable_placeholderkey() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.placeholderkey_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::MessageKey>(GetArenaForAllocation());
    _impl_.placeholderkey_ = p;
  }
  return _impl_.placeholderkey_;
}
inline ::proto::MessageKey* ContextInfo::mutable_placeholderkey() {
  ::proto::MessageKey* _msg = _internal_mutable_placeholderkey();
  // @@protoc_insertion_point(field_mutable:proto.ContextInfo.placeholderKey)
  return _msg;
}
inline void ContextInfo::set_allocated_placeholderkey(::proto::MessageKey* placeholderkey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.placeholderkey_;
  }
  if (placeholderkey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(placeholderkey);
    if (message_arena != submessage_arena) {
      placeholderkey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, placeholderkey, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.placeholderkey_ = placeholderkey;
  // @@protoc_insertion_point(field_set_allocated:proto.ContextInfo.placeholderKey)
}

// optional uint32 expiration = 25;
inline bool ContextInfo::_internal_has_expiration() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ContextInfo::has_expiration() const {
  return _internal_has_expiration();
}
inline void ContextInfo::clear_expiration() {
  _impl_.expiration_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint32_t ContextInfo::_internal_expiration() const {
  return _impl_.expiration_;
}
inline uint32_t ContextInfo::expiration() const {
  // @@protoc_insertion_point(field_get:proto.ContextInfo.expiration)
  return _internal_expiration();
}
inline void ContextInfo::_internal_set_expiration(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.expiration_ = value;
}
inline void ContextInfo::set_expiration(uint32_t value) {
  _internal_set_expiration(value);
  // @@protoc_insertion_point(field_set:proto.ContextInfo.expiration)
}

// optional int64 ephemeralSettingTimestamp = 26;
inline bool ContextInfo::_internal_has_ephemeralsettingtimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ContextInfo::has_ephemeralsettingtimestamp() const {
  return _internal_has_ephemeralsettingtimestamp();
}
inline void ContextInfo::clear_ephemeralsettingtimestamp() {
  _impl_.ephemeralsettingtimestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline int64_t ContextInfo::_internal_ephemeralsettingtimestamp() const {
  return _impl_.ephemeralsettingtimestamp_;
}
inline int64_t ContextInfo::ephemeralsettingtimestamp() const {
  // @@protoc_insertion_point(field_get:proto.ContextInfo.ephemeralSettingTimestamp)
  return _internal_ephemeralsettingtimestamp();
}
inline void ContextInfo::_internal_set_ephemeralsettingtimestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.ephemeralsettingtimestamp_ = value;
}
inline void ContextInfo::set_ephemeralsettingtimestamp(int64_t value) {
  _internal_set_ephemeralsettingtimestamp(value);
  // @@protoc_insertion_point(field_set:proto.ContextInfo.ephemeralSettingTimestamp)
}

// optional bytes ephemeralSharedSecret = 27;
inline bool ContextInfo::_internal_has_ephemeralsharedsecret() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ContextInfo::has_ephemeralsharedsecret() const {
  return _internal_has_ephemeralsharedsecret();
}
inline void ContextInfo::clear_ephemeralsharedsecret() {
  _impl_.ephemeralsharedsecret_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ContextInfo::ephemeralsharedsecret() const {
  // @@protoc_insertion_point(field_get:proto.ContextInfo.ephemeralSharedSecret)
  return _internal_ephemeralsharedsecret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextInfo::set_ephemeralsharedsecret(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.ephemeralsharedsecret_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ContextInfo.ephemeralSharedSecret)
}
inline std::string* ContextInfo::mutable_ephemeralsharedsecret() {
  std::string* _s = _internal_mutable_ephemeralsharedsecret();
  // @@protoc_insertion_point(field_mutable:proto.ContextInfo.ephemeralSharedSecret)
  return _s;
}
inline const std::string& ContextInfo::_internal_ephemeralsharedsecret() const {
  return _impl_.ephemeralsharedsecret_.Get();
}
inline void ContextInfo::_internal_set_ephemeralsharedsecret(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.ephemeralsharedsecret_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextInfo::_internal_mutable_ephemeralsharedsecret() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.ephemeralsharedsecret_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextInfo::release_ephemeralsharedsecret() {
  // @@protoc_insertion_point(field_release:proto.ContextInfo.ephemeralSharedSecret)
  if (!_internal_has_ephemeralsharedsecret()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.ephemeralsharedsecret_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ephemeralsharedsecret_.IsDefault()) {
    _impl_.ephemeralsharedsecret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContextInfo::set_allocated_ephemeralsharedsecret(std::string* ephemeralsharedsecret) {
  if (ephemeralsharedsecret != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.ephemeralsharedsecret_.SetAllocated(ephemeralsharedsecret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ephemeralsharedsecret_.IsDefault()) {
    _impl_.ephemeralsharedsecret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ContextInfo.ephemeralSharedSecret)
}

// optional .proto.ExternalAdReplyInfo externalAdReply = 28;
inline bool ContextInfo::_internal_has_externaladreply() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.externaladreply_ != nullptr);
  return value;
}
inline bool ContextInfo::has_externaladreply() const {
  return _internal_has_externaladreply();
}
inline void ContextInfo::clear_externaladreply() {
  if (_impl_.externaladreply_ != nullptr) _impl_.externaladreply_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::proto::ExternalAdReplyInfo& ContextInfo::_internal_externaladreply() const {
  const ::proto::ExternalAdReplyInfo* p = _impl_.externaladreply_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ExternalAdReplyInfo&>(
      ::proto::_ExternalAdReplyInfo_default_instance_);
}
inline const ::proto::ExternalAdReplyInfo& ContextInfo::externaladreply() const {
  // @@protoc_insertion_point(field_get:proto.ContextInfo.externalAdReply)
  return _internal_externaladreply();
}
inline void ContextInfo::unsafe_arena_set_allocated_externaladreply(
    ::proto::ExternalAdReplyInfo* externaladreply) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.externaladreply_);
  }
  _impl_.externaladreply_ = externaladreply;
  if (externaladreply) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ContextInfo.externalAdReply)
}
inline ::proto::ExternalAdReplyInfo* ContextInfo::release_externaladreply() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::proto::ExternalAdReplyInfo* temp = _impl_.externaladreply_;
  _impl_.externaladreply_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ExternalAdReplyInfo* ContextInfo::unsafe_arena_release_externaladreply() {
  // @@protoc_insertion_point(field_release:proto.ContextInfo.externalAdReply)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::proto::ExternalAdReplyInfo* temp = _impl_.externaladreply_;
  _impl_.externaladreply_ = nullptr;
  return temp;
}
inline ::proto::ExternalAdReplyInfo* ContextInfo::_internal_mutable_externaladreply() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.externaladreply_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ExternalAdReplyInfo>(GetArenaForAllocation());
    _impl_.externaladreply_ = p;
  }
  return _impl_.externaladreply_;
}
inline ::proto::ExternalAdReplyInfo* ContextInfo::mutable_externaladreply() {
  ::proto::ExternalAdReplyInfo* _msg = _internal_mutable_externaladreply();
  // @@protoc_insertion_point(field_mutable:proto.ContextInfo.externalAdReply)
  return _msg;
}
inline void ContextInfo::set_allocated_externaladreply(::proto::ExternalAdReplyInfo* externaladreply) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.externaladreply_;
  }
  if (externaladreply) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(externaladreply);
    if (message_arena != submessage_arena) {
      externaladreply = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, externaladreply, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.externaladreply_ = externaladreply;
  // @@protoc_insertion_point(field_set_allocated:proto.ContextInfo.externalAdReply)
}

// -------------------------------------------------------------------

// SenderKeyDistributionMessage

// optional string groupId = 1;
inline bool SenderKeyDistributionMessage::_internal_has_groupid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SenderKeyDistributionMessage::has_groupid() const {
  return _internal_has_groupid();
}
inline void SenderKeyDistributionMessage::clear_groupid() {
  _impl_.groupid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SenderKeyDistributionMessage::groupid() const {
  // @@protoc_insertion_point(field_get:proto.SenderKeyDistributionMessage.groupId)
  return _internal_groupid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SenderKeyDistributionMessage::set_groupid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.groupid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SenderKeyDistributionMessage.groupId)
}
inline std::string* SenderKeyDistributionMessage::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:proto.SenderKeyDistributionMessage.groupId)
  return _s;
}
inline const std::string& SenderKeyDistributionMessage::_internal_groupid() const {
  return _impl_.groupid_.Get();
}
inline void SenderKeyDistributionMessage::_internal_set_groupid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.groupid_.Set(value, GetArenaForAllocation());
}
inline std::string* SenderKeyDistributionMessage::_internal_mutable_groupid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.groupid_.Mutable(GetArenaForAllocation());
}
inline std::string* SenderKeyDistributionMessage::release_groupid() {
  // @@protoc_insertion_point(field_release:proto.SenderKeyDistributionMessage.groupId)
  if (!_internal_has_groupid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.groupid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupid_.IsDefault()) {
    _impl_.groupid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SenderKeyDistributionMessage::set_allocated_groupid(std::string* groupid) {
  if (groupid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.groupid_.SetAllocated(groupid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupid_.IsDefault()) {
    _impl_.groupid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SenderKeyDistributionMessage.groupId)
}

// optional bytes axolotlSenderKeyDistributionMessage = 2;
inline bool SenderKeyDistributionMessage::_internal_has_axolotlsenderkeydistributionmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SenderKeyDistributionMessage::has_axolotlsenderkeydistributionmessage() const {
  return _internal_has_axolotlsenderkeydistributionmessage();
}
inline void SenderKeyDistributionMessage::clear_axolotlsenderkeydistributionmessage() {
  _impl_.axolotlsenderkeydistributionmessage_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SenderKeyDistributionMessage::axolotlsenderkeydistributionmessage() const {
  // @@protoc_insertion_point(field_get:proto.SenderKeyDistributionMessage.axolotlSenderKeyDistributionMessage)
  return _internal_axolotlsenderkeydistributionmessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SenderKeyDistributionMessage::set_axolotlsenderkeydistributionmessage(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.axolotlsenderkeydistributionmessage_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SenderKeyDistributionMessage.axolotlSenderKeyDistributionMessage)
}
inline std::string* SenderKeyDistributionMessage::mutable_axolotlsenderkeydistributionmessage() {
  std::string* _s = _internal_mutable_axolotlsenderkeydistributionmessage();
  // @@protoc_insertion_point(field_mutable:proto.SenderKeyDistributionMessage.axolotlSenderKeyDistributionMessage)
  return _s;
}
inline const std::string& SenderKeyDistributionMessage::_internal_axolotlsenderkeydistributionmessage() const {
  return _impl_.axolotlsenderkeydistributionmessage_.Get();
}
inline void SenderKeyDistributionMessage::_internal_set_axolotlsenderkeydistributionmessage(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.axolotlsenderkeydistributionmessage_.Set(value, GetArenaForAllocation());
}
inline std::string* SenderKeyDistributionMessage::_internal_mutable_axolotlsenderkeydistributionmessage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.axolotlsenderkeydistributionmessage_.Mutable(GetArenaForAllocation());
}
inline std::string* SenderKeyDistributionMessage::release_axolotlsenderkeydistributionmessage() {
  // @@protoc_insertion_point(field_release:proto.SenderKeyDistributionMessage.axolotlSenderKeyDistributionMessage)
  if (!_internal_has_axolotlsenderkeydistributionmessage()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.axolotlsenderkeydistributionmessage_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.axolotlsenderkeydistributionmessage_.IsDefault()) {
    _impl_.axolotlsenderkeydistributionmessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SenderKeyDistributionMessage::set_allocated_axolotlsenderkeydistributionmessage(std::string* axolotlsenderkeydistributionmessage) {
  if (axolotlsenderkeydistributionmessage != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.axolotlsenderkeydistributionmessage_.SetAllocated(axolotlsenderkeydistributionmessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.axolotlsenderkeydistributionmessage_.IsDefault()) {
    _impl_.axolotlsenderkeydistributionmessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SenderKeyDistributionMessage.axolotlSenderKeyDistributionMessage)
}

// -------------------------------------------------------------------

// ImageMessage

// optional string url = 1;
inline bool ImageMessage::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ImageMessage::has_url() const {
  return _internal_has_url();
}
inline void ImageMessage::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ImageMessage::url() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageMessage::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ImageMessage.url)
}
inline std::string* ImageMessage::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:proto.ImageMessage.url)
  return _s;
}
inline const std::string& ImageMessage::_internal_url() const {
  return _impl_.url_.Get();
}
inline void ImageMessage::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageMessage::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageMessage::release_url() {
  // @@protoc_insertion_point(field_release:proto.ImageMessage.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImageMessage::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ImageMessage.url)
}

// optional string mimetype = 2;
inline bool ImageMessage::_internal_has_mimetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ImageMessage::has_mimetype() const {
  return _internal_has_mimetype();
}
inline void ImageMessage::clear_mimetype() {
  _impl_.mimetype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ImageMessage::mimetype() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.mimetype)
  return _internal_mimetype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageMessage::set_mimetype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.mimetype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ImageMessage.mimetype)
}
inline std::string* ImageMessage::mutable_mimetype() {
  std::string* _s = _internal_mutable_mimetype();
  // @@protoc_insertion_point(field_mutable:proto.ImageMessage.mimetype)
  return _s;
}
inline const std::string& ImageMessage::_internal_mimetype() const {
  return _impl_.mimetype_.Get();
}
inline void ImageMessage::_internal_set_mimetype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mimetype_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageMessage::_internal_mutable_mimetype() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mimetype_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageMessage::release_mimetype() {
  // @@protoc_insertion_point(field_release:proto.ImageMessage.mimetype)
  if (!_internal_has_mimetype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.mimetype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mimetype_.IsDefault()) {
    _impl_.mimetype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImageMessage::set_allocated_mimetype(std::string* mimetype) {
  if (mimetype != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mimetype_.SetAllocated(mimetype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mimetype_.IsDefault()) {
    _impl_.mimetype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ImageMessage.mimetype)
}

// optional string caption = 3;
inline bool ImageMessage::_internal_has_caption() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ImageMessage::has_caption() const {
  return _internal_has_caption();
}
inline void ImageMessage::clear_caption() {
  _impl_.caption_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ImageMessage::caption() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.caption)
  return _internal_caption();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageMessage::set_caption(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.caption_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ImageMessage.caption)
}
inline std::string* ImageMessage::mutable_caption() {
  std::string* _s = _internal_mutable_caption();
  // @@protoc_insertion_point(field_mutable:proto.ImageMessage.caption)
  return _s;
}
inline const std::string& ImageMessage::_internal_caption() const {
  return _impl_.caption_.Get();
}
inline void ImageMessage::_internal_set_caption(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.caption_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageMessage::_internal_mutable_caption() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.caption_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageMessage::release_caption() {
  // @@protoc_insertion_point(field_release:proto.ImageMessage.caption)
  if (!_internal_has_caption()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.caption_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caption_.IsDefault()) {
    _impl_.caption_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImageMessage::set_allocated_caption(std::string* caption) {
  if (caption != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.caption_.SetAllocated(caption, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caption_.IsDefault()) {
    _impl_.caption_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ImageMessage.caption)
}

// optional bytes fileSha256 = 4;
inline bool ImageMessage::_internal_has_filesha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ImageMessage::has_filesha256() const {
  return _internal_has_filesha256();
}
inline void ImageMessage::clear_filesha256() {
  _impl_.filesha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ImageMessage::filesha256() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.fileSha256)
  return _internal_filesha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageMessage::set_filesha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.filesha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ImageMessage.fileSha256)
}
inline std::string* ImageMessage::mutable_filesha256() {
  std::string* _s = _internal_mutable_filesha256();
  // @@protoc_insertion_point(field_mutable:proto.ImageMessage.fileSha256)
  return _s;
}
inline const std::string& ImageMessage::_internal_filesha256() const {
  return _impl_.filesha256_.Get();
}
inline void ImageMessage::_internal_set_filesha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.filesha256_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageMessage::_internal_mutable_filesha256() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.filesha256_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageMessage::release_filesha256() {
  // @@protoc_insertion_point(field_release:proto.ImageMessage.fileSha256)
  if (!_internal_has_filesha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.filesha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filesha256_.IsDefault()) {
    _impl_.filesha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImageMessage::set_allocated_filesha256(std::string* filesha256) {
  if (filesha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.filesha256_.SetAllocated(filesha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filesha256_.IsDefault()) {
    _impl_.filesha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ImageMessage.fileSha256)
}

// optional uint64 fileLength = 5;
inline bool ImageMessage::_internal_has_filelength() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool ImageMessage::has_filelength() const {
  return _internal_has_filelength();
}
inline void ImageMessage::clear_filelength() {
  _impl_.filelength_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline uint64_t ImageMessage::_internal_filelength() const {
  return _impl_.filelength_;
}
inline uint64_t ImageMessage::filelength() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.fileLength)
  return _internal_filelength();
}
inline void ImageMessage::_internal_set_filelength(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.filelength_ = value;
}
inline void ImageMessage::set_filelength(uint64_t value) {
  _internal_set_filelength(value);
  // @@protoc_insertion_point(field_set:proto.ImageMessage.fileLength)
}

// optional uint32 height = 6;
inline bool ImageMessage::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool ImageMessage::has_height() const {
  return _internal_has_height();
}
inline void ImageMessage::clear_height() {
  _impl_.height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline uint32_t ImageMessage::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t ImageMessage::height() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.height)
  return _internal_height();
}
inline void ImageMessage::_internal_set_height(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.height_ = value;
}
inline void ImageMessage::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:proto.ImageMessage.height)
}

// optional uint32 width = 7;
inline bool ImageMessage::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool ImageMessage::has_width() const {
  return _internal_has_width();
}
inline void ImageMessage::clear_width() {
  _impl_.width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline uint32_t ImageMessage::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t ImageMessage::width() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.width)
  return _internal_width();
}
inline void ImageMessage::_internal_set_width(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.width_ = value;
}
inline void ImageMessage::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:proto.ImageMessage.width)
}

// optional bytes mediaKey = 8;
inline bool ImageMessage::_internal_has_mediakey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ImageMessage::has_mediakey() const {
  return _internal_has_mediakey();
}
inline void ImageMessage::clear_mediakey() {
  _impl_.mediakey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ImageMessage::mediakey() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.mediaKey)
  return _internal_mediakey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageMessage::set_mediakey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.mediakey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ImageMessage.mediaKey)
}
inline std::string* ImageMessage::mutable_mediakey() {
  std::string* _s = _internal_mutable_mediakey();
  // @@protoc_insertion_point(field_mutable:proto.ImageMessage.mediaKey)
  return _s;
}
inline const std::string& ImageMessage::_internal_mediakey() const {
  return _impl_.mediakey_.Get();
}
inline void ImageMessage::_internal_set_mediakey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.mediakey_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageMessage::_internal_mutable_mediakey() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.mediakey_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageMessage::release_mediakey() {
  // @@protoc_insertion_point(field_release:proto.ImageMessage.mediaKey)
  if (!_internal_has_mediakey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.mediakey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mediakey_.IsDefault()) {
    _impl_.mediakey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImageMessage::set_allocated_mediakey(std::string* mediakey) {
  if (mediakey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.mediakey_.SetAllocated(mediakey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mediakey_.IsDefault()) {
    _impl_.mediakey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ImageMessage.mediaKey)
}

// optional bytes fileEncSha256 = 9;
inline bool ImageMessage::_internal_has_fileencsha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ImageMessage::has_fileencsha256() const {
  return _internal_has_fileencsha256();
}
inline void ImageMessage::clear_fileencsha256() {
  _impl_.fileencsha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ImageMessage::fileencsha256() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.fileEncSha256)
  return _internal_fileencsha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageMessage::set_fileencsha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.fileencsha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ImageMessage.fileEncSha256)
}
inline std::string* ImageMessage::mutable_fileencsha256() {
  std::string* _s = _internal_mutable_fileencsha256();
  // @@protoc_insertion_point(field_mutable:proto.ImageMessage.fileEncSha256)
  return _s;
}
inline const std::string& ImageMessage::_internal_fileencsha256() const {
  return _impl_.fileencsha256_.Get();
}
inline void ImageMessage::_internal_set_fileencsha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.fileencsha256_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageMessage::_internal_mutable_fileencsha256() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.fileencsha256_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageMessage::release_fileencsha256() {
  // @@protoc_insertion_point(field_release:proto.ImageMessage.fileEncSha256)
  if (!_internal_has_fileencsha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.fileencsha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fileencsha256_.IsDefault()) {
    _impl_.fileencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImageMessage::set_allocated_fileencsha256(std::string* fileencsha256) {
  if (fileencsha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.fileencsha256_.SetAllocated(fileencsha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fileencsha256_.IsDefault()) {
    _impl_.fileencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ImageMessage.fileEncSha256)
}

// repeated .proto.InteractiveAnnotation interactiveAnnotations = 10;
inline int ImageMessage::_internal_interactiveannotations_size() const {
  return _impl_.interactiveannotations_.size();
}
inline int ImageMessage::interactiveannotations_size() const {
  return _internal_interactiveannotations_size();
}
inline void ImageMessage::clear_interactiveannotations() {
  _impl_.interactiveannotations_.Clear();
}
inline ::proto::InteractiveAnnotation* ImageMessage::mutable_interactiveannotations(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ImageMessage.interactiveAnnotations)
  return _impl_.interactiveannotations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::InteractiveAnnotation >*
ImageMessage::mutable_interactiveannotations() {
  // @@protoc_insertion_point(field_mutable_list:proto.ImageMessage.interactiveAnnotations)
  return &_impl_.interactiveannotations_;
}
inline const ::proto::InteractiveAnnotation& ImageMessage::_internal_interactiveannotations(int index) const {
  return _impl_.interactiveannotations_.Get(index);
}
inline const ::proto::InteractiveAnnotation& ImageMessage::interactiveannotations(int index) const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.interactiveAnnotations)
  return _internal_interactiveannotations(index);
}
inline ::proto::InteractiveAnnotation* ImageMessage::_internal_add_interactiveannotations() {
  return _impl_.interactiveannotations_.Add();
}
inline ::proto::InteractiveAnnotation* ImageMessage::add_interactiveannotations() {
  ::proto::InteractiveAnnotation* _add = _internal_add_interactiveannotations();
  // @@protoc_insertion_point(field_add:proto.ImageMessage.interactiveAnnotations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::InteractiveAnnotation >&
ImageMessage::interactiveannotations() const {
  // @@protoc_insertion_point(field_list:proto.ImageMessage.interactiveAnnotations)
  return _impl_.interactiveannotations_;
}

// optional string directPath = 11;
inline bool ImageMessage::_internal_has_directpath() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ImageMessage::has_directpath() const {
  return _internal_has_directpath();
}
inline void ImageMessage::clear_directpath() {
  _impl_.directpath_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ImageMessage::directpath() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.directPath)
  return _internal_directpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageMessage::set_directpath(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.directpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ImageMessage.directPath)
}
inline std::string* ImageMessage::mutable_directpath() {
  std::string* _s = _internal_mutable_directpath();
  // @@protoc_insertion_point(field_mutable:proto.ImageMessage.directPath)
  return _s;
}
inline const std::string& ImageMessage::_internal_directpath() const {
  return _impl_.directpath_.Get();
}
inline void ImageMessage::_internal_set_directpath(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.directpath_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageMessage::_internal_mutable_directpath() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.directpath_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageMessage::release_directpath() {
  // @@protoc_insertion_point(field_release:proto.ImageMessage.directPath)
  if (!_internal_has_directpath()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.directpath_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.directpath_.IsDefault()) {
    _impl_.directpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImageMessage::set_allocated_directpath(std::string* directpath) {
  if (directpath != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.directpath_.SetAllocated(directpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.directpath_.IsDefault()) {
    _impl_.directpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ImageMessage.directPath)
}

// optional int64 mediaKeyTimestamp = 12;
inline bool ImageMessage::_internal_has_mediakeytimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool ImageMessage::has_mediakeytimestamp() const {
  return _internal_has_mediakeytimestamp();
}
inline void ImageMessage::clear_mediakeytimestamp() {
  _impl_.mediakeytimestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline int64_t ImageMessage::_internal_mediakeytimestamp() const {
  return _impl_.mediakeytimestamp_;
}
inline int64_t ImageMessage::mediakeytimestamp() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.mediaKeyTimestamp)
  return _internal_mediakeytimestamp();
}
inline void ImageMessage::_internal_set_mediakeytimestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.mediakeytimestamp_ = value;
}
inline void ImageMessage::set_mediakeytimestamp(int64_t value) {
  _internal_set_mediakeytimestamp(value);
  // @@protoc_insertion_point(field_set:proto.ImageMessage.mediaKeyTimestamp)
}

// optional bytes jpegThumbnail = 16;
inline bool ImageMessage::_internal_has_jpegthumbnail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ImageMessage::has_jpegthumbnail() const {
  return _internal_has_jpegthumbnail();
}
inline void ImageMessage::clear_jpegthumbnail() {
  _impl_.jpegthumbnail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ImageMessage::jpegthumbnail() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.jpegThumbnail)
  return _internal_jpegthumbnail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageMessage::set_jpegthumbnail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.jpegthumbnail_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ImageMessage.jpegThumbnail)
}
inline std::string* ImageMessage::mutable_jpegthumbnail() {
  std::string* _s = _internal_mutable_jpegthumbnail();
  // @@protoc_insertion_point(field_mutable:proto.ImageMessage.jpegThumbnail)
  return _s;
}
inline const std::string& ImageMessage::_internal_jpegthumbnail() const {
  return _impl_.jpegthumbnail_.Get();
}
inline void ImageMessage::_internal_set_jpegthumbnail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.jpegthumbnail_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageMessage::_internal_mutable_jpegthumbnail() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.jpegthumbnail_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageMessage::release_jpegthumbnail() {
  // @@protoc_insertion_point(field_release:proto.ImageMessage.jpegThumbnail)
  if (!_internal_has_jpegthumbnail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.jpegthumbnail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jpegthumbnail_.IsDefault()) {
    _impl_.jpegthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImageMessage::set_allocated_jpegthumbnail(std::string* jpegthumbnail) {
  if (jpegthumbnail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.jpegthumbnail_.SetAllocated(jpegthumbnail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jpegthumbnail_.IsDefault()) {
    _impl_.jpegthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ImageMessage.jpegThumbnail)
}

// optional .proto.ContextInfo contextInfo = 17;
inline bool ImageMessage::_internal_has_contextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contextinfo_ != nullptr);
  return value;
}
inline bool ImageMessage::has_contextinfo() const {
  return _internal_has_contextinfo();
}
inline void ImageMessage::clear_contextinfo() {
  if (_impl_.contextinfo_ != nullptr) _impl_.contextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const ::proto::ContextInfo& ImageMessage::_internal_contextinfo() const {
  const ::proto::ContextInfo* p = _impl_.contextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContextInfo&>(
      ::proto::_ContextInfo_default_instance_);
}
inline const ::proto::ContextInfo& ImageMessage::contextinfo() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.contextInfo)
  return _internal_contextinfo();
}
inline void ImageMessage::unsafe_arena_set_allocated_contextinfo(
    ::proto::ContextInfo* contextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextinfo_);
  }
  _impl_.contextinfo_ = contextinfo;
  if (contextinfo) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ImageMessage.contextInfo)
}
inline ::proto::ContextInfo* ImageMessage::release_contextinfo() {
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContextInfo* ImageMessage::unsafe_arena_release_contextinfo() {
  // @@protoc_insertion_point(field_release:proto.ImageMessage.contextInfo)
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
  return temp;
}
inline ::proto::ContextInfo* ImageMessage::_internal_mutable_contextinfo() {
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.contextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContextInfo>(GetArenaForAllocation());
    _impl_.contextinfo_ = p;
  }
  return _impl_.contextinfo_;
}
inline ::proto::ContextInfo* ImageMessage::mutable_contextinfo() {
  ::proto::ContextInfo* _msg = _internal_mutable_contextinfo();
  // @@protoc_insertion_point(field_mutable:proto.ImageMessage.contextInfo)
  return _msg;
}
inline void ImageMessage::set_allocated_contextinfo(::proto::ContextInfo* contextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contextinfo_;
  }
  if (contextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contextinfo);
    if (message_arena != submessage_arena) {
      contextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.contextinfo_ = contextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.ImageMessage.contextInfo)
}

// optional bytes firstScanSidecar = 18;
inline bool ImageMessage::_internal_has_firstscansidecar() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ImageMessage::has_firstscansidecar() const {
  return _internal_has_firstscansidecar();
}
inline void ImageMessage::clear_firstscansidecar() {
  _impl_.firstscansidecar_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& ImageMessage::firstscansidecar() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.firstScanSidecar)
  return _internal_firstscansidecar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageMessage::set_firstscansidecar(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.firstscansidecar_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ImageMessage.firstScanSidecar)
}
inline std::string* ImageMessage::mutable_firstscansidecar() {
  std::string* _s = _internal_mutable_firstscansidecar();
  // @@protoc_insertion_point(field_mutable:proto.ImageMessage.firstScanSidecar)
  return _s;
}
inline const std::string& ImageMessage::_internal_firstscansidecar() const {
  return _impl_.firstscansidecar_.Get();
}
inline void ImageMessage::_internal_set_firstscansidecar(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.firstscansidecar_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageMessage::_internal_mutable_firstscansidecar() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.firstscansidecar_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageMessage::release_firstscansidecar() {
  // @@protoc_insertion_point(field_release:proto.ImageMessage.firstScanSidecar)
  if (!_internal_has_firstscansidecar()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.firstscansidecar_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.firstscansidecar_.IsDefault()) {
    _impl_.firstscansidecar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImageMessage::set_allocated_firstscansidecar(std::string* firstscansidecar) {
  if (firstscansidecar != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.firstscansidecar_.SetAllocated(firstscansidecar, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.firstscansidecar_.IsDefault()) {
    _impl_.firstscansidecar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ImageMessage.firstScanSidecar)
}

// optional uint32 firstScanLength = 19;
inline bool ImageMessage::_internal_has_firstscanlength() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool ImageMessage::has_firstscanlength() const {
  return _internal_has_firstscanlength();
}
inline void ImageMessage::clear_firstscanlength() {
  _impl_.firstscanlength_ = 0u;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline uint32_t ImageMessage::_internal_firstscanlength() const {
  return _impl_.firstscanlength_;
}
inline uint32_t ImageMessage::firstscanlength() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.firstScanLength)
  return _internal_firstscanlength();
}
inline void ImageMessage::_internal_set_firstscanlength(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.firstscanlength_ = value;
}
inline void ImageMessage::set_firstscanlength(uint32_t value) {
  _internal_set_firstscanlength(value);
  // @@protoc_insertion_point(field_set:proto.ImageMessage.firstScanLength)
}

// optional uint32 experimentGroupId = 20;
inline bool ImageMessage::_internal_has_experimentgroupid() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool ImageMessage::has_experimentgroupid() const {
  return _internal_has_experimentgroupid();
}
inline void ImageMessage::clear_experimentgroupid() {
  _impl_.experimentgroupid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline uint32_t ImageMessage::_internal_experimentgroupid() const {
  return _impl_.experimentgroupid_;
}
inline uint32_t ImageMessage::experimentgroupid() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.experimentGroupId)
  return _internal_experimentgroupid();
}
inline void ImageMessage::_internal_set_experimentgroupid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.experimentgroupid_ = value;
}
inline void ImageMessage::set_experimentgroupid(uint32_t value) {
  _internal_set_experimentgroupid(value);
  // @@protoc_insertion_point(field_set:proto.ImageMessage.experimentGroupId)
}

// optional bytes scansSidecar = 21;
inline bool ImageMessage::_internal_has_scanssidecar() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ImageMessage::has_scanssidecar() const {
  return _internal_has_scanssidecar();
}
inline void ImageMessage::clear_scanssidecar() {
  _impl_.scanssidecar_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& ImageMessage::scanssidecar() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.scansSidecar)
  return _internal_scanssidecar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageMessage::set_scanssidecar(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000200u;
 _impl_.scanssidecar_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ImageMessage.scansSidecar)
}
inline std::string* ImageMessage::mutable_scanssidecar() {
  std::string* _s = _internal_mutable_scanssidecar();
  // @@protoc_insertion_point(field_mutable:proto.ImageMessage.scansSidecar)
  return _s;
}
inline const std::string& ImageMessage::_internal_scanssidecar() const {
  return _impl_.scanssidecar_.Get();
}
inline void ImageMessage::_internal_set_scanssidecar(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.scanssidecar_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageMessage::_internal_mutable_scanssidecar() {
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.scanssidecar_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageMessage::release_scanssidecar() {
  // @@protoc_insertion_point(field_release:proto.ImageMessage.scansSidecar)
  if (!_internal_has_scanssidecar()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* p = _impl_.scanssidecar_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.scanssidecar_.IsDefault()) {
    _impl_.scanssidecar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImageMessage::set_allocated_scanssidecar(std::string* scanssidecar) {
  if (scanssidecar != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.scanssidecar_.SetAllocated(scanssidecar, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.scanssidecar_.IsDefault()) {
    _impl_.scanssidecar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ImageMessage.scansSidecar)
}

// repeated uint32 scanLengths = 22;
inline int ImageMessage::_internal_scanlengths_size() const {
  return _impl_.scanlengths_.size();
}
inline int ImageMessage::scanlengths_size() const {
  return _internal_scanlengths_size();
}
inline void ImageMessage::clear_scanlengths() {
  _impl_.scanlengths_.Clear();
}
inline uint32_t ImageMessage::_internal_scanlengths(int index) const {
  return _impl_.scanlengths_.Get(index);
}
inline uint32_t ImageMessage::scanlengths(int index) const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.scanLengths)
  return _internal_scanlengths(index);
}
inline void ImageMessage::set_scanlengths(int index, uint32_t value) {
  _impl_.scanlengths_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.ImageMessage.scanLengths)
}
inline void ImageMessage::_internal_add_scanlengths(uint32_t value) {
  _impl_.scanlengths_.Add(value);
}
inline void ImageMessage::add_scanlengths(uint32_t value) {
  _internal_add_scanlengths(value);
  // @@protoc_insertion_point(field_add:proto.ImageMessage.scanLengths)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ImageMessage::_internal_scanlengths() const {
  return _impl_.scanlengths_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ImageMessage::scanlengths() const {
  // @@protoc_insertion_point(field_list:proto.ImageMessage.scanLengths)
  return _internal_scanlengths();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ImageMessage::_internal_mutable_scanlengths() {
  return &_impl_.scanlengths_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ImageMessage::mutable_scanlengths() {
  // @@protoc_insertion_point(field_mutable_list:proto.ImageMessage.scanLengths)
  return _internal_mutable_scanlengths();
}

// optional bytes midQualityFileSha256 = 23;
inline bool ImageMessage::_internal_has_midqualityfilesha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ImageMessage::has_midqualityfilesha256() const {
  return _internal_has_midqualityfilesha256();
}
inline void ImageMessage::clear_midqualityfilesha256() {
  _impl_.midqualityfilesha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& ImageMessage::midqualityfilesha256() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.midQualityFileSha256)
  return _internal_midqualityfilesha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageMessage::set_midqualityfilesha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000400u;
 _impl_.midqualityfilesha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ImageMessage.midQualityFileSha256)
}
inline std::string* ImageMessage::mutable_midqualityfilesha256() {
  std::string* _s = _internal_mutable_midqualityfilesha256();
  // @@protoc_insertion_point(field_mutable:proto.ImageMessage.midQualityFileSha256)
  return _s;
}
inline const std::string& ImageMessage::_internal_midqualityfilesha256() const {
  return _impl_.midqualityfilesha256_.Get();
}
inline void ImageMessage::_internal_set_midqualityfilesha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.midqualityfilesha256_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageMessage::_internal_mutable_midqualityfilesha256() {
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.midqualityfilesha256_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageMessage::release_midqualityfilesha256() {
  // @@protoc_insertion_point(field_release:proto.ImageMessage.midQualityFileSha256)
  if (!_internal_has_midqualityfilesha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* p = _impl_.midqualityfilesha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.midqualityfilesha256_.IsDefault()) {
    _impl_.midqualityfilesha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImageMessage::set_allocated_midqualityfilesha256(std::string* midqualityfilesha256) {
  if (midqualityfilesha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.midqualityfilesha256_.SetAllocated(midqualityfilesha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.midqualityfilesha256_.IsDefault()) {
    _impl_.midqualityfilesha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ImageMessage.midQualityFileSha256)
}

// optional bytes midQualityFileEncSha256 = 24;
inline bool ImageMessage::_internal_has_midqualityfileencsha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ImageMessage::has_midqualityfileencsha256() const {
  return _internal_has_midqualityfileencsha256();
}
inline void ImageMessage::clear_midqualityfileencsha256() {
  _impl_.midqualityfileencsha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& ImageMessage::midqualityfileencsha256() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.midQualityFileEncSha256)
  return _internal_midqualityfileencsha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageMessage::set_midqualityfileencsha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000800u;
 _impl_.midqualityfileencsha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ImageMessage.midQualityFileEncSha256)
}
inline std::string* ImageMessage::mutable_midqualityfileencsha256() {
  std::string* _s = _internal_mutable_midqualityfileencsha256();
  // @@protoc_insertion_point(field_mutable:proto.ImageMessage.midQualityFileEncSha256)
  return _s;
}
inline const std::string& ImageMessage::_internal_midqualityfileencsha256() const {
  return _impl_.midqualityfileencsha256_.Get();
}
inline void ImageMessage::_internal_set_midqualityfileencsha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.midqualityfileencsha256_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageMessage::_internal_mutable_midqualityfileencsha256() {
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.midqualityfileencsha256_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageMessage::release_midqualityfileencsha256() {
  // @@protoc_insertion_point(field_release:proto.ImageMessage.midQualityFileEncSha256)
  if (!_internal_has_midqualityfileencsha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* p = _impl_.midqualityfileencsha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.midqualityfileencsha256_.IsDefault()) {
    _impl_.midqualityfileencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImageMessage::set_allocated_midqualityfileencsha256(std::string* midqualityfileencsha256) {
  if (midqualityfileencsha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.midqualityfileencsha256_.SetAllocated(midqualityfileencsha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.midqualityfileencsha256_.IsDefault()) {
    _impl_.midqualityfileencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ImageMessage.midQualityFileEncSha256)
}

// optional bool viewOnce = 25;
inline bool ImageMessage::_internal_has_viewonce() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool ImageMessage::has_viewonce() const {
  return _internal_has_viewonce();
}
inline void ImageMessage::clear_viewonce() {
  _impl_.viewonce_ = false;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline bool ImageMessage::_internal_viewonce() const {
  return _impl_.viewonce_;
}
inline bool ImageMessage::viewonce() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.viewOnce)
  return _internal_viewonce();
}
inline void ImageMessage::_internal_set_viewonce(bool value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.viewonce_ = value;
}
inline void ImageMessage::set_viewonce(bool value) {
  _internal_set_viewonce(value);
  // @@protoc_insertion_point(field_set:proto.ImageMessage.viewOnce)
}

// optional string thumbnailDirectPath = 26;
inline bool ImageMessage::_internal_has_thumbnaildirectpath() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ImageMessage::has_thumbnaildirectpath() const {
  return _internal_has_thumbnaildirectpath();
}
inline void ImageMessage::clear_thumbnaildirectpath() {
  _impl_.thumbnaildirectpath_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const std::string& ImageMessage::thumbnaildirectpath() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.thumbnailDirectPath)
  return _internal_thumbnaildirectpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageMessage::set_thumbnaildirectpath(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00001000u;
 _impl_.thumbnaildirectpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ImageMessage.thumbnailDirectPath)
}
inline std::string* ImageMessage::mutable_thumbnaildirectpath() {
  std::string* _s = _internal_mutable_thumbnaildirectpath();
  // @@protoc_insertion_point(field_mutable:proto.ImageMessage.thumbnailDirectPath)
  return _s;
}
inline const std::string& ImageMessage::_internal_thumbnaildirectpath() const {
  return _impl_.thumbnaildirectpath_.Get();
}
inline void ImageMessage::_internal_set_thumbnaildirectpath(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.thumbnaildirectpath_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageMessage::_internal_mutable_thumbnaildirectpath() {
  _impl_._has_bits_[0] |= 0x00001000u;
  return _impl_.thumbnaildirectpath_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageMessage::release_thumbnaildirectpath() {
  // @@protoc_insertion_point(field_release:proto.ImageMessage.thumbnailDirectPath)
  if (!_internal_has_thumbnaildirectpath()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00001000u;
  auto* p = _impl_.thumbnaildirectpath_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnaildirectpath_.IsDefault()) {
    _impl_.thumbnaildirectpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImageMessage::set_allocated_thumbnaildirectpath(std::string* thumbnaildirectpath) {
  if (thumbnaildirectpath != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.thumbnaildirectpath_.SetAllocated(thumbnaildirectpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnaildirectpath_.IsDefault()) {
    _impl_.thumbnaildirectpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ImageMessage.thumbnailDirectPath)
}

// optional bytes thumbnailSha256 = 27;
inline bool ImageMessage::_internal_has_thumbnailsha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ImageMessage::has_thumbnailsha256() const {
  return _internal_has_thumbnailsha256();
}
inline void ImageMessage::clear_thumbnailsha256() {
  _impl_.thumbnailsha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const std::string& ImageMessage::thumbnailsha256() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.thumbnailSha256)
  return _internal_thumbnailsha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageMessage::set_thumbnailsha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00002000u;
 _impl_.thumbnailsha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ImageMessage.thumbnailSha256)
}
inline std::string* ImageMessage::mutable_thumbnailsha256() {
  std::string* _s = _internal_mutable_thumbnailsha256();
  // @@protoc_insertion_point(field_mutable:proto.ImageMessage.thumbnailSha256)
  return _s;
}
inline const std::string& ImageMessage::_internal_thumbnailsha256() const {
  return _impl_.thumbnailsha256_.Get();
}
inline void ImageMessage::_internal_set_thumbnailsha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.thumbnailsha256_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageMessage::_internal_mutable_thumbnailsha256() {
  _impl_._has_bits_[0] |= 0x00002000u;
  return _impl_.thumbnailsha256_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageMessage::release_thumbnailsha256() {
  // @@protoc_insertion_point(field_release:proto.ImageMessage.thumbnailSha256)
  if (!_internal_has_thumbnailsha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00002000u;
  auto* p = _impl_.thumbnailsha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailsha256_.IsDefault()) {
    _impl_.thumbnailsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImageMessage::set_allocated_thumbnailsha256(std::string* thumbnailsha256) {
  if (thumbnailsha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.thumbnailsha256_.SetAllocated(thumbnailsha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailsha256_.IsDefault()) {
    _impl_.thumbnailsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ImageMessage.thumbnailSha256)
}

// optional bytes thumbnailEncSha256 = 28;
inline bool ImageMessage::_internal_has_thumbnailencsha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ImageMessage::has_thumbnailencsha256() const {
  return _internal_has_thumbnailencsha256();
}
inline void ImageMessage::clear_thumbnailencsha256() {
  _impl_.thumbnailencsha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const std::string& ImageMessage::thumbnailencsha256() const {
  // @@protoc_insertion_point(field_get:proto.ImageMessage.thumbnailEncSha256)
  return _internal_thumbnailencsha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageMessage::set_thumbnailencsha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00004000u;
 _impl_.thumbnailencsha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ImageMessage.thumbnailEncSha256)
}
inline std::string* ImageMessage::mutable_thumbnailencsha256() {
  std::string* _s = _internal_mutable_thumbnailencsha256();
  // @@protoc_insertion_point(field_mutable:proto.ImageMessage.thumbnailEncSha256)
  return _s;
}
inline const std::string& ImageMessage::_internal_thumbnailencsha256() const {
  return _impl_.thumbnailencsha256_.Get();
}
inline void ImageMessage::_internal_set_thumbnailencsha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.thumbnailencsha256_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageMessage::_internal_mutable_thumbnailencsha256() {
  _impl_._has_bits_[0] |= 0x00004000u;
  return _impl_.thumbnailencsha256_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageMessage::release_thumbnailencsha256() {
  // @@protoc_insertion_point(field_release:proto.ImageMessage.thumbnailEncSha256)
  if (!_internal_has_thumbnailencsha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00004000u;
  auto* p = _impl_.thumbnailencsha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailencsha256_.IsDefault()) {
    _impl_.thumbnailencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImageMessage::set_allocated_thumbnailencsha256(std::string* thumbnailencsha256) {
  if (thumbnailencsha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.thumbnailencsha256_.SetAllocated(thumbnailencsha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailencsha256_.IsDefault()) {
    _impl_.thumbnailencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ImageMessage.thumbnailEncSha256)
}

// -------------------------------------------------------------------

// InvoiceMessage

// optional string note = 1;
inline bool InvoiceMessage::_internal_has_note() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InvoiceMessage::has_note() const {
  return _internal_has_note();
}
inline void InvoiceMessage::clear_note() {
  _impl_.note_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InvoiceMessage::note() const {
  // @@protoc_insertion_point(field_get:proto.InvoiceMessage.note)
  return _internal_note();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceMessage::set_note(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.note_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.InvoiceMessage.note)
}
inline std::string* InvoiceMessage::mutable_note() {
  std::string* _s = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:proto.InvoiceMessage.note)
  return _s;
}
inline const std::string& InvoiceMessage::_internal_note() const {
  return _impl_.note_.Get();
}
inline void InvoiceMessage::_internal_set_note(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.note_.Set(value, GetArenaForAllocation());
}
inline std::string* InvoiceMessage::_internal_mutable_note() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.note_.Mutable(GetArenaForAllocation());
}
inline std::string* InvoiceMessage::release_note() {
  // @@protoc_insertion_point(field_release:proto.InvoiceMessage.note)
  if (!_internal_has_note()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.note_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.note_.IsDefault()) {
    _impl_.note_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InvoiceMessage::set_allocated_note(std::string* note) {
  if (note != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.note_.SetAllocated(note, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.note_.IsDefault()) {
    _impl_.note_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.InvoiceMessage.note)
}

// optional string token = 2;
inline bool InvoiceMessage::_internal_has_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InvoiceMessage::has_token() const {
  return _internal_has_token();
}
inline void InvoiceMessage::clear_token() {
  _impl_.token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InvoiceMessage::token() const {
  // @@protoc_insertion_point(field_get:proto.InvoiceMessage.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceMessage::set_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.InvoiceMessage.token)
}
inline std::string* InvoiceMessage::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:proto.InvoiceMessage.token)
  return _s;
}
inline const std::string& InvoiceMessage::_internal_token() const {
  return _impl_.token_.Get();
}
inline void InvoiceMessage::_internal_set_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* InvoiceMessage::_internal_mutable_token() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* InvoiceMessage::release_token() {
  // @@protoc_insertion_point(field_release:proto.InvoiceMessage.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InvoiceMessage::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.InvoiceMessage.token)
}

// optional .proto.InvoiceMessage.InvoiceMessageAttachmentType attachmentType = 3;
inline bool InvoiceMessage::_internal_has_attachmenttype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool InvoiceMessage::has_attachmenttype() const {
  return _internal_has_attachmenttype();
}
inline void InvoiceMessage::clear_attachmenttype() {
  _impl_.attachmenttype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::proto::InvoiceMessage_InvoiceMessageAttachmentType InvoiceMessage::_internal_attachmenttype() const {
  return static_cast< ::proto::InvoiceMessage_InvoiceMessageAttachmentType >(_impl_.attachmenttype_);
}
inline ::proto::InvoiceMessage_InvoiceMessageAttachmentType InvoiceMessage::attachmenttype() const {
  // @@protoc_insertion_point(field_get:proto.InvoiceMessage.attachmentType)
  return _internal_attachmenttype();
}
inline void InvoiceMessage::_internal_set_attachmenttype(::proto::InvoiceMessage_InvoiceMessageAttachmentType value) {
  assert(::proto::InvoiceMessage_InvoiceMessageAttachmentType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.attachmenttype_ = value;
}
inline void InvoiceMessage::set_attachmenttype(::proto::InvoiceMessage_InvoiceMessageAttachmentType value) {
  _internal_set_attachmenttype(value);
  // @@protoc_insertion_point(field_set:proto.InvoiceMessage.attachmentType)
}

// optional string attachmentMimetype = 4;
inline bool InvoiceMessage::_internal_has_attachmentmimetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InvoiceMessage::has_attachmentmimetype() const {
  return _internal_has_attachmentmimetype();
}
inline void InvoiceMessage::clear_attachmentmimetype() {
  _impl_.attachmentmimetype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& InvoiceMessage::attachmentmimetype() const {
  // @@protoc_insertion_point(field_get:proto.InvoiceMessage.attachmentMimetype)
  return _internal_attachmentmimetype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceMessage::set_attachmentmimetype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.attachmentmimetype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.InvoiceMessage.attachmentMimetype)
}
inline std::string* InvoiceMessage::mutable_attachmentmimetype() {
  std::string* _s = _internal_mutable_attachmentmimetype();
  // @@protoc_insertion_point(field_mutable:proto.InvoiceMessage.attachmentMimetype)
  return _s;
}
inline const std::string& InvoiceMessage::_internal_attachmentmimetype() const {
  return _impl_.attachmentmimetype_.Get();
}
inline void InvoiceMessage::_internal_set_attachmentmimetype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.attachmentmimetype_.Set(value, GetArenaForAllocation());
}
inline std::string* InvoiceMessage::_internal_mutable_attachmentmimetype() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.attachmentmimetype_.Mutable(GetArenaForAllocation());
}
inline std::string* InvoiceMessage::release_attachmentmimetype() {
  // @@protoc_insertion_point(field_release:proto.InvoiceMessage.attachmentMimetype)
  if (!_internal_has_attachmentmimetype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.attachmentmimetype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachmentmimetype_.IsDefault()) {
    _impl_.attachmentmimetype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InvoiceMessage::set_allocated_attachmentmimetype(std::string* attachmentmimetype) {
  if (attachmentmimetype != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.attachmentmimetype_.SetAllocated(attachmentmimetype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachmentmimetype_.IsDefault()) {
    _impl_.attachmentmimetype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.InvoiceMessage.attachmentMimetype)
}

// optional bytes attachmentMediaKey = 5;
inline bool InvoiceMessage::_internal_has_attachmentmediakey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InvoiceMessage::has_attachmentmediakey() const {
  return _internal_has_attachmentmediakey();
}
inline void InvoiceMessage::clear_attachmentmediakey() {
  _impl_.attachmentmediakey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& InvoiceMessage::attachmentmediakey() const {
  // @@protoc_insertion_point(field_get:proto.InvoiceMessage.attachmentMediaKey)
  return _internal_attachmentmediakey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceMessage::set_attachmentmediakey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.attachmentmediakey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.InvoiceMessage.attachmentMediaKey)
}
inline std::string* InvoiceMessage::mutable_attachmentmediakey() {
  std::string* _s = _internal_mutable_attachmentmediakey();
  // @@protoc_insertion_point(field_mutable:proto.InvoiceMessage.attachmentMediaKey)
  return _s;
}
inline const std::string& InvoiceMessage::_internal_attachmentmediakey() const {
  return _impl_.attachmentmediakey_.Get();
}
inline void InvoiceMessage::_internal_set_attachmentmediakey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.attachmentmediakey_.Set(value, GetArenaForAllocation());
}
inline std::string* InvoiceMessage::_internal_mutable_attachmentmediakey() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.attachmentmediakey_.Mutable(GetArenaForAllocation());
}
inline std::string* InvoiceMessage::release_attachmentmediakey() {
  // @@protoc_insertion_point(field_release:proto.InvoiceMessage.attachmentMediaKey)
  if (!_internal_has_attachmentmediakey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.attachmentmediakey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachmentmediakey_.IsDefault()) {
    _impl_.attachmentmediakey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InvoiceMessage::set_allocated_attachmentmediakey(std::string* attachmentmediakey) {
  if (attachmentmediakey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.attachmentmediakey_.SetAllocated(attachmentmediakey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachmentmediakey_.IsDefault()) {
    _impl_.attachmentmediakey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.InvoiceMessage.attachmentMediaKey)
}

// optional int64 attachmentMediaKeyTimestamp = 6;
inline bool InvoiceMessage::_internal_has_attachmentmediakeytimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool InvoiceMessage::has_attachmentmediakeytimestamp() const {
  return _internal_has_attachmentmediakeytimestamp();
}
inline void InvoiceMessage::clear_attachmentmediakeytimestamp() {
  _impl_.attachmentmediakeytimestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t InvoiceMessage::_internal_attachmentmediakeytimestamp() const {
  return _impl_.attachmentmediakeytimestamp_;
}
inline int64_t InvoiceMessage::attachmentmediakeytimestamp() const {
  // @@protoc_insertion_point(field_get:proto.InvoiceMessage.attachmentMediaKeyTimestamp)
  return _internal_attachmentmediakeytimestamp();
}
inline void InvoiceMessage::_internal_set_attachmentmediakeytimestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.attachmentmediakeytimestamp_ = value;
}
inline void InvoiceMessage::set_attachmentmediakeytimestamp(int64_t value) {
  _internal_set_attachmentmediakeytimestamp(value);
  // @@protoc_insertion_point(field_set:proto.InvoiceMessage.attachmentMediaKeyTimestamp)
}

// optional bytes attachmentFileSha256 = 7;
inline bool InvoiceMessage::_internal_has_attachmentfilesha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InvoiceMessage::has_attachmentfilesha256() const {
  return _internal_has_attachmentfilesha256();
}
inline void InvoiceMessage::clear_attachmentfilesha256() {
  _impl_.attachmentfilesha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& InvoiceMessage::attachmentfilesha256() const {
  // @@protoc_insertion_point(field_get:proto.InvoiceMessage.attachmentFileSha256)
  return _internal_attachmentfilesha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceMessage::set_attachmentfilesha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.attachmentfilesha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.InvoiceMessage.attachmentFileSha256)
}
inline std::string* InvoiceMessage::mutable_attachmentfilesha256() {
  std::string* _s = _internal_mutable_attachmentfilesha256();
  // @@protoc_insertion_point(field_mutable:proto.InvoiceMessage.attachmentFileSha256)
  return _s;
}
inline const std::string& InvoiceMessage::_internal_attachmentfilesha256() const {
  return _impl_.attachmentfilesha256_.Get();
}
inline void InvoiceMessage::_internal_set_attachmentfilesha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.attachmentfilesha256_.Set(value, GetArenaForAllocation());
}
inline std::string* InvoiceMessage::_internal_mutable_attachmentfilesha256() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.attachmentfilesha256_.Mutable(GetArenaForAllocation());
}
inline std::string* InvoiceMessage::release_attachmentfilesha256() {
  // @@protoc_insertion_point(field_release:proto.InvoiceMessage.attachmentFileSha256)
  if (!_internal_has_attachmentfilesha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.attachmentfilesha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachmentfilesha256_.IsDefault()) {
    _impl_.attachmentfilesha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InvoiceMessage::set_allocated_attachmentfilesha256(std::string* attachmentfilesha256) {
  if (attachmentfilesha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.attachmentfilesha256_.SetAllocated(attachmentfilesha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachmentfilesha256_.IsDefault()) {
    _impl_.attachmentfilesha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.InvoiceMessage.attachmentFileSha256)
}

// optional bytes attachmentFileEncSha256 = 8;
inline bool InvoiceMessage::_internal_has_attachmentfileencsha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool InvoiceMessage::has_attachmentfileencsha256() const {
  return _internal_has_attachmentfileencsha256();
}
inline void InvoiceMessage::clear_attachmentfileencsha256() {
  _impl_.attachmentfileencsha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& InvoiceMessage::attachmentfileencsha256() const {
  // @@protoc_insertion_point(field_get:proto.InvoiceMessage.attachmentFileEncSha256)
  return _internal_attachmentfileencsha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceMessage::set_attachmentfileencsha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.attachmentfileencsha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.InvoiceMessage.attachmentFileEncSha256)
}
inline std::string* InvoiceMessage::mutable_attachmentfileencsha256() {
  std::string* _s = _internal_mutable_attachmentfileencsha256();
  // @@protoc_insertion_point(field_mutable:proto.InvoiceMessage.attachmentFileEncSha256)
  return _s;
}
inline const std::string& InvoiceMessage::_internal_attachmentfileencsha256() const {
  return _impl_.attachmentfileencsha256_.Get();
}
inline void InvoiceMessage::_internal_set_attachmentfileencsha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.attachmentfileencsha256_.Set(value, GetArenaForAllocation());
}
inline std::string* InvoiceMessage::_internal_mutable_attachmentfileencsha256() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.attachmentfileencsha256_.Mutable(GetArenaForAllocation());
}
inline std::string* InvoiceMessage::release_attachmentfileencsha256() {
  // @@protoc_insertion_point(field_release:proto.InvoiceMessage.attachmentFileEncSha256)
  if (!_internal_has_attachmentfileencsha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.attachmentfileencsha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachmentfileencsha256_.IsDefault()) {
    _impl_.attachmentfileencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InvoiceMessage::set_allocated_attachmentfileencsha256(std::string* attachmentfileencsha256) {
  if (attachmentfileencsha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.attachmentfileencsha256_.SetAllocated(attachmentfileencsha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachmentfileencsha256_.IsDefault()) {
    _impl_.attachmentfileencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.InvoiceMessage.attachmentFileEncSha256)
}

// optional string attachmentDirectPath = 9;
inline bool InvoiceMessage::_internal_has_attachmentdirectpath() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool InvoiceMessage::has_attachmentdirectpath() const {
  return _internal_has_attachmentdirectpath();
}
inline void InvoiceMessage::clear_attachmentdirectpath() {
  _impl_.attachmentdirectpath_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& InvoiceMessage::attachmentdirectpath() const {
  // @@protoc_insertion_point(field_get:proto.InvoiceMessage.attachmentDirectPath)
  return _internal_attachmentdirectpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceMessage::set_attachmentdirectpath(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.attachmentdirectpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.InvoiceMessage.attachmentDirectPath)
}
inline std::string* InvoiceMessage::mutable_attachmentdirectpath() {
  std::string* _s = _internal_mutable_attachmentdirectpath();
  // @@protoc_insertion_point(field_mutable:proto.InvoiceMessage.attachmentDirectPath)
  return _s;
}
inline const std::string& InvoiceMessage::_internal_attachmentdirectpath() const {
  return _impl_.attachmentdirectpath_.Get();
}
inline void InvoiceMessage::_internal_set_attachmentdirectpath(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.attachmentdirectpath_.Set(value, GetArenaForAllocation());
}
inline std::string* InvoiceMessage::_internal_mutable_attachmentdirectpath() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.attachmentdirectpath_.Mutable(GetArenaForAllocation());
}
inline std::string* InvoiceMessage::release_attachmentdirectpath() {
  // @@protoc_insertion_point(field_release:proto.InvoiceMessage.attachmentDirectPath)
  if (!_internal_has_attachmentdirectpath()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.attachmentdirectpath_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachmentdirectpath_.IsDefault()) {
    _impl_.attachmentdirectpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InvoiceMessage::set_allocated_attachmentdirectpath(std::string* attachmentdirectpath) {
  if (attachmentdirectpath != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.attachmentdirectpath_.SetAllocated(attachmentdirectpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachmentdirectpath_.IsDefault()) {
    _impl_.attachmentdirectpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.InvoiceMessage.attachmentDirectPath)
}

// optional bytes attachmentJpegThumbnail = 10;
inline bool InvoiceMessage::_internal_has_attachmentjpegthumbnail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool InvoiceMessage::has_attachmentjpegthumbnail() const {
  return _internal_has_attachmentjpegthumbnail();
}
inline void InvoiceMessage::clear_attachmentjpegthumbnail() {
  _impl_.attachmentjpegthumbnail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& InvoiceMessage::attachmentjpegthumbnail() const {
  // @@protoc_insertion_point(field_get:proto.InvoiceMessage.attachmentJpegThumbnail)
  return _internal_attachmentjpegthumbnail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvoiceMessage::set_attachmentjpegthumbnail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.attachmentjpegthumbnail_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.InvoiceMessage.attachmentJpegThumbnail)
}
inline std::string* InvoiceMessage::mutable_attachmentjpegthumbnail() {
  std::string* _s = _internal_mutable_attachmentjpegthumbnail();
  // @@protoc_insertion_point(field_mutable:proto.InvoiceMessage.attachmentJpegThumbnail)
  return _s;
}
inline const std::string& InvoiceMessage::_internal_attachmentjpegthumbnail() const {
  return _impl_.attachmentjpegthumbnail_.Get();
}
inline void InvoiceMessage::_internal_set_attachmentjpegthumbnail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.attachmentjpegthumbnail_.Set(value, GetArenaForAllocation());
}
inline std::string* InvoiceMessage::_internal_mutable_attachmentjpegthumbnail() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.attachmentjpegthumbnail_.Mutable(GetArenaForAllocation());
}
inline std::string* InvoiceMessage::release_attachmentjpegthumbnail() {
  // @@protoc_insertion_point(field_release:proto.InvoiceMessage.attachmentJpegThumbnail)
  if (!_internal_has_attachmentjpegthumbnail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.attachmentjpegthumbnail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachmentjpegthumbnail_.IsDefault()) {
    _impl_.attachmentjpegthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InvoiceMessage::set_allocated_attachmentjpegthumbnail(std::string* attachmentjpegthumbnail) {
  if (attachmentjpegthumbnail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.attachmentjpegthumbnail_.SetAllocated(attachmentjpegthumbnail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachmentjpegthumbnail_.IsDefault()) {
    _impl_.attachmentjpegthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.InvoiceMessage.attachmentJpegThumbnail)
}

// -------------------------------------------------------------------

// ContactMessage

// optional string displayName = 1;
inline bool ContactMessage::_internal_has_displayname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContactMessage::has_displayname() const {
  return _internal_has_displayname();
}
inline void ContactMessage::clear_displayname() {
  _impl_.displayname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContactMessage::displayname() const {
  // @@protoc_insertion_point(field_get:proto.ContactMessage.displayName)
  return _internal_displayname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContactMessage::set_displayname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.displayname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ContactMessage.displayName)
}
inline std::string* ContactMessage::mutable_displayname() {
  std::string* _s = _internal_mutable_displayname();
  // @@protoc_insertion_point(field_mutable:proto.ContactMessage.displayName)
  return _s;
}
inline const std::string& ContactMessage::_internal_displayname() const {
  return _impl_.displayname_.Get();
}
inline void ContactMessage::_internal_set_displayname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.displayname_.Set(value, GetArenaForAllocation());
}
inline std::string* ContactMessage::_internal_mutable_displayname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.displayname_.Mutable(GetArenaForAllocation());
}
inline std::string* ContactMessage::release_displayname() {
  // @@protoc_insertion_point(field_release:proto.ContactMessage.displayName)
  if (!_internal_has_displayname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.displayname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displayname_.IsDefault()) {
    _impl_.displayname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContactMessage::set_allocated_displayname(std::string* displayname) {
  if (displayname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.displayname_.SetAllocated(displayname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displayname_.IsDefault()) {
    _impl_.displayname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ContactMessage.displayName)
}

// optional string vcard = 16;
inline bool ContactMessage::_internal_has_vcard() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContactMessage::has_vcard() const {
  return _internal_has_vcard();
}
inline void ContactMessage::clear_vcard() {
  _impl_.vcard_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContactMessage::vcard() const {
  // @@protoc_insertion_point(field_get:proto.ContactMessage.vcard)
  return _internal_vcard();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContactMessage::set_vcard(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.vcard_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ContactMessage.vcard)
}
inline std::string* ContactMessage::mutable_vcard() {
  std::string* _s = _internal_mutable_vcard();
  // @@protoc_insertion_point(field_mutable:proto.ContactMessage.vcard)
  return _s;
}
inline const std::string& ContactMessage::_internal_vcard() const {
  return _impl_.vcard_.Get();
}
inline void ContactMessage::_internal_set_vcard(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.vcard_.Set(value, GetArenaForAllocation());
}
inline std::string* ContactMessage::_internal_mutable_vcard() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.vcard_.Mutable(GetArenaForAllocation());
}
inline std::string* ContactMessage::release_vcard() {
  // @@protoc_insertion_point(field_release:proto.ContactMessage.vcard)
  if (!_internal_has_vcard()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.vcard_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vcard_.IsDefault()) {
    _impl_.vcard_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContactMessage::set_allocated_vcard(std::string* vcard) {
  if (vcard != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.vcard_.SetAllocated(vcard, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vcard_.IsDefault()) {
    _impl_.vcard_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ContactMessage.vcard)
}

// optional .proto.ContextInfo contextInfo = 17;
inline bool ContactMessage::_internal_has_contextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contextinfo_ != nullptr);
  return value;
}
inline bool ContactMessage::has_contextinfo() const {
  return _internal_has_contextinfo();
}
inline void ContactMessage::clear_contextinfo() {
  if (_impl_.contextinfo_ != nullptr) _impl_.contextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::proto::ContextInfo& ContactMessage::_internal_contextinfo() const {
  const ::proto::ContextInfo* p = _impl_.contextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContextInfo&>(
      ::proto::_ContextInfo_default_instance_);
}
inline const ::proto::ContextInfo& ContactMessage::contextinfo() const {
  // @@protoc_insertion_point(field_get:proto.ContactMessage.contextInfo)
  return _internal_contextinfo();
}
inline void ContactMessage::unsafe_arena_set_allocated_contextinfo(
    ::proto::ContextInfo* contextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextinfo_);
  }
  _impl_.contextinfo_ = contextinfo;
  if (contextinfo) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ContactMessage.contextInfo)
}
inline ::proto::ContextInfo* ContactMessage::release_contextinfo() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContextInfo* ContactMessage::unsafe_arena_release_contextinfo() {
  // @@protoc_insertion_point(field_release:proto.ContactMessage.contextInfo)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
  return temp;
}
inline ::proto::ContextInfo* ContactMessage::_internal_mutable_contextinfo() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.contextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContextInfo>(GetArenaForAllocation());
    _impl_.contextinfo_ = p;
  }
  return _impl_.contextinfo_;
}
inline ::proto::ContextInfo* ContactMessage::mutable_contextinfo() {
  ::proto::ContextInfo* _msg = _internal_mutable_contextinfo();
  // @@protoc_insertion_point(field_mutable:proto.ContactMessage.contextInfo)
  return _msg;
}
inline void ContactMessage::set_allocated_contextinfo(::proto::ContextInfo* contextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contextinfo_;
  }
  if (contextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contextinfo);
    if (message_arena != submessage_arena) {
      contextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.contextinfo_ = contextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.ContactMessage.contextInfo)
}

// -------------------------------------------------------------------

// LocationMessage

// optional double degreesLatitude = 1;
inline bool LocationMessage::_internal_has_degreeslatitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LocationMessage::has_degreeslatitude() const {
  return _internal_has_degreeslatitude();
}
inline void LocationMessage::clear_degreeslatitude() {
  _impl_.degreeslatitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double LocationMessage::_internal_degreeslatitude() const {
  return _impl_.degreeslatitude_;
}
inline double LocationMessage::degreeslatitude() const {
  // @@protoc_insertion_point(field_get:proto.LocationMessage.degreesLatitude)
  return _internal_degreeslatitude();
}
inline void LocationMessage::_internal_set_degreeslatitude(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.degreeslatitude_ = value;
}
inline void LocationMessage::set_degreeslatitude(double value) {
  _internal_set_degreeslatitude(value);
  // @@protoc_insertion_point(field_set:proto.LocationMessage.degreesLatitude)
}

// optional double degreesLongitude = 2;
inline bool LocationMessage::_internal_has_degreeslongitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LocationMessage::has_degreeslongitude() const {
  return _internal_has_degreeslongitude();
}
inline void LocationMessage::clear_degreeslongitude() {
  _impl_.degreeslongitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double LocationMessage::_internal_degreeslongitude() const {
  return _impl_.degreeslongitude_;
}
inline double LocationMessage::degreeslongitude() const {
  // @@protoc_insertion_point(field_get:proto.LocationMessage.degreesLongitude)
  return _internal_degreeslongitude();
}
inline void LocationMessage::_internal_set_degreeslongitude(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.degreeslongitude_ = value;
}
inline void LocationMessage::set_degreeslongitude(double value) {
  _internal_set_degreeslongitude(value);
  // @@protoc_insertion_point(field_set:proto.LocationMessage.degreesLongitude)
}

// optional string name = 3;
inline bool LocationMessage::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LocationMessage::has_name() const {
  return _internal_has_name();
}
inline void LocationMessage::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LocationMessage::name() const {
  // @@protoc_insertion_point(field_get:proto.LocationMessage.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationMessage::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.LocationMessage.name)
}
inline std::string* LocationMessage::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.LocationMessage.name)
  return _s;
}
inline const std::string& LocationMessage::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LocationMessage::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationMessage::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationMessage::release_name() {
  // @@protoc_insertion_point(field_release:proto.LocationMessage.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LocationMessage::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.LocationMessage.name)
}

// optional string address = 4;
inline bool LocationMessage::_internal_has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LocationMessage::has_address() const {
  return _internal_has_address();
}
inline void LocationMessage::clear_address() {
  _impl_.address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LocationMessage::address() const {
  // @@protoc_insertion_point(field_get:proto.LocationMessage.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationMessage::set_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.LocationMessage.address)
}
inline std::string* LocationMessage::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:proto.LocationMessage.address)
  return _s;
}
inline const std::string& LocationMessage::_internal_address() const {
  return _impl_.address_.Get();
}
inline void LocationMessage::_internal_set_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationMessage::_internal_mutable_address() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationMessage::release_address() {
  // @@protoc_insertion_point(field_release:proto.LocationMessage.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LocationMessage::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.LocationMessage.address)
}

// optional string url = 5;
inline bool LocationMessage::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LocationMessage::has_url() const {
  return _internal_has_url();
}
inline void LocationMessage::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LocationMessage::url() const {
  // @@protoc_insertion_point(field_get:proto.LocationMessage.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationMessage::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.LocationMessage.url)
}
inline std::string* LocationMessage::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:proto.LocationMessage.url)
  return _s;
}
inline const std::string& LocationMessage::_internal_url() const {
  return _impl_.url_.Get();
}
inline void LocationMessage::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationMessage::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationMessage::release_url() {
  // @@protoc_insertion_point(field_release:proto.LocationMessage.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LocationMessage::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.LocationMessage.url)
}

// optional bool isLive = 6;
inline bool LocationMessage::_internal_has_islive() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool LocationMessage::has_islive() const {
  return _internal_has_islive();
}
inline void LocationMessage::clear_islive() {
  _impl_.islive_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool LocationMessage::_internal_islive() const {
  return _impl_.islive_;
}
inline bool LocationMessage::islive() const {
  // @@protoc_insertion_point(field_get:proto.LocationMessage.isLive)
  return _internal_islive();
}
inline void LocationMessage::_internal_set_islive(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.islive_ = value;
}
inline void LocationMessage::set_islive(bool value) {
  _internal_set_islive(value);
  // @@protoc_insertion_point(field_set:proto.LocationMessage.isLive)
}

// optional uint32 accuracyInMeters = 7;
inline bool LocationMessage::_internal_has_accuracyinmeters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool LocationMessage::has_accuracyinmeters() const {
  return _internal_has_accuracyinmeters();
}
inline void LocationMessage::clear_accuracyinmeters() {
  _impl_.accuracyinmeters_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t LocationMessage::_internal_accuracyinmeters() const {
  return _impl_.accuracyinmeters_;
}
inline uint32_t LocationMessage::accuracyinmeters() const {
  // @@protoc_insertion_point(field_get:proto.LocationMessage.accuracyInMeters)
  return _internal_accuracyinmeters();
}
inline void LocationMessage::_internal_set_accuracyinmeters(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.accuracyinmeters_ = value;
}
inline void LocationMessage::set_accuracyinmeters(uint32_t value) {
  _internal_set_accuracyinmeters(value);
  // @@protoc_insertion_point(field_set:proto.LocationMessage.accuracyInMeters)
}

// optional float speedInMps = 8;
inline bool LocationMessage::_internal_has_speedinmps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool LocationMessage::has_speedinmps() const {
  return _internal_has_speedinmps();
}
inline void LocationMessage::clear_speedinmps() {
  _impl_.speedinmps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float LocationMessage::_internal_speedinmps() const {
  return _impl_.speedinmps_;
}
inline float LocationMessage::speedinmps() const {
  // @@protoc_insertion_point(field_get:proto.LocationMessage.speedInMps)
  return _internal_speedinmps();
}
inline void LocationMessage::_internal_set_speedinmps(float value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.speedinmps_ = value;
}
inline void LocationMessage::set_speedinmps(float value) {
  _internal_set_speedinmps(value);
  // @@protoc_insertion_point(field_set:proto.LocationMessage.speedInMps)
}

// optional uint32 degreesClockwiseFromMagneticNorth = 9;
inline bool LocationMessage::_internal_has_degreesclockwisefrommagneticnorth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool LocationMessage::has_degreesclockwisefrommagneticnorth() const {
  return _internal_has_degreesclockwisefrommagneticnorth();
}
inline void LocationMessage::clear_degreesclockwisefrommagneticnorth() {
  _impl_.degreesclockwisefrommagneticnorth_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint32_t LocationMessage::_internal_degreesclockwisefrommagneticnorth() const {
  return _impl_.degreesclockwisefrommagneticnorth_;
}
inline uint32_t LocationMessage::degreesclockwisefrommagneticnorth() const {
  // @@protoc_insertion_point(field_get:proto.LocationMessage.degreesClockwiseFromMagneticNorth)
  return _internal_degreesclockwisefrommagneticnorth();
}
inline void LocationMessage::_internal_set_degreesclockwisefrommagneticnorth(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.degreesclockwisefrommagneticnorth_ = value;
}
inline void LocationMessage::set_degreesclockwisefrommagneticnorth(uint32_t value) {
  _internal_set_degreesclockwisefrommagneticnorth(value);
  // @@protoc_insertion_point(field_set:proto.LocationMessage.degreesClockwiseFromMagneticNorth)
}

// optional string comment = 11;
inline bool LocationMessage::_internal_has_comment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LocationMessage::has_comment() const {
  return _internal_has_comment();
}
inline void LocationMessage::clear_comment() {
  _impl_.comment_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& LocationMessage::comment() const {
  // @@protoc_insertion_point(field_get:proto.LocationMessage.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationMessage::set_comment(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.LocationMessage.comment)
}
inline std::string* LocationMessage::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:proto.LocationMessage.comment)
  return _s;
}
inline const std::string& LocationMessage::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void LocationMessage::_internal_set_comment(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationMessage::_internal_mutable_comment() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationMessage::release_comment() {
  // @@protoc_insertion_point(field_release:proto.LocationMessage.comment)
  if (!_internal_has_comment()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.comment_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LocationMessage::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.LocationMessage.comment)
}

// optional bytes jpegThumbnail = 16;
inline bool LocationMessage::_internal_has_jpegthumbnail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LocationMessage::has_jpegthumbnail() const {
  return _internal_has_jpegthumbnail();
}
inline void LocationMessage::clear_jpegthumbnail() {
  _impl_.jpegthumbnail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& LocationMessage::jpegthumbnail() const {
  // @@protoc_insertion_point(field_get:proto.LocationMessage.jpegThumbnail)
  return _internal_jpegthumbnail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationMessage::set_jpegthumbnail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.jpegthumbnail_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.LocationMessage.jpegThumbnail)
}
inline std::string* LocationMessage::mutable_jpegthumbnail() {
  std::string* _s = _internal_mutable_jpegthumbnail();
  // @@protoc_insertion_point(field_mutable:proto.LocationMessage.jpegThumbnail)
  return _s;
}
inline const std::string& LocationMessage::_internal_jpegthumbnail() const {
  return _impl_.jpegthumbnail_.Get();
}
inline void LocationMessage::_internal_set_jpegthumbnail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.jpegthumbnail_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationMessage::_internal_mutable_jpegthumbnail() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.jpegthumbnail_.Mutable(GetArenaForAllocation());
}
inline std::string* LocationMessage::release_jpegthumbnail() {
  // @@protoc_insertion_point(field_release:proto.LocationMessage.jpegThumbnail)
  if (!_internal_has_jpegthumbnail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.jpegthumbnail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jpegthumbnail_.IsDefault()) {
    _impl_.jpegthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LocationMessage::set_allocated_jpegthumbnail(std::string* jpegthumbnail) {
  if (jpegthumbnail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.jpegthumbnail_.SetAllocated(jpegthumbnail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jpegthumbnail_.IsDefault()) {
    _impl_.jpegthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.LocationMessage.jpegThumbnail)
}

// optional .proto.ContextInfo contextInfo = 17;
inline bool LocationMessage::_internal_has_contextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contextinfo_ != nullptr);
  return value;
}
inline bool LocationMessage::has_contextinfo() const {
  return _internal_has_contextinfo();
}
inline void LocationMessage::clear_contextinfo() {
  if (_impl_.contextinfo_ != nullptr) _impl_.contextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::proto::ContextInfo& LocationMessage::_internal_contextinfo() const {
  const ::proto::ContextInfo* p = _impl_.contextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContextInfo&>(
      ::proto::_ContextInfo_default_instance_);
}
inline const ::proto::ContextInfo& LocationMessage::contextinfo() const {
  // @@protoc_insertion_point(field_get:proto.LocationMessage.contextInfo)
  return _internal_contextinfo();
}
inline void LocationMessage::unsafe_arena_set_allocated_contextinfo(
    ::proto::ContextInfo* contextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextinfo_);
  }
  _impl_.contextinfo_ = contextinfo;
  if (contextinfo) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.LocationMessage.contextInfo)
}
inline ::proto::ContextInfo* LocationMessage::release_contextinfo() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContextInfo* LocationMessage::unsafe_arena_release_contextinfo() {
  // @@protoc_insertion_point(field_release:proto.LocationMessage.contextInfo)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
  return temp;
}
inline ::proto::ContextInfo* LocationMessage::_internal_mutable_contextinfo() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.contextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContextInfo>(GetArenaForAllocation());
    _impl_.contextinfo_ = p;
  }
  return _impl_.contextinfo_;
}
inline ::proto::ContextInfo* LocationMessage::mutable_contextinfo() {
  ::proto::ContextInfo* _msg = _internal_mutable_contextinfo();
  // @@protoc_insertion_point(field_mutable:proto.LocationMessage.contextInfo)
  return _msg;
}
inline void LocationMessage::set_allocated_contextinfo(::proto::ContextInfo* contextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contextinfo_;
  }
  if (contextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contextinfo);
    if (message_arena != submessage_arena) {
      contextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.contextinfo_ = contextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.LocationMessage.contextInfo)
}

// -------------------------------------------------------------------

// ExtendedTextMessage

// optional string text = 1;
inline bool ExtendedTextMessage::_internal_has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExtendedTextMessage::has_text() const {
  return _internal_has_text();
}
inline void ExtendedTextMessage::clear_text() {
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExtendedTextMessage::text() const {
  // @@protoc_insertion_point(field_get:proto.ExtendedTextMessage.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtendedTextMessage::set_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ExtendedTextMessage.text)
}
inline std::string* ExtendedTextMessage::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:proto.ExtendedTextMessage.text)
  return _s;
}
inline const std::string& ExtendedTextMessage::_internal_text() const {
  return _impl_.text_.Get();
}
inline void ExtendedTextMessage::_internal_set_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtendedTextMessage::_internal_mutable_text() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtendedTextMessage::release_text() {
  // @@protoc_insertion_point(field_release:proto.ExtendedTextMessage.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExtendedTextMessage::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ExtendedTextMessage.text)
}

// optional string matchedText = 2;
inline bool ExtendedTextMessage::_internal_has_matchedtext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExtendedTextMessage::has_matchedtext() const {
  return _internal_has_matchedtext();
}
inline void ExtendedTextMessage::clear_matchedtext() {
  _impl_.matchedtext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ExtendedTextMessage::matchedtext() const {
  // @@protoc_insertion_point(field_get:proto.ExtendedTextMessage.matchedText)
  return _internal_matchedtext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtendedTextMessage::set_matchedtext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.matchedtext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ExtendedTextMessage.matchedText)
}
inline std::string* ExtendedTextMessage::mutable_matchedtext() {
  std::string* _s = _internal_mutable_matchedtext();
  // @@protoc_insertion_point(field_mutable:proto.ExtendedTextMessage.matchedText)
  return _s;
}
inline const std::string& ExtendedTextMessage::_internal_matchedtext() const {
  return _impl_.matchedtext_.Get();
}
inline void ExtendedTextMessage::_internal_set_matchedtext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.matchedtext_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtendedTextMessage::_internal_mutable_matchedtext() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.matchedtext_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtendedTextMessage::release_matchedtext() {
  // @@protoc_insertion_point(field_release:proto.ExtendedTextMessage.matchedText)
  if (!_internal_has_matchedtext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.matchedtext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.matchedtext_.IsDefault()) {
    _impl_.matchedtext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExtendedTextMessage::set_allocated_matchedtext(std::string* matchedtext) {
  if (matchedtext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.matchedtext_.SetAllocated(matchedtext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.matchedtext_.IsDefault()) {
    _impl_.matchedtext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ExtendedTextMessage.matchedText)
}

// optional string canonicalUrl = 4;
inline bool ExtendedTextMessage::_internal_has_canonicalurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExtendedTextMessage::has_canonicalurl() const {
  return _internal_has_canonicalurl();
}
inline void ExtendedTextMessage::clear_canonicalurl() {
  _impl_.canonicalurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ExtendedTextMessage::canonicalurl() const {
  // @@protoc_insertion_point(field_get:proto.ExtendedTextMessage.canonicalUrl)
  return _internal_canonicalurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtendedTextMessage::set_canonicalurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.canonicalurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ExtendedTextMessage.canonicalUrl)
}
inline std::string* ExtendedTextMessage::mutable_canonicalurl() {
  std::string* _s = _internal_mutable_canonicalurl();
  // @@protoc_insertion_point(field_mutable:proto.ExtendedTextMessage.canonicalUrl)
  return _s;
}
inline const std::string& ExtendedTextMessage::_internal_canonicalurl() const {
  return _impl_.canonicalurl_.Get();
}
inline void ExtendedTextMessage::_internal_set_canonicalurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.canonicalurl_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtendedTextMessage::_internal_mutable_canonicalurl() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.canonicalurl_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtendedTextMessage::release_canonicalurl() {
  // @@protoc_insertion_point(field_release:proto.ExtendedTextMessage.canonicalUrl)
  if (!_internal_has_canonicalurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.canonicalurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.canonicalurl_.IsDefault()) {
    _impl_.canonicalurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExtendedTextMessage::set_allocated_canonicalurl(std::string* canonicalurl) {
  if (canonicalurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.canonicalurl_.SetAllocated(canonicalurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.canonicalurl_.IsDefault()) {
    _impl_.canonicalurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ExtendedTextMessage.canonicalUrl)
}

// optional string description = 5;
inline bool ExtendedTextMessage::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ExtendedTextMessage::has_description() const {
  return _internal_has_description();
}
inline void ExtendedTextMessage::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ExtendedTextMessage::description() const {
  // @@protoc_insertion_point(field_get:proto.ExtendedTextMessage.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtendedTextMessage::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ExtendedTextMessage.description)
}
inline std::string* ExtendedTextMessage::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:proto.ExtendedTextMessage.description)
  return _s;
}
inline const std::string& ExtendedTextMessage::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ExtendedTextMessage::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtendedTextMessage::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtendedTextMessage::release_description() {
  // @@protoc_insertion_point(field_release:proto.ExtendedTextMessage.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExtendedTextMessage::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ExtendedTextMessage.description)
}

// optional string title = 6;
inline bool ExtendedTextMessage::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ExtendedTextMessage::has_title() const {
  return _internal_has_title();
}
inline void ExtendedTextMessage::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ExtendedTextMessage::title() const {
  // @@protoc_insertion_point(field_get:proto.ExtendedTextMessage.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtendedTextMessage::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ExtendedTextMessage.title)
}
inline std::string* ExtendedTextMessage::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:proto.ExtendedTextMessage.title)
  return _s;
}
inline const std::string& ExtendedTextMessage::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ExtendedTextMessage::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtendedTextMessage::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtendedTextMessage::release_title() {
  // @@protoc_insertion_point(field_release:proto.ExtendedTextMessage.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExtendedTextMessage::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ExtendedTextMessage.title)
}

// optional fixed32 textArgb = 7;
inline bool ExtendedTextMessage::_internal_has_textargb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ExtendedTextMessage::has_textargb() const {
  return _internal_has_textargb();
}
inline void ExtendedTextMessage::clear_textargb() {
  _impl_.textargb_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t ExtendedTextMessage::_internal_textargb() const {
  return _impl_.textargb_;
}
inline uint32_t ExtendedTextMessage::textargb() const {
  // @@protoc_insertion_point(field_get:proto.ExtendedTextMessage.textArgb)
  return _internal_textargb();
}
inline void ExtendedTextMessage::_internal_set_textargb(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.textargb_ = value;
}
inline void ExtendedTextMessage::set_textargb(uint32_t value) {
  _internal_set_textargb(value);
  // @@protoc_insertion_point(field_set:proto.ExtendedTextMessage.textArgb)
}

// optional fixed32 backgroundArgb = 8;
inline bool ExtendedTextMessage::_internal_has_backgroundargb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ExtendedTextMessage::has_backgroundargb() const {
  return _internal_has_backgroundargb();
}
inline void ExtendedTextMessage::clear_backgroundargb() {
  _impl_.backgroundargb_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t ExtendedTextMessage::_internal_backgroundargb() const {
  return _impl_.backgroundargb_;
}
inline uint32_t ExtendedTextMessage::backgroundargb() const {
  // @@protoc_insertion_point(field_get:proto.ExtendedTextMessage.backgroundArgb)
  return _internal_backgroundargb();
}
inline void ExtendedTextMessage::_internal_set_backgroundargb(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.backgroundargb_ = value;
}
inline void ExtendedTextMessage::set_backgroundargb(uint32_t value) {
  _internal_set_backgroundargb(value);
  // @@protoc_insertion_point(field_set:proto.ExtendedTextMessage.backgroundArgb)
}

// optional .proto.ExtendedTextMessage.ExtendedTextMessageFontType font = 9;
inline bool ExtendedTextMessage::_internal_has_font() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ExtendedTextMessage::has_font() const {
  return _internal_has_font();
}
inline void ExtendedTextMessage::clear_font() {
  _impl_.font_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::proto::ExtendedTextMessage_ExtendedTextMessageFontType ExtendedTextMessage::_internal_font() const {
  return static_cast< ::proto::ExtendedTextMessage_ExtendedTextMessageFontType >(_impl_.font_);
}
inline ::proto::ExtendedTextMessage_ExtendedTextMessageFontType ExtendedTextMessage::font() const {
  // @@protoc_insertion_point(field_get:proto.ExtendedTextMessage.font)
  return _internal_font();
}
inline void ExtendedTextMessage::_internal_set_font(::proto::ExtendedTextMessage_ExtendedTextMessageFontType value) {
  assert(::proto::ExtendedTextMessage_ExtendedTextMessageFontType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.font_ = value;
}
inline void ExtendedTextMessage::set_font(::proto::ExtendedTextMessage_ExtendedTextMessageFontType value) {
  _internal_set_font(value);
  // @@protoc_insertion_point(field_set:proto.ExtendedTextMessage.font)
}

// optional .proto.ExtendedTextMessage.ExtendedTextMessagePreviewType previewType = 10;
inline bool ExtendedTextMessage::_internal_has_previewtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ExtendedTextMessage::has_previewtype() const {
  return _internal_has_previewtype();
}
inline void ExtendedTextMessage::clear_previewtype() {
  _impl_.previewtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::proto::ExtendedTextMessage_ExtendedTextMessagePreviewType ExtendedTextMessage::_internal_previewtype() const {
  return static_cast< ::proto::ExtendedTextMessage_ExtendedTextMessagePreviewType >(_impl_.previewtype_);
}
inline ::proto::ExtendedTextMessage_ExtendedTextMessagePreviewType ExtendedTextMessage::previewtype() const {
  // @@protoc_insertion_point(field_get:proto.ExtendedTextMessage.previewType)
  return _internal_previewtype();
}
inline void ExtendedTextMessage::_internal_set_previewtype(::proto::ExtendedTextMessage_ExtendedTextMessagePreviewType value) {
  assert(::proto::ExtendedTextMessage_ExtendedTextMessagePreviewType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.previewtype_ = value;
}
inline void ExtendedTextMessage::set_previewtype(::proto::ExtendedTextMessage_ExtendedTextMessagePreviewType value) {
  _internal_set_previewtype(value);
  // @@protoc_insertion_point(field_set:proto.ExtendedTextMessage.previewType)
}

// optional bytes jpegThumbnail = 16;
inline bool ExtendedTextMessage::_internal_has_jpegthumbnail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ExtendedTextMessage::has_jpegthumbnail() const {
  return _internal_has_jpegthumbnail();
}
inline void ExtendedTextMessage::clear_jpegthumbnail() {
  _impl_.jpegthumbnail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ExtendedTextMessage::jpegthumbnail() const {
  // @@protoc_insertion_point(field_get:proto.ExtendedTextMessage.jpegThumbnail)
  return _internal_jpegthumbnail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtendedTextMessage::set_jpegthumbnail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.jpegthumbnail_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ExtendedTextMessage.jpegThumbnail)
}
inline std::string* ExtendedTextMessage::mutable_jpegthumbnail() {
  std::string* _s = _internal_mutable_jpegthumbnail();
  // @@protoc_insertion_point(field_mutable:proto.ExtendedTextMessage.jpegThumbnail)
  return _s;
}
inline const std::string& ExtendedTextMessage::_internal_jpegthumbnail() const {
  return _impl_.jpegthumbnail_.Get();
}
inline void ExtendedTextMessage::_internal_set_jpegthumbnail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.jpegthumbnail_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtendedTextMessage::_internal_mutable_jpegthumbnail() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.jpegthumbnail_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtendedTextMessage::release_jpegthumbnail() {
  // @@protoc_insertion_point(field_release:proto.ExtendedTextMessage.jpegThumbnail)
  if (!_internal_has_jpegthumbnail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.jpegthumbnail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jpegthumbnail_.IsDefault()) {
    _impl_.jpegthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExtendedTextMessage::set_allocated_jpegthumbnail(std::string* jpegthumbnail) {
  if (jpegthumbnail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.jpegthumbnail_.SetAllocated(jpegthumbnail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jpegthumbnail_.IsDefault()) {
    _impl_.jpegthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ExtendedTextMessage.jpegThumbnail)
}

// optional .proto.ContextInfo contextInfo = 17;
inline bool ExtendedTextMessage::_internal_has_contextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contextinfo_ != nullptr);
  return value;
}
inline bool ExtendedTextMessage::has_contextinfo() const {
  return _internal_has_contextinfo();
}
inline void ExtendedTextMessage::clear_contextinfo() {
  if (_impl_.contextinfo_ != nullptr) _impl_.contextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::proto::ContextInfo& ExtendedTextMessage::_internal_contextinfo() const {
  const ::proto::ContextInfo* p = _impl_.contextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContextInfo&>(
      ::proto::_ContextInfo_default_instance_);
}
inline const ::proto::ContextInfo& ExtendedTextMessage::contextinfo() const {
  // @@protoc_insertion_point(field_get:proto.ExtendedTextMessage.contextInfo)
  return _internal_contextinfo();
}
inline void ExtendedTextMessage::unsafe_arena_set_allocated_contextinfo(
    ::proto::ContextInfo* contextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextinfo_);
  }
  _impl_.contextinfo_ = contextinfo;
  if (contextinfo) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ExtendedTextMessage.contextInfo)
}
inline ::proto::ContextInfo* ExtendedTextMessage::release_contextinfo() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContextInfo* ExtendedTextMessage::unsafe_arena_release_contextinfo() {
  // @@protoc_insertion_point(field_release:proto.ExtendedTextMessage.contextInfo)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
  return temp;
}
inline ::proto::ContextInfo* ExtendedTextMessage::_internal_mutable_contextinfo() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.contextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContextInfo>(GetArenaForAllocation());
    _impl_.contextinfo_ = p;
  }
  return _impl_.contextinfo_;
}
inline ::proto::ContextInfo* ExtendedTextMessage::mutable_contextinfo() {
  ::proto::ContextInfo* _msg = _internal_mutable_contextinfo();
  // @@protoc_insertion_point(field_mutable:proto.ExtendedTextMessage.contextInfo)
  return _msg;
}
inline void ExtendedTextMessage::set_allocated_contextinfo(::proto::ContextInfo* contextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contextinfo_;
  }
  if (contextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contextinfo);
    if (message_arena != submessage_arena) {
      contextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.contextinfo_ = contextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.ExtendedTextMessage.contextInfo)
}

// optional bool doNotPlayInline = 18;
inline bool ExtendedTextMessage::_internal_has_donotplayinline() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ExtendedTextMessage::has_donotplayinline() const {
  return _internal_has_donotplayinline();
}
inline void ExtendedTextMessage::clear_donotplayinline() {
  _impl_.donotplayinline_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool ExtendedTextMessage::_internal_donotplayinline() const {
  return _impl_.donotplayinline_;
}
inline bool ExtendedTextMessage::donotplayinline() const {
  // @@protoc_insertion_point(field_get:proto.ExtendedTextMessage.doNotPlayInline)
  return _internal_donotplayinline();
}
inline void ExtendedTextMessage::_internal_set_donotplayinline(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.donotplayinline_ = value;
}
inline void ExtendedTextMessage::set_donotplayinline(bool value) {
  _internal_set_donotplayinline(value);
  // @@protoc_insertion_point(field_set:proto.ExtendedTextMessage.doNotPlayInline)
}

// -------------------------------------------------------------------

// DocumentMessage

// optional string url = 1;
inline bool DocumentMessage::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DocumentMessage::has_url() const {
  return _internal_has_url();
}
inline void DocumentMessage::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DocumentMessage::url() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentMessage::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DocumentMessage.url)
}
inline std::string* DocumentMessage::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:proto.DocumentMessage.url)
  return _s;
}
inline const std::string& DocumentMessage::_internal_url() const {
  return _impl_.url_.Get();
}
inline void DocumentMessage::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentMessage::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentMessage::release_url() {
  // @@protoc_insertion_point(field_release:proto.DocumentMessage.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocumentMessage::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DocumentMessage.url)
}

// optional string mimetype = 2;
inline bool DocumentMessage::_internal_has_mimetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DocumentMessage::has_mimetype() const {
  return _internal_has_mimetype();
}
inline void DocumentMessage::clear_mimetype() {
  _impl_.mimetype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DocumentMessage::mimetype() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.mimetype)
  return _internal_mimetype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentMessage::set_mimetype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.mimetype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DocumentMessage.mimetype)
}
inline std::string* DocumentMessage::mutable_mimetype() {
  std::string* _s = _internal_mutable_mimetype();
  // @@protoc_insertion_point(field_mutable:proto.DocumentMessage.mimetype)
  return _s;
}
inline const std::string& DocumentMessage::_internal_mimetype() const {
  return _impl_.mimetype_.Get();
}
inline void DocumentMessage::_internal_set_mimetype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mimetype_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentMessage::_internal_mutable_mimetype() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mimetype_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentMessage::release_mimetype() {
  // @@protoc_insertion_point(field_release:proto.DocumentMessage.mimetype)
  if (!_internal_has_mimetype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.mimetype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mimetype_.IsDefault()) {
    _impl_.mimetype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocumentMessage::set_allocated_mimetype(std::string* mimetype) {
  if (mimetype != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mimetype_.SetAllocated(mimetype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mimetype_.IsDefault()) {
    _impl_.mimetype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DocumentMessage.mimetype)
}

// optional string title = 3;
inline bool DocumentMessage::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DocumentMessage::has_title() const {
  return _internal_has_title();
}
inline void DocumentMessage::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DocumentMessage::title() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentMessage::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DocumentMessage.title)
}
inline std::string* DocumentMessage::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:proto.DocumentMessage.title)
  return _s;
}
inline const std::string& DocumentMessage::_internal_title() const {
  return _impl_.title_.Get();
}
inline void DocumentMessage::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentMessage::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentMessage::release_title() {
  // @@protoc_insertion_point(field_release:proto.DocumentMessage.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocumentMessage::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DocumentMessage.title)
}

// optional bytes fileSha256 = 4;
inline bool DocumentMessage::_internal_has_filesha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DocumentMessage::has_filesha256() const {
  return _internal_has_filesha256();
}
inline void DocumentMessage::clear_filesha256() {
  _impl_.filesha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DocumentMessage::filesha256() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.fileSha256)
  return _internal_filesha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentMessage::set_filesha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.filesha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DocumentMessage.fileSha256)
}
inline std::string* DocumentMessage::mutable_filesha256() {
  std::string* _s = _internal_mutable_filesha256();
  // @@protoc_insertion_point(field_mutable:proto.DocumentMessage.fileSha256)
  return _s;
}
inline const std::string& DocumentMessage::_internal_filesha256() const {
  return _impl_.filesha256_.Get();
}
inline void DocumentMessage::_internal_set_filesha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.filesha256_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentMessage::_internal_mutable_filesha256() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.filesha256_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentMessage::release_filesha256() {
  // @@protoc_insertion_point(field_release:proto.DocumentMessage.fileSha256)
  if (!_internal_has_filesha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.filesha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filesha256_.IsDefault()) {
    _impl_.filesha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocumentMessage::set_allocated_filesha256(std::string* filesha256) {
  if (filesha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.filesha256_.SetAllocated(filesha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filesha256_.IsDefault()) {
    _impl_.filesha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DocumentMessage.fileSha256)
}

// optional uint64 fileLength = 5;
inline bool DocumentMessage::_internal_has_filelength() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool DocumentMessage::has_filelength() const {
  return _internal_has_filelength();
}
inline void DocumentMessage::clear_filelength() {
  _impl_.filelength_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint64_t DocumentMessage::_internal_filelength() const {
  return _impl_.filelength_;
}
inline uint64_t DocumentMessage::filelength() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.fileLength)
  return _internal_filelength();
}
inline void DocumentMessage::_internal_set_filelength(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.filelength_ = value;
}
inline void DocumentMessage::set_filelength(uint64_t value) {
  _internal_set_filelength(value);
  // @@protoc_insertion_point(field_set:proto.DocumentMessage.fileLength)
}

// optional uint32 pageCount = 6;
inline bool DocumentMessage::_internal_has_pagecount() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool DocumentMessage::has_pagecount() const {
  return _internal_has_pagecount();
}
inline void DocumentMessage::clear_pagecount() {
  _impl_.pagecount_ = 0u;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline uint32_t DocumentMessage::_internal_pagecount() const {
  return _impl_.pagecount_;
}
inline uint32_t DocumentMessage::pagecount() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.pageCount)
  return _internal_pagecount();
}
inline void DocumentMessage::_internal_set_pagecount(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.pagecount_ = value;
}
inline void DocumentMessage::set_pagecount(uint32_t value) {
  _internal_set_pagecount(value);
  // @@protoc_insertion_point(field_set:proto.DocumentMessage.pageCount)
}

// optional bytes mediaKey = 7;
inline bool DocumentMessage::_internal_has_mediakey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DocumentMessage::has_mediakey() const {
  return _internal_has_mediakey();
}
inline void DocumentMessage::clear_mediakey() {
  _impl_.mediakey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DocumentMessage::mediakey() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.mediaKey)
  return _internal_mediakey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentMessage::set_mediakey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.mediakey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DocumentMessage.mediaKey)
}
inline std::string* DocumentMessage::mutable_mediakey() {
  std::string* _s = _internal_mutable_mediakey();
  // @@protoc_insertion_point(field_mutable:proto.DocumentMessage.mediaKey)
  return _s;
}
inline const std::string& DocumentMessage::_internal_mediakey() const {
  return _impl_.mediakey_.Get();
}
inline void DocumentMessage::_internal_set_mediakey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.mediakey_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentMessage::_internal_mutable_mediakey() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.mediakey_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentMessage::release_mediakey() {
  // @@protoc_insertion_point(field_release:proto.DocumentMessage.mediaKey)
  if (!_internal_has_mediakey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.mediakey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mediakey_.IsDefault()) {
    _impl_.mediakey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocumentMessage::set_allocated_mediakey(std::string* mediakey) {
  if (mediakey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.mediakey_.SetAllocated(mediakey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mediakey_.IsDefault()) {
    _impl_.mediakey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DocumentMessage.mediaKey)
}

// optional string fileName = 8;
inline bool DocumentMessage::_internal_has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DocumentMessage::has_filename() const {
  return _internal_has_filename();
}
inline void DocumentMessage::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& DocumentMessage::filename() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.fileName)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentMessage::set_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DocumentMessage.fileName)
}
inline std::string* DocumentMessage::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:proto.DocumentMessage.fileName)
  return _s;
}
inline const std::string& DocumentMessage::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void DocumentMessage::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentMessage::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentMessage::release_filename() {
  // @@protoc_insertion_point(field_release:proto.DocumentMessage.fileName)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocumentMessage::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DocumentMessage.fileName)
}

// optional bytes fileEncSha256 = 9;
inline bool DocumentMessage::_internal_has_fileencsha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DocumentMessage::has_fileencsha256() const {
  return _internal_has_fileencsha256();
}
inline void DocumentMessage::clear_fileencsha256() {
  _impl_.fileencsha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& DocumentMessage::fileencsha256() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.fileEncSha256)
  return _internal_fileencsha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentMessage::set_fileencsha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.fileencsha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DocumentMessage.fileEncSha256)
}
inline std::string* DocumentMessage::mutable_fileencsha256() {
  std::string* _s = _internal_mutable_fileencsha256();
  // @@protoc_insertion_point(field_mutable:proto.DocumentMessage.fileEncSha256)
  return _s;
}
inline const std::string& DocumentMessage::_internal_fileencsha256() const {
  return _impl_.fileencsha256_.Get();
}
inline void DocumentMessage::_internal_set_fileencsha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.fileencsha256_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentMessage::_internal_mutable_fileencsha256() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.fileencsha256_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentMessage::release_fileencsha256() {
  // @@protoc_insertion_point(field_release:proto.DocumentMessage.fileEncSha256)
  if (!_internal_has_fileencsha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.fileencsha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fileencsha256_.IsDefault()) {
    _impl_.fileencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocumentMessage::set_allocated_fileencsha256(std::string* fileencsha256) {
  if (fileencsha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.fileencsha256_.SetAllocated(fileencsha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fileencsha256_.IsDefault()) {
    _impl_.fileencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DocumentMessage.fileEncSha256)
}

// optional string directPath = 10;
inline bool DocumentMessage::_internal_has_directpath() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DocumentMessage::has_directpath() const {
  return _internal_has_directpath();
}
inline void DocumentMessage::clear_directpath() {
  _impl_.directpath_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& DocumentMessage::directpath() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.directPath)
  return _internal_directpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentMessage::set_directpath(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.directpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DocumentMessage.directPath)
}
inline std::string* DocumentMessage::mutable_directpath() {
  std::string* _s = _internal_mutable_directpath();
  // @@protoc_insertion_point(field_mutable:proto.DocumentMessage.directPath)
  return _s;
}
inline const std::string& DocumentMessage::_internal_directpath() const {
  return _impl_.directpath_.Get();
}
inline void DocumentMessage::_internal_set_directpath(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.directpath_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentMessage::_internal_mutable_directpath() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.directpath_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentMessage::release_directpath() {
  // @@protoc_insertion_point(field_release:proto.DocumentMessage.directPath)
  if (!_internal_has_directpath()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.directpath_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.directpath_.IsDefault()) {
    _impl_.directpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocumentMessage::set_allocated_directpath(std::string* directpath) {
  if (directpath != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.directpath_.SetAllocated(directpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.directpath_.IsDefault()) {
    _impl_.directpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DocumentMessage.directPath)
}

// optional int64 mediaKeyTimestamp = 11;
inline bool DocumentMessage::_internal_has_mediakeytimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool DocumentMessage::has_mediakeytimestamp() const {
  return _internal_has_mediakeytimestamp();
}
inline void DocumentMessage::clear_mediakeytimestamp() {
  _impl_.mediakeytimestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline int64_t DocumentMessage::_internal_mediakeytimestamp() const {
  return _impl_.mediakeytimestamp_;
}
inline int64_t DocumentMessage::mediakeytimestamp() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.mediaKeyTimestamp)
  return _internal_mediakeytimestamp();
}
inline void DocumentMessage::_internal_set_mediakeytimestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.mediakeytimestamp_ = value;
}
inline void DocumentMessage::set_mediakeytimestamp(int64_t value) {
  _internal_set_mediakeytimestamp(value);
  // @@protoc_insertion_point(field_set:proto.DocumentMessage.mediaKeyTimestamp)
}

// optional bool contactVcard = 12;
inline bool DocumentMessage::_internal_has_contactvcard() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool DocumentMessage::has_contactvcard() const {
  return _internal_has_contactvcard();
}
inline void DocumentMessage::clear_contactvcard() {
  _impl_.contactvcard_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool DocumentMessage::_internal_contactvcard() const {
  return _impl_.contactvcard_;
}
inline bool DocumentMessage::contactvcard() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.contactVcard)
  return _internal_contactvcard();
}
inline void DocumentMessage::_internal_set_contactvcard(bool value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.contactvcard_ = value;
}
inline void DocumentMessage::set_contactvcard(bool value) {
  _internal_set_contactvcard(value);
  // @@protoc_insertion_point(field_set:proto.DocumentMessage.contactVcard)
}

// optional string thumbnailDirectPath = 13;
inline bool DocumentMessage::_internal_has_thumbnaildirectpath() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DocumentMessage::has_thumbnaildirectpath() const {
  return _internal_has_thumbnaildirectpath();
}
inline void DocumentMessage::clear_thumbnaildirectpath() {
  _impl_.thumbnaildirectpath_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& DocumentMessage::thumbnaildirectpath() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.thumbnailDirectPath)
  return _internal_thumbnaildirectpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentMessage::set_thumbnaildirectpath(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.thumbnaildirectpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DocumentMessage.thumbnailDirectPath)
}
inline std::string* DocumentMessage::mutable_thumbnaildirectpath() {
  std::string* _s = _internal_mutable_thumbnaildirectpath();
  // @@protoc_insertion_point(field_mutable:proto.DocumentMessage.thumbnailDirectPath)
  return _s;
}
inline const std::string& DocumentMessage::_internal_thumbnaildirectpath() const {
  return _impl_.thumbnaildirectpath_.Get();
}
inline void DocumentMessage::_internal_set_thumbnaildirectpath(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.thumbnaildirectpath_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentMessage::_internal_mutable_thumbnaildirectpath() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.thumbnaildirectpath_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentMessage::release_thumbnaildirectpath() {
  // @@protoc_insertion_point(field_release:proto.DocumentMessage.thumbnailDirectPath)
  if (!_internal_has_thumbnaildirectpath()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.thumbnaildirectpath_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnaildirectpath_.IsDefault()) {
    _impl_.thumbnaildirectpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocumentMessage::set_allocated_thumbnaildirectpath(std::string* thumbnaildirectpath) {
  if (thumbnaildirectpath != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.thumbnaildirectpath_.SetAllocated(thumbnaildirectpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnaildirectpath_.IsDefault()) {
    _impl_.thumbnaildirectpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DocumentMessage.thumbnailDirectPath)
}

// optional bytes thumbnailSha256 = 14;
inline bool DocumentMessage::_internal_has_thumbnailsha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool DocumentMessage::has_thumbnailsha256() const {
  return _internal_has_thumbnailsha256();
}
inline void DocumentMessage::clear_thumbnailsha256() {
  _impl_.thumbnailsha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& DocumentMessage::thumbnailsha256() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.thumbnailSha256)
  return _internal_thumbnailsha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentMessage::set_thumbnailsha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000200u;
 _impl_.thumbnailsha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DocumentMessage.thumbnailSha256)
}
inline std::string* DocumentMessage::mutable_thumbnailsha256() {
  std::string* _s = _internal_mutable_thumbnailsha256();
  // @@protoc_insertion_point(field_mutable:proto.DocumentMessage.thumbnailSha256)
  return _s;
}
inline const std::string& DocumentMessage::_internal_thumbnailsha256() const {
  return _impl_.thumbnailsha256_.Get();
}
inline void DocumentMessage::_internal_set_thumbnailsha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.thumbnailsha256_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentMessage::_internal_mutable_thumbnailsha256() {
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.thumbnailsha256_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentMessage::release_thumbnailsha256() {
  // @@protoc_insertion_point(field_release:proto.DocumentMessage.thumbnailSha256)
  if (!_internal_has_thumbnailsha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* p = _impl_.thumbnailsha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailsha256_.IsDefault()) {
    _impl_.thumbnailsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocumentMessage::set_allocated_thumbnailsha256(std::string* thumbnailsha256) {
  if (thumbnailsha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.thumbnailsha256_.SetAllocated(thumbnailsha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailsha256_.IsDefault()) {
    _impl_.thumbnailsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DocumentMessage.thumbnailSha256)
}

// optional bytes thumbnailEncSha256 = 15;
inline bool DocumentMessage::_internal_has_thumbnailencsha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool DocumentMessage::has_thumbnailencsha256() const {
  return _internal_has_thumbnailencsha256();
}
inline void DocumentMessage::clear_thumbnailencsha256() {
  _impl_.thumbnailencsha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& DocumentMessage::thumbnailencsha256() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.thumbnailEncSha256)
  return _internal_thumbnailencsha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentMessage::set_thumbnailencsha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000400u;
 _impl_.thumbnailencsha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DocumentMessage.thumbnailEncSha256)
}
inline std::string* DocumentMessage::mutable_thumbnailencsha256() {
  std::string* _s = _internal_mutable_thumbnailencsha256();
  // @@protoc_insertion_point(field_mutable:proto.DocumentMessage.thumbnailEncSha256)
  return _s;
}
inline const std::string& DocumentMessage::_internal_thumbnailencsha256() const {
  return _impl_.thumbnailencsha256_.Get();
}
inline void DocumentMessage::_internal_set_thumbnailencsha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.thumbnailencsha256_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentMessage::_internal_mutable_thumbnailencsha256() {
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.thumbnailencsha256_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentMessage::release_thumbnailencsha256() {
  // @@protoc_insertion_point(field_release:proto.DocumentMessage.thumbnailEncSha256)
  if (!_internal_has_thumbnailencsha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* p = _impl_.thumbnailencsha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailencsha256_.IsDefault()) {
    _impl_.thumbnailencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocumentMessage::set_allocated_thumbnailencsha256(std::string* thumbnailencsha256) {
  if (thumbnailencsha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.thumbnailencsha256_.SetAllocated(thumbnailencsha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailencsha256_.IsDefault()) {
    _impl_.thumbnailencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DocumentMessage.thumbnailEncSha256)
}

// optional bytes jpegThumbnail = 16;
inline bool DocumentMessage::_internal_has_jpegthumbnail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool DocumentMessage::has_jpegthumbnail() const {
  return _internal_has_jpegthumbnail();
}
inline void DocumentMessage::clear_jpegthumbnail() {
  _impl_.jpegthumbnail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& DocumentMessage::jpegthumbnail() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.jpegThumbnail)
  return _internal_jpegthumbnail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentMessage::set_jpegthumbnail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000800u;
 _impl_.jpegthumbnail_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DocumentMessage.jpegThumbnail)
}
inline std::string* DocumentMessage::mutable_jpegthumbnail() {
  std::string* _s = _internal_mutable_jpegthumbnail();
  // @@protoc_insertion_point(field_mutable:proto.DocumentMessage.jpegThumbnail)
  return _s;
}
inline const std::string& DocumentMessage::_internal_jpegthumbnail() const {
  return _impl_.jpegthumbnail_.Get();
}
inline void DocumentMessage::_internal_set_jpegthumbnail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.jpegthumbnail_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentMessage::_internal_mutable_jpegthumbnail() {
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.jpegthumbnail_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentMessage::release_jpegthumbnail() {
  // @@protoc_insertion_point(field_release:proto.DocumentMessage.jpegThumbnail)
  if (!_internal_has_jpegthumbnail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* p = _impl_.jpegthumbnail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jpegthumbnail_.IsDefault()) {
    _impl_.jpegthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocumentMessage::set_allocated_jpegthumbnail(std::string* jpegthumbnail) {
  if (jpegthumbnail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.jpegthumbnail_.SetAllocated(jpegthumbnail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jpegthumbnail_.IsDefault()) {
    _impl_.jpegthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DocumentMessage.jpegThumbnail)
}

// optional .proto.ContextInfo contextInfo = 17;
inline bool DocumentMessage::_internal_has_contextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contextinfo_ != nullptr);
  return value;
}
inline bool DocumentMessage::has_contextinfo() const {
  return _internal_has_contextinfo();
}
inline void DocumentMessage::clear_contextinfo() {
  if (_impl_.contextinfo_ != nullptr) _impl_.contextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::proto::ContextInfo& DocumentMessage::_internal_contextinfo() const {
  const ::proto::ContextInfo* p = _impl_.contextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContextInfo&>(
      ::proto::_ContextInfo_default_instance_);
}
inline const ::proto::ContextInfo& DocumentMessage::contextinfo() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.contextInfo)
  return _internal_contextinfo();
}
inline void DocumentMessage::unsafe_arena_set_allocated_contextinfo(
    ::proto::ContextInfo* contextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextinfo_);
  }
  _impl_.contextinfo_ = contextinfo;
  if (contextinfo) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.DocumentMessage.contextInfo)
}
inline ::proto::ContextInfo* DocumentMessage::release_contextinfo() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContextInfo* DocumentMessage::unsafe_arena_release_contextinfo() {
  // @@protoc_insertion_point(field_release:proto.DocumentMessage.contextInfo)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
  return temp;
}
inline ::proto::ContextInfo* DocumentMessage::_internal_mutable_contextinfo() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.contextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContextInfo>(GetArenaForAllocation());
    _impl_.contextinfo_ = p;
  }
  return _impl_.contextinfo_;
}
inline ::proto::ContextInfo* DocumentMessage::mutable_contextinfo() {
  ::proto::ContextInfo* _msg = _internal_mutable_contextinfo();
  // @@protoc_insertion_point(field_mutable:proto.DocumentMessage.contextInfo)
  return _msg;
}
inline void DocumentMessage::set_allocated_contextinfo(::proto::ContextInfo* contextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contextinfo_;
  }
  if (contextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contextinfo);
    if (message_arena != submessage_arena) {
      contextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.contextinfo_ = contextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.DocumentMessage.contextInfo)
}

// optional uint32 thumbnailHeight = 18;
inline bool DocumentMessage::_internal_has_thumbnailheight() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool DocumentMessage::has_thumbnailheight() const {
  return _internal_has_thumbnailheight();
}
inline void DocumentMessage::clear_thumbnailheight() {
  _impl_.thumbnailheight_ = 0u;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline uint32_t DocumentMessage::_internal_thumbnailheight() const {
  return _impl_.thumbnailheight_;
}
inline uint32_t DocumentMessage::thumbnailheight() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.thumbnailHeight)
  return _internal_thumbnailheight();
}
inline void DocumentMessage::_internal_set_thumbnailheight(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.thumbnailheight_ = value;
}
inline void DocumentMessage::set_thumbnailheight(uint32_t value) {
  _internal_set_thumbnailheight(value);
  // @@protoc_insertion_point(field_set:proto.DocumentMessage.thumbnailHeight)
}

// optional uint32 thumbnailWidth = 19;
inline bool DocumentMessage::_internal_has_thumbnailwidth() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool DocumentMessage::has_thumbnailwidth() const {
  return _internal_has_thumbnailwidth();
}
inline void DocumentMessage::clear_thumbnailwidth() {
  _impl_.thumbnailwidth_ = 0u;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline uint32_t DocumentMessage::_internal_thumbnailwidth() const {
  return _impl_.thumbnailwidth_;
}
inline uint32_t DocumentMessage::thumbnailwidth() const {
  // @@protoc_insertion_point(field_get:proto.DocumentMessage.thumbnailWidth)
  return _internal_thumbnailwidth();
}
inline void DocumentMessage::_internal_set_thumbnailwidth(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.thumbnailwidth_ = value;
}
inline void DocumentMessage::set_thumbnailwidth(uint32_t value) {
  _internal_set_thumbnailwidth(value);
  // @@protoc_insertion_point(field_set:proto.DocumentMessage.thumbnailWidth)
}

// -------------------------------------------------------------------

// AudioMessage

// optional string url = 1;
inline bool AudioMessage::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioMessage::has_url() const {
  return _internal_has_url();
}
inline void AudioMessage::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AudioMessage::url() const {
  // @@protoc_insertion_point(field_get:proto.AudioMessage.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioMessage::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.AudioMessage.url)
}
inline std::string* AudioMessage::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:proto.AudioMessage.url)
  return _s;
}
inline const std::string& AudioMessage::_internal_url() const {
  return _impl_.url_.Get();
}
inline void AudioMessage::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioMessage::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioMessage::release_url() {
  // @@protoc_insertion_point(field_release:proto.AudioMessage.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AudioMessage::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.AudioMessage.url)
}

// optional string mimetype = 2;
inline bool AudioMessage::_internal_has_mimetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AudioMessage::has_mimetype() const {
  return _internal_has_mimetype();
}
inline void AudioMessage::clear_mimetype() {
  _impl_.mimetype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AudioMessage::mimetype() const {
  // @@protoc_insertion_point(field_get:proto.AudioMessage.mimetype)
  return _internal_mimetype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioMessage::set_mimetype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.mimetype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.AudioMessage.mimetype)
}
inline std::string* AudioMessage::mutable_mimetype() {
  std::string* _s = _internal_mutable_mimetype();
  // @@protoc_insertion_point(field_mutable:proto.AudioMessage.mimetype)
  return _s;
}
inline const std::string& AudioMessage::_internal_mimetype() const {
  return _impl_.mimetype_.Get();
}
inline void AudioMessage::_internal_set_mimetype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mimetype_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioMessage::_internal_mutable_mimetype() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mimetype_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioMessage::release_mimetype() {
  // @@protoc_insertion_point(field_release:proto.AudioMessage.mimetype)
  if (!_internal_has_mimetype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.mimetype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mimetype_.IsDefault()) {
    _impl_.mimetype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AudioMessage::set_allocated_mimetype(std::string* mimetype) {
  if (mimetype != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mimetype_.SetAllocated(mimetype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mimetype_.IsDefault()) {
    _impl_.mimetype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.AudioMessage.mimetype)
}

// optional bytes fileSha256 = 3;
inline bool AudioMessage::_internal_has_filesha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AudioMessage::has_filesha256() const {
  return _internal_has_filesha256();
}
inline void AudioMessage::clear_filesha256() {
  _impl_.filesha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AudioMessage::filesha256() const {
  // @@protoc_insertion_point(field_get:proto.AudioMessage.fileSha256)
  return _internal_filesha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioMessage::set_filesha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.filesha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.AudioMessage.fileSha256)
}
inline std::string* AudioMessage::mutable_filesha256() {
  std::string* _s = _internal_mutable_filesha256();
  // @@protoc_insertion_point(field_mutable:proto.AudioMessage.fileSha256)
  return _s;
}
inline const std::string& AudioMessage::_internal_filesha256() const {
  return _impl_.filesha256_.Get();
}
inline void AudioMessage::_internal_set_filesha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.filesha256_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioMessage::_internal_mutable_filesha256() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.filesha256_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioMessage::release_filesha256() {
  // @@protoc_insertion_point(field_release:proto.AudioMessage.fileSha256)
  if (!_internal_has_filesha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.filesha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filesha256_.IsDefault()) {
    _impl_.filesha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AudioMessage::set_allocated_filesha256(std::string* filesha256) {
  if (filesha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.filesha256_.SetAllocated(filesha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filesha256_.IsDefault()) {
    _impl_.filesha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.AudioMessage.fileSha256)
}

// optional uint64 fileLength = 4;
inline bool AudioMessage::_internal_has_filelength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool AudioMessage::has_filelength() const {
  return _internal_has_filelength();
}
inline void AudioMessage::clear_filelength() {
  _impl_.filelength_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint64_t AudioMessage::_internal_filelength() const {
  return _impl_.filelength_;
}
inline uint64_t AudioMessage::filelength() const {
  // @@protoc_insertion_point(field_get:proto.AudioMessage.fileLength)
  return _internal_filelength();
}
inline void AudioMessage::_internal_set_filelength(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.filelength_ = value;
}
inline void AudioMessage::set_filelength(uint64_t value) {
  _internal_set_filelength(value);
  // @@protoc_insertion_point(field_set:proto.AudioMessage.fileLength)
}

// optional uint32 seconds = 5;
inline bool AudioMessage::_internal_has_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool AudioMessage::has_seconds() const {
  return _internal_has_seconds();
}
inline void AudioMessage::clear_seconds() {
  _impl_.seconds_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t AudioMessage::_internal_seconds() const {
  return _impl_.seconds_;
}
inline uint32_t AudioMessage::seconds() const {
  // @@protoc_insertion_point(field_get:proto.AudioMessage.seconds)
  return _internal_seconds();
}
inline void AudioMessage::_internal_set_seconds(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.seconds_ = value;
}
inline void AudioMessage::set_seconds(uint32_t value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:proto.AudioMessage.seconds)
}

// optional bool ptt = 6;
inline bool AudioMessage::_internal_has_ptt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool AudioMessage::has_ptt() const {
  return _internal_has_ptt();
}
inline void AudioMessage::clear_ptt() {
  _impl_.ptt_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool AudioMessage::_internal_ptt() const {
  return _impl_.ptt_;
}
inline bool AudioMessage::ptt() const {
  // @@protoc_insertion_point(field_get:proto.AudioMessage.ptt)
  return _internal_ptt();
}
inline void AudioMessage::_internal_set_ptt(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.ptt_ = value;
}
inline void AudioMessage::set_ptt(bool value) {
  _internal_set_ptt(value);
  // @@protoc_insertion_point(field_set:proto.AudioMessage.ptt)
}

// optional bytes mediaKey = 7;
inline bool AudioMessage::_internal_has_mediakey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AudioMessage::has_mediakey() const {
  return _internal_has_mediakey();
}
inline void AudioMessage::clear_mediakey() {
  _impl_.mediakey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AudioMessage::mediakey() const {
  // @@protoc_insertion_point(field_get:proto.AudioMessage.mediaKey)
  return _internal_mediakey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioMessage::set_mediakey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.mediakey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.AudioMessage.mediaKey)
}
inline std::string* AudioMessage::mutable_mediakey() {
  std::string* _s = _internal_mutable_mediakey();
  // @@protoc_insertion_point(field_mutable:proto.AudioMessage.mediaKey)
  return _s;
}
inline const std::string& AudioMessage::_internal_mediakey() const {
  return _impl_.mediakey_.Get();
}
inline void AudioMessage::_internal_set_mediakey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mediakey_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioMessage::_internal_mutable_mediakey() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.mediakey_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioMessage::release_mediakey() {
  // @@protoc_insertion_point(field_release:proto.AudioMessage.mediaKey)
  if (!_internal_has_mediakey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.mediakey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mediakey_.IsDefault()) {
    _impl_.mediakey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AudioMessage::set_allocated_mediakey(std::string* mediakey) {
  if (mediakey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.mediakey_.SetAllocated(mediakey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mediakey_.IsDefault()) {
    _impl_.mediakey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.AudioMessage.mediaKey)
}

// optional bytes fileEncSha256 = 8;
inline bool AudioMessage::_internal_has_fileencsha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AudioMessage::has_fileencsha256() const {
  return _internal_has_fileencsha256();
}
inline void AudioMessage::clear_fileencsha256() {
  _impl_.fileencsha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& AudioMessage::fileencsha256() const {
  // @@protoc_insertion_point(field_get:proto.AudioMessage.fileEncSha256)
  return _internal_fileencsha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioMessage::set_fileencsha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.fileencsha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.AudioMessage.fileEncSha256)
}
inline std::string* AudioMessage::mutable_fileencsha256() {
  std::string* _s = _internal_mutable_fileencsha256();
  // @@protoc_insertion_point(field_mutable:proto.AudioMessage.fileEncSha256)
  return _s;
}
inline const std::string& AudioMessage::_internal_fileencsha256() const {
  return _impl_.fileencsha256_.Get();
}
inline void AudioMessage::_internal_set_fileencsha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.fileencsha256_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioMessage::_internal_mutable_fileencsha256() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.fileencsha256_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioMessage::release_fileencsha256() {
  // @@protoc_insertion_point(field_release:proto.AudioMessage.fileEncSha256)
  if (!_internal_has_fileencsha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.fileencsha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fileencsha256_.IsDefault()) {
    _impl_.fileencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AudioMessage::set_allocated_fileencsha256(std::string* fileencsha256) {
  if (fileencsha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.fileencsha256_.SetAllocated(fileencsha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fileencsha256_.IsDefault()) {
    _impl_.fileencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.AudioMessage.fileEncSha256)
}

// optional string directPath = 9;
inline bool AudioMessage::_internal_has_directpath() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AudioMessage::has_directpath() const {
  return _internal_has_directpath();
}
inline void AudioMessage::clear_directpath() {
  _impl_.directpath_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& AudioMessage::directpath() const {
  // @@protoc_insertion_point(field_get:proto.AudioMessage.directPath)
  return _internal_directpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioMessage::set_directpath(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.directpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.AudioMessage.directPath)
}
inline std::string* AudioMessage::mutable_directpath() {
  std::string* _s = _internal_mutable_directpath();
  // @@protoc_insertion_point(field_mutable:proto.AudioMessage.directPath)
  return _s;
}
inline const std::string& AudioMessage::_internal_directpath() const {
  return _impl_.directpath_.Get();
}
inline void AudioMessage::_internal_set_directpath(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.directpath_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioMessage::_internal_mutable_directpath() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.directpath_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioMessage::release_directpath() {
  // @@protoc_insertion_point(field_release:proto.AudioMessage.directPath)
  if (!_internal_has_directpath()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.directpath_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.directpath_.IsDefault()) {
    _impl_.directpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AudioMessage::set_allocated_directpath(std::string* directpath) {
  if (directpath != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.directpath_.SetAllocated(directpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.directpath_.IsDefault()) {
    _impl_.directpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.AudioMessage.directPath)
}

// optional int64 mediaKeyTimestamp = 10;
inline bool AudioMessage::_internal_has_mediakeytimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool AudioMessage::has_mediakeytimestamp() const {
  return _internal_has_mediakeytimestamp();
}
inline void AudioMessage::clear_mediakeytimestamp() {
  _impl_.mediakeytimestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int64_t AudioMessage::_internal_mediakeytimestamp() const {
  return _impl_.mediakeytimestamp_;
}
inline int64_t AudioMessage::mediakeytimestamp() const {
  // @@protoc_insertion_point(field_get:proto.AudioMessage.mediaKeyTimestamp)
  return _internal_mediakeytimestamp();
}
inline void AudioMessage::_internal_set_mediakeytimestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.mediakeytimestamp_ = value;
}
inline void AudioMessage::set_mediakeytimestamp(int64_t value) {
  _internal_set_mediakeytimestamp(value);
  // @@protoc_insertion_point(field_set:proto.AudioMessage.mediaKeyTimestamp)
}

// optional .proto.ContextInfo contextInfo = 17;
inline bool AudioMessage::_internal_has_contextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contextinfo_ != nullptr);
  return value;
}
inline bool AudioMessage::has_contextinfo() const {
  return _internal_has_contextinfo();
}
inline void AudioMessage::clear_contextinfo() {
  if (_impl_.contextinfo_ != nullptr) _impl_.contextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::proto::ContextInfo& AudioMessage::_internal_contextinfo() const {
  const ::proto::ContextInfo* p = _impl_.contextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContextInfo&>(
      ::proto::_ContextInfo_default_instance_);
}
inline const ::proto::ContextInfo& AudioMessage::contextinfo() const {
  // @@protoc_insertion_point(field_get:proto.AudioMessage.contextInfo)
  return _internal_contextinfo();
}
inline void AudioMessage::unsafe_arena_set_allocated_contextinfo(
    ::proto::ContextInfo* contextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextinfo_);
  }
  _impl_.contextinfo_ = contextinfo;
  if (contextinfo) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.AudioMessage.contextInfo)
}
inline ::proto::ContextInfo* AudioMessage::release_contextinfo() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContextInfo* AudioMessage::unsafe_arena_release_contextinfo() {
  // @@protoc_insertion_point(field_release:proto.AudioMessage.contextInfo)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
  return temp;
}
inline ::proto::ContextInfo* AudioMessage::_internal_mutable_contextinfo() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.contextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContextInfo>(GetArenaForAllocation());
    _impl_.contextinfo_ = p;
  }
  return _impl_.contextinfo_;
}
inline ::proto::ContextInfo* AudioMessage::mutable_contextinfo() {
  ::proto::ContextInfo* _msg = _internal_mutable_contextinfo();
  // @@protoc_insertion_point(field_mutable:proto.AudioMessage.contextInfo)
  return _msg;
}
inline void AudioMessage::set_allocated_contextinfo(::proto::ContextInfo* contextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contextinfo_;
  }
  if (contextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contextinfo);
    if (message_arena != submessage_arena) {
      contextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.contextinfo_ = contextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.AudioMessage.contextInfo)
}

// optional bytes streamingSidecar = 18;
inline bool AudioMessage::_internal_has_streamingsidecar() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool AudioMessage::has_streamingsidecar() const {
  return _internal_has_streamingsidecar();
}
inline void AudioMessage::clear_streamingsidecar() {
  _impl_.streamingsidecar_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& AudioMessage::streamingsidecar() const {
  // @@protoc_insertion_point(field_get:proto.AudioMessage.streamingSidecar)
  return _internal_streamingsidecar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioMessage::set_streamingsidecar(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.streamingsidecar_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.AudioMessage.streamingSidecar)
}
inline std::string* AudioMessage::mutable_streamingsidecar() {
  std::string* _s = _internal_mutable_streamingsidecar();
  // @@protoc_insertion_point(field_mutable:proto.AudioMessage.streamingSidecar)
  return _s;
}
inline const std::string& AudioMessage::_internal_streamingsidecar() const {
  return _impl_.streamingsidecar_.Get();
}
inline void AudioMessage::_internal_set_streamingsidecar(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.streamingsidecar_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioMessage::_internal_mutable_streamingsidecar() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.streamingsidecar_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioMessage::release_streamingsidecar() {
  // @@protoc_insertion_point(field_release:proto.AudioMessage.streamingSidecar)
  if (!_internal_has_streamingsidecar()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.streamingsidecar_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.streamingsidecar_.IsDefault()) {
    _impl_.streamingsidecar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AudioMessage::set_allocated_streamingsidecar(std::string* streamingsidecar) {
  if (streamingsidecar != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.streamingsidecar_.SetAllocated(streamingsidecar, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.streamingsidecar_.IsDefault()) {
    _impl_.streamingsidecar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.AudioMessage.streamingSidecar)
}

// -------------------------------------------------------------------

// VideoMessage

// optional string url = 1;
inline bool VideoMessage::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoMessage::has_url() const {
  return _internal_has_url();
}
inline void VideoMessage::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VideoMessage::url() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoMessage::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.VideoMessage.url)
}
inline std::string* VideoMessage::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:proto.VideoMessage.url)
  return _s;
}
inline const std::string& VideoMessage::_internal_url() const {
  return _impl_.url_.Get();
}
inline void VideoMessage::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoMessage::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoMessage::release_url() {
  // @@protoc_insertion_point(field_release:proto.VideoMessage.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoMessage::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.VideoMessage.url)
}

// optional string mimetype = 2;
inline bool VideoMessage::_internal_has_mimetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VideoMessage::has_mimetype() const {
  return _internal_has_mimetype();
}
inline void VideoMessage::clear_mimetype() {
  _impl_.mimetype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VideoMessage::mimetype() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.mimetype)
  return _internal_mimetype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoMessage::set_mimetype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.mimetype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.VideoMessage.mimetype)
}
inline std::string* VideoMessage::mutable_mimetype() {
  std::string* _s = _internal_mutable_mimetype();
  // @@protoc_insertion_point(field_mutable:proto.VideoMessage.mimetype)
  return _s;
}
inline const std::string& VideoMessage::_internal_mimetype() const {
  return _impl_.mimetype_.Get();
}
inline void VideoMessage::_internal_set_mimetype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mimetype_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoMessage::_internal_mutable_mimetype() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mimetype_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoMessage::release_mimetype() {
  // @@protoc_insertion_point(field_release:proto.VideoMessage.mimetype)
  if (!_internal_has_mimetype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.mimetype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mimetype_.IsDefault()) {
    _impl_.mimetype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoMessage::set_allocated_mimetype(std::string* mimetype) {
  if (mimetype != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mimetype_.SetAllocated(mimetype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mimetype_.IsDefault()) {
    _impl_.mimetype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.VideoMessage.mimetype)
}

// optional bytes fileSha256 = 3;
inline bool VideoMessage::_internal_has_filesha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VideoMessage::has_filesha256() const {
  return _internal_has_filesha256();
}
inline void VideoMessage::clear_filesha256() {
  _impl_.filesha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& VideoMessage::filesha256() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.fileSha256)
  return _internal_filesha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoMessage::set_filesha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.filesha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.VideoMessage.fileSha256)
}
inline std::string* VideoMessage::mutable_filesha256() {
  std::string* _s = _internal_mutable_filesha256();
  // @@protoc_insertion_point(field_mutable:proto.VideoMessage.fileSha256)
  return _s;
}
inline const std::string& VideoMessage::_internal_filesha256() const {
  return _impl_.filesha256_.Get();
}
inline void VideoMessage::_internal_set_filesha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.filesha256_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoMessage::_internal_mutable_filesha256() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.filesha256_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoMessage::release_filesha256() {
  // @@protoc_insertion_point(field_release:proto.VideoMessage.fileSha256)
  if (!_internal_has_filesha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.filesha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filesha256_.IsDefault()) {
    _impl_.filesha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoMessage::set_allocated_filesha256(std::string* filesha256) {
  if (filesha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.filesha256_.SetAllocated(filesha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filesha256_.IsDefault()) {
    _impl_.filesha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.VideoMessage.fileSha256)
}

// optional uint64 fileLength = 4;
inline bool VideoMessage::_internal_has_filelength() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool VideoMessage::has_filelength() const {
  return _internal_has_filelength();
}
inline void VideoMessage::clear_filelength() {
  _impl_.filelength_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint64_t VideoMessage::_internal_filelength() const {
  return _impl_.filelength_;
}
inline uint64_t VideoMessage::filelength() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.fileLength)
  return _internal_filelength();
}
inline void VideoMessage::_internal_set_filelength(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.filelength_ = value;
}
inline void VideoMessage::set_filelength(uint64_t value) {
  _internal_set_filelength(value);
  // @@protoc_insertion_point(field_set:proto.VideoMessage.fileLength)
}

// optional uint32 seconds = 5;
inline bool VideoMessage::_internal_has_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool VideoMessage::has_seconds() const {
  return _internal_has_seconds();
}
inline void VideoMessage::clear_seconds() {
  _impl_.seconds_ = 0u;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline uint32_t VideoMessage::_internal_seconds() const {
  return _impl_.seconds_;
}
inline uint32_t VideoMessage::seconds() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.seconds)
  return _internal_seconds();
}
inline void VideoMessage::_internal_set_seconds(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.seconds_ = value;
}
inline void VideoMessage::set_seconds(uint32_t value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:proto.VideoMessage.seconds)
}

// optional bytes mediaKey = 6;
inline bool VideoMessage::_internal_has_mediakey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VideoMessage::has_mediakey() const {
  return _internal_has_mediakey();
}
inline void VideoMessage::clear_mediakey() {
  _impl_.mediakey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& VideoMessage::mediakey() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.mediaKey)
  return _internal_mediakey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoMessage::set_mediakey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.mediakey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.VideoMessage.mediaKey)
}
inline std::string* VideoMessage::mutable_mediakey() {
  std::string* _s = _internal_mutable_mediakey();
  // @@protoc_insertion_point(field_mutable:proto.VideoMessage.mediaKey)
  return _s;
}
inline const std::string& VideoMessage::_internal_mediakey() const {
  return _impl_.mediakey_.Get();
}
inline void VideoMessage::_internal_set_mediakey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mediakey_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoMessage::_internal_mutable_mediakey() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.mediakey_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoMessage::release_mediakey() {
  // @@protoc_insertion_point(field_release:proto.VideoMessage.mediaKey)
  if (!_internal_has_mediakey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.mediakey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mediakey_.IsDefault()) {
    _impl_.mediakey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoMessage::set_allocated_mediakey(std::string* mediakey) {
  if (mediakey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.mediakey_.SetAllocated(mediakey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mediakey_.IsDefault()) {
    _impl_.mediakey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.VideoMessage.mediaKey)
}

// optional string caption = 7;
inline bool VideoMessage::_internal_has_caption() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool VideoMessage::has_caption() const {
  return _internal_has_caption();
}
inline void VideoMessage::clear_caption() {
  _impl_.caption_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& VideoMessage::caption() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.caption)
  return _internal_caption();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoMessage::set_caption(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.caption_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.VideoMessage.caption)
}
inline std::string* VideoMessage::mutable_caption() {
  std::string* _s = _internal_mutable_caption();
  // @@protoc_insertion_point(field_mutable:proto.VideoMessage.caption)
  return _s;
}
inline const std::string& VideoMessage::_internal_caption() const {
  return _impl_.caption_.Get();
}
inline void VideoMessage::_internal_set_caption(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.caption_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoMessage::_internal_mutable_caption() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.caption_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoMessage::release_caption() {
  // @@protoc_insertion_point(field_release:proto.VideoMessage.caption)
  if (!_internal_has_caption()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.caption_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caption_.IsDefault()) {
    _impl_.caption_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoMessage::set_allocated_caption(std::string* caption) {
  if (caption != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.caption_.SetAllocated(caption, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caption_.IsDefault()) {
    _impl_.caption_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.VideoMessage.caption)
}

// optional bool gifPlayback = 8;
inline bool VideoMessage::_internal_has_gifplayback() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool VideoMessage::has_gifplayback() const {
  return _internal_has_gifplayback();
}
inline void VideoMessage::clear_gifplayback() {
  _impl_.gifplayback_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool VideoMessage::_internal_gifplayback() const {
  return _impl_.gifplayback_;
}
inline bool VideoMessage::gifplayback() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.gifPlayback)
  return _internal_gifplayback();
}
inline void VideoMessage::_internal_set_gifplayback(bool value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.gifplayback_ = value;
}
inline void VideoMessage::set_gifplayback(bool value) {
  _internal_set_gifplayback(value);
  // @@protoc_insertion_point(field_set:proto.VideoMessage.gifPlayback)
}

// optional uint32 height = 9;
inline bool VideoMessage::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool VideoMessage::has_height() const {
  return _internal_has_height();
}
inline void VideoMessage::clear_height() {
  _impl_.height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline uint32_t VideoMessage::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t VideoMessage::height() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.height)
  return _internal_height();
}
inline void VideoMessage::_internal_set_height(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.height_ = value;
}
inline void VideoMessage::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:proto.VideoMessage.height)
}

// optional uint32 width = 10;
inline bool VideoMessage::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool VideoMessage::has_width() const {
  return _internal_has_width();
}
inline void VideoMessage::clear_width() {
  _impl_.width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline uint32_t VideoMessage::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t VideoMessage::width() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.width)
  return _internal_width();
}
inline void VideoMessage::_internal_set_width(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.width_ = value;
}
inline void VideoMessage::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:proto.VideoMessage.width)
}

// optional bytes fileEncSha256 = 11;
inline bool VideoMessage::_internal_has_fileencsha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool VideoMessage::has_fileencsha256() const {
  return _internal_has_fileencsha256();
}
inline void VideoMessage::clear_fileencsha256() {
  _impl_.fileencsha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& VideoMessage::fileencsha256() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.fileEncSha256)
  return _internal_fileencsha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoMessage::set_fileencsha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.fileencsha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.VideoMessage.fileEncSha256)
}
inline std::string* VideoMessage::mutable_fileencsha256() {
  std::string* _s = _internal_mutable_fileencsha256();
  // @@protoc_insertion_point(field_mutable:proto.VideoMessage.fileEncSha256)
  return _s;
}
inline const std::string& VideoMessage::_internal_fileencsha256() const {
  return _impl_.fileencsha256_.Get();
}
inline void VideoMessage::_internal_set_fileencsha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.fileencsha256_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoMessage::_internal_mutable_fileencsha256() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.fileencsha256_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoMessage::release_fileencsha256() {
  // @@protoc_insertion_point(field_release:proto.VideoMessage.fileEncSha256)
  if (!_internal_has_fileencsha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.fileencsha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fileencsha256_.IsDefault()) {
    _impl_.fileencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoMessage::set_allocated_fileencsha256(std::string* fileencsha256) {
  if (fileencsha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.fileencsha256_.SetAllocated(fileencsha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fileencsha256_.IsDefault()) {
    _impl_.fileencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.VideoMessage.fileEncSha256)
}

// repeated .proto.InteractiveAnnotation interactiveAnnotations = 12;
inline int VideoMessage::_internal_interactiveannotations_size() const {
  return _impl_.interactiveannotations_.size();
}
inline int VideoMessage::interactiveannotations_size() const {
  return _internal_interactiveannotations_size();
}
inline void VideoMessage::clear_interactiveannotations() {
  _impl_.interactiveannotations_.Clear();
}
inline ::proto::InteractiveAnnotation* VideoMessage::mutable_interactiveannotations(int index) {
  // @@protoc_insertion_point(field_mutable:proto.VideoMessage.interactiveAnnotations)
  return _impl_.interactiveannotations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::InteractiveAnnotation >*
VideoMessage::mutable_interactiveannotations() {
  // @@protoc_insertion_point(field_mutable_list:proto.VideoMessage.interactiveAnnotations)
  return &_impl_.interactiveannotations_;
}
inline const ::proto::InteractiveAnnotation& VideoMessage::_internal_interactiveannotations(int index) const {
  return _impl_.interactiveannotations_.Get(index);
}
inline const ::proto::InteractiveAnnotation& VideoMessage::interactiveannotations(int index) const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.interactiveAnnotations)
  return _internal_interactiveannotations(index);
}
inline ::proto::InteractiveAnnotation* VideoMessage::_internal_add_interactiveannotations() {
  return _impl_.interactiveannotations_.Add();
}
inline ::proto::InteractiveAnnotation* VideoMessage::add_interactiveannotations() {
  ::proto::InteractiveAnnotation* _add = _internal_add_interactiveannotations();
  // @@protoc_insertion_point(field_add:proto.VideoMessage.interactiveAnnotations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::InteractiveAnnotation >&
VideoMessage::interactiveannotations() const {
  // @@protoc_insertion_point(field_list:proto.VideoMessage.interactiveAnnotations)
  return _impl_.interactiveannotations_;
}

// optional string directPath = 13;
inline bool VideoMessage::_internal_has_directpath() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool VideoMessage::has_directpath() const {
  return _internal_has_directpath();
}
inline void VideoMessage::clear_directpath() {
  _impl_.directpath_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& VideoMessage::directpath() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.directPath)
  return _internal_directpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoMessage::set_directpath(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.directpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.VideoMessage.directPath)
}
inline std::string* VideoMessage::mutable_directpath() {
  std::string* _s = _internal_mutable_directpath();
  // @@protoc_insertion_point(field_mutable:proto.VideoMessage.directPath)
  return _s;
}
inline const std::string& VideoMessage::_internal_directpath() const {
  return _impl_.directpath_.Get();
}
inline void VideoMessage::_internal_set_directpath(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.directpath_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoMessage::_internal_mutable_directpath() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.directpath_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoMessage::release_directpath() {
  // @@protoc_insertion_point(field_release:proto.VideoMessage.directPath)
  if (!_internal_has_directpath()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.directpath_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.directpath_.IsDefault()) {
    _impl_.directpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoMessage::set_allocated_directpath(std::string* directpath) {
  if (directpath != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.directpath_.SetAllocated(directpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.directpath_.IsDefault()) {
    _impl_.directpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.VideoMessage.directPath)
}

// optional int64 mediaKeyTimestamp = 14;
inline bool VideoMessage::_internal_has_mediakeytimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool VideoMessage::has_mediakeytimestamp() const {
  return _internal_has_mediakeytimestamp();
}
inline void VideoMessage::clear_mediakeytimestamp() {
  _impl_.mediakeytimestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline int64_t VideoMessage::_internal_mediakeytimestamp() const {
  return _impl_.mediakeytimestamp_;
}
inline int64_t VideoMessage::mediakeytimestamp() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.mediaKeyTimestamp)
  return _internal_mediakeytimestamp();
}
inline void VideoMessage::_internal_set_mediakeytimestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.mediakeytimestamp_ = value;
}
inline void VideoMessage::set_mediakeytimestamp(int64_t value) {
  _internal_set_mediakeytimestamp(value);
  // @@protoc_insertion_point(field_set:proto.VideoMessage.mediaKeyTimestamp)
}

// optional bytes jpegThumbnail = 16;
inline bool VideoMessage::_internal_has_jpegthumbnail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool VideoMessage::has_jpegthumbnail() const {
  return _internal_has_jpegthumbnail();
}
inline void VideoMessage::clear_jpegthumbnail() {
  _impl_.jpegthumbnail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& VideoMessage::jpegthumbnail() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.jpegThumbnail)
  return _internal_jpegthumbnail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoMessage::set_jpegthumbnail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.jpegthumbnail_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.VideoMessage.jpegThumbnail)
}
inline std::string* VideoMessage::mutable_jpegthumbnail() {
  std::string* _s = _internal_mutable_jpegthumbnail();
  // @@protoc_insertion_point(field_mutable:proto.VideoMessage.jpegThumbnail)
  return _s;
}
inline const std::string& VideoMessage::_internal_jpegthumbnail() const {
  return _impl_.jpegthumbnail_.Get();
}
inline void VideoMessage::_internal_set_jpegthumbnail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.jpegthumbnail_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoMessage::_internal_mutable_jpegthumbnail() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.jpegthumbnail_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoMessage::release_jpegthumbnail() {
  // @@protoc_insertion_point(field_release:proto.VideoMessage.jpegThumbnail)
  if (!_internal_has_jpegthumbnail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.jpegthumbnail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jpegthumbnail_.IsDefault()) {
    _impl_.jpegthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoMessage::set_allocated_jpegthumbnail(std::string* jpegthumbnail) {
  if (jpegthumbnail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.jpegthumbnail_.SetAllocated(jpegthumbnail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jpegthumbnail_.IsDefault()) {
    _impl_.jpegthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.VideoMessage.jpegThumbnail)
}

// optional .proto.ContextInfo contextInfo = 17;
inline bool VideoMessage::_internal_has_contextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contextinfo_ != nullptr);
  return value;
}
inline bool VideoMessage::has_contextinfo() const {
  return _internal_has_contextinfo();
}
inline void VideoMessage::clear_contextinfo() {
  if (_impl_.contextinfo_ != nullptr) _impl_.contextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::proto::ContextInfo& VideoMessage::_internal_contextinfo() const {
  const ::proto::ContextInfo* p = _impl_.contextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContextInfo&>(
      ::proto::_ContextInfo_default_instance_);
}
inline const ::proto::ContextInfo& VideoMessage::contextinfo() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.contextInfo)
  return _internal_contextinfo();
}
inline void VideoMessage::unsafe_arena_set_allocated_contextinfo(
    ::proto::ContextInfo* contextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextinfo_);
  }
  _impl_.contextinfo_ = contextinfo;
  if (contextinfo) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.VideoMessage.contextInfo)
}
inline ::proto::ContextInfo* VideoMessage::release_contextinfo() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContextInfo* VideoMessage::unsafe_arena_release_contextinfo() {
  // @@protoc_insertion_point(field_release:proto.VideoMessage.contextInfo)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
  return temp;
}
inline ::proto::ContextInfo* VideoMessage::_internal_mutable_contextinfo() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.contextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContextInfo>(GetArenaForAllocation());
    _impl_.contextinfo_ = p;
  }
  return _impl_.contextinfo_;
}
inline ::proto::ContextInfo* VideoMessage::mutable_contextinfo() {
  ::proto::ContextInfo* _msg = _internal_mutable_contextinfo();
  // @@protoc_insertion_point(field_mutable:proto.VideoMessage.contextInfo)
  return _msg;
}
inline void VideoMessage::set_allocated_contextinfo(::proto::ContextInfo* contextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contextinfo_;
  }
  if (contextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contextinfo);
    if (message_arena != submessage_arena) {
      contextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.contextinfo_ = contextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.VideoMessage.contextInfo)
}

// optional bytes streamingSidecar = 18;
inline bool VideoMessage::_internal_has_streamingsidecar() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool VideoMessage::has_streamingsidecar() const {
  return _internal_has_streamingsidecar();
}
inline void VideoMessage::clear_streamingsidecar() {
  _impl_.streamingsidecar_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& VideoMessage::streamingsidecar() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.streamingSidecar)
  return _internal_streamingsidecar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoMessage::set_streamingsidecar(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.streamingsidecar_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.VideoMessage.streamingSidecar)
}
inline std::string* VideoMessage::mutable_streamingsidecar() {
  std::string* _s = _internal_mutable_streamingsidecar();
  // @@protoc_insertion_point(field_mutable:proto.VideoMessage.streamingSidecar)
  return _s;
}
inline const std::string& VideoMessage::_internal_streamingsidecar() const {
  return _impl_.streamingsidecar_.Get();
}
inline void VideoMessage::_internal_set_streamingsidecar(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.streamingsidecar_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoMessage::_internal_mutable_streamingsidecar() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.streamingsidecar_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoMessage::release_streamingsidecar() {
  // @@protoc_insertion_point(field_release:proto.VideoMessage.streamingSidecar)
  if (!_internal_has_streamingsidecar()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.streamingsidecar_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.streamingsidecar_.IsDefault()) {
    _impl_.streamingsidecar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoMessage::set_allocated_streamingsidecar(std::string* streamingsidecar) {
  if (streamingsidecar != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.streamingsidecar_.SetAllocated(streamingsidecar, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.streamingsidecar_.IsDefault()) {
    _impl_.streamingsidecar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.VideoMessage.streamingSidecar)
}

// optional .proto.VideoMessage.VideoMessageAttribution gifAttribution = 19;
inline bool VideoMessage::_internal_has_gifattribution() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool VideoMessage::has_gifattribution() const {
  return _internal_has_gifattribution();
}
inline void VideoMessage::clear_gifattribution() {
  _impl_.gifattribution_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline ::proto::VideoMessage_VideoMessageAttribution VideoMessage::_internal_gifattribution() const {
  return static_cast< ::proto::VideoMessage_VideoMessageAttribution >(_impl_.gifattribution_);
}
inline ::proto::VideoMessage_VideoMessageAttribution VideoMessage::gifattribution() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.gifAttribution)
  return _internal_gifattribution();
}
inline void VideoMessage::_internal_set_gifattribution(::proto::VideoMessage_VideoMessageAttribution value) {
  assert(::proto::VideoMessage_VideoMessageAttribution_IsValid(value));
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.gifattribution_ = value;
}
inline void VideoMessage::set_gifattribution(::proto::VideoMessage_VideoMessageAttribution value) {
  _internal_set_gifattribution(value);
  // @@protoc_insertion_point(field_set:proto.VideoMessage.gifAttribution)
}

// optional bool viewOnce = 20;
inline bool VideoMessage::_internal_has_viewonce() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool VideoMessage::has_viewonce() const {
  return _internal_has_viewonce();
}
inline void VideoMessage::clear_viewonce() {
  _impl_.viewonce_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool VideoMessage::_internal_viewonce() const {
  return _impl_.viewonce_;
}
inline bool VideoMessage::viewonce() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.viewOnce)
  return _internal_viewonce();
}
inline void VideoMessage::_internal_set_viewonce(bool value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.viewonce_ = value;
}
inline void VideoMessage::set_viewonce(bool value) {
  _internal_set_viewonce(value);
  // @@protoc_insertion_point(field_set:proto.VideoMessage.viewOnce)
}

// optional string thumbnailDirectPath = 21;
inline bool VideoMessage::_internal_has_thumbnaildirectpath() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool VideoMessage::has_thumbnaildirectpath() const {
  return _internal_has_thumbnaildirectpath();
}
inline void VideoMessage::clear_thumbnaildirectpath() {
  _impl_.thumbnaildirectpath_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& VideoMessage::thumbnaildirectpath() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.thumbnailDirectPath)
  return _internal_thumbnaildirectpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoMessage::set_thumbnaildirectpath(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000200u;
 _impl_.thumbnaildirectpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.VideoMessage.thumbnailDirectPath)
}
inline std::string* VideoMessage::mutable_thumbnaildirectpath() {
  std::string* _s = _internal_mutable_thumbnaildirectpath();
  // @@protoc_insertion_point(field_mutable:proto.VideoMessage.thumbnailDirectPath)
  return _s;
}
inline const std::string& VideoMessage::_internal_thumbnaildirectpath() const {
  return _impl_.thumbnaildirectpath_.Get();
}
inline void VideoMessage::_internal_set_thumbnaildirectpath(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.thumbnaildirectpath_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoMessage::_internal_mutable_thumbnaildirectpath() {
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.thumbnaildirectpath_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoMessage::release_thumbnaildirectpath() {
  // @@protoc_insertion_point(field_release:proto.VideoMessage.thumbnailDirectPath)
  if (!_internal_has_thumbnaildirectpath()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* p = _impl_.thumbnaildirectpath_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnaildirectpath_.IsDefault()) {
    _impl_.thumbnaildirectpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoMessage::set_allocated_thumbnaildirectpath(std::string* thumbnaildirectpath) {
  if (thumbnaildirectpath != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.thumbnaildirectpath_.SetAllocated(thumbnaildirectpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnaildirectpath_.IsDefault()) {
    _impl_.thumbnaildirectpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.VideoMessage.thumbnailDirectPath)
}

// optional bytes thumbnailSha256 = 22;
inline bool VideoMessage::_internal_has_thumbnailsha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool VideoMessage::has_thumbnailsha256() const {
  return _internal_has_thumbnailsha256();
}
inline void VideoMessage::clear_thumbnailsha256() {
  _impl_.thumbnailsha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& VideoMessage::thumbnailsha256() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.thumbnailSha256)
  return _internal_thumbnailsha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoMessage::set_thumbnailsha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000400u;
 _impl_.thumbnailsha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.VideoMessage.thumbnailSha256)
}
inline std::string* VideoMessage::mutable_thumbnailsha256() {
  std::string* _s = _internal_mutable_thumbnailsha256();
  // @@protoc_insertion_point(field_mutable:proto.VideoMessage.thumbnailSha256)
  return _s;
}
inline const std::string& VideoMessage::_internal_thumbnailsha256() const {
  return _impl_.thumbnailsha256_.Get();
}
inline void VideoMessage::_internal_set_thumbnailsha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.thumbnailsha256_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoMessage::_internal_mutable_thumbnailsha256() {
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.thumbnailsha256_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoMessage::release_thumbnailsha256() {
  // @@protoc_insertion_point(field_release:proto.VideoMessage.thumbnailSha256)
  if (!_internal_has_thumbnailsha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* p = _impl_.thumbnailsha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailsha256_.IsDefault()) {
    _impl_.thumbnailsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoMessage::set_allocated_thumbnailsha256(std::string* thumbnailsha256) {
  if (thumbnailsha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.thumbnailsha256_.SetAllocated(thumbnailsha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailsha256_.IsDefault()) {
    _impl_.thumbnailsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.VideoMessage.thumbnailSha256)
}

// optional bytes thumbnailEncSha256 = 23;
inline bool VideoMessage::_internal_has_thumbnailencsha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool VideoMessage::has_thumbnailencsha256() const {
  return _internal_has_thumbnailencsha256();
}
inline void VideoMessage::clear_thumbnailencsha256() {
  _impl_.thumbnailencsha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& VideoMessage::thumbnailencsha256() const {
  // @@protoc_insertion_point(field_get:proto.VideoMessage.thumbnailEncSha256)
  return _internal_thumbnailencsha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoMessage::set_thumbnailencsha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000800u;
 _impl_.thumbnailencsha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.VideoMessage.thumbnailEncSha256)
}
inline std::string* VideoMessage::mutable_thumbnailencsha256() {
  std::string* _s = _internal_mutable_thumbnailencsha256();
  // @@protoc_insertion_point(field_mutable:proto.VideoMessage.thumbnailEncSha256)
  return _s;
}
inline const std::string& VideoMessage::_internal_thumbnailencsha256() const {
  return _impl_.thumbnailencsha256_.Get();
}
inline void VideoMessage::_internal_set_thumbnailencsha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.thumbnailencsha256_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoMessage::_internal_mutable_thumbnailencsha256() {
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.thumbnailencsha256_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoMessage::release_thumbnailencsha256() {
  // @@protoc_insertion_point(field_release:proto.VideoMessage.thumbnailEncSha256)
  if (!_internal_has_thumbnailencsha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* p = _impl_.thumbnailencsha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailencsha256_.IsDefault()) {
    _impl_.thumbnailencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoMessage::set_allocated_thumbnailencsha256(std::string* thumbnailencsha256) {
  if (thumbnailencsha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.thumbnailencsha256_.SetAllocated(thumbnailencsha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailencsha256_.IsDefault()) {
    _impl_.thumbnailencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.VideoMessage.thumbnailEncSha256)
}

// -------------------------------------------------------------------

// Call

// optional bytes callKey = 1;
inline bool Call::_internal_has_callkey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Call::has_callkey() const {
  return _internal_has_callkey();
}
inline void Call::clear_callkey() {
  _impl_.callkey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Call::callkey() const {
  // @@protoc_insertion_point(field_get:proto.Call.callKey)
  return _internal_callkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Call::set_callkey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.callkey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Call.callKey)
}
inline std::string* Call::mutable_callkey() {
  std::string* _s = _internal_mutable_callkey();
  // @@protoc_insertion_point(field_mutable:proto.Call.callKey)
  return _s;
}
inline const std::string& Call::_internal_callkey() const {
  return _impl_.callkey_.Get();
}
inline void Call::_internal_set_callkey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.callkey_.Set(value, GetArenaForAllocation());
}
inline std::string* Call::_internal_mutable_callkey() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.callkey_.Mutable(GetArenaForAllocation());
}
inline std::string* Call::release_callkey() {
  // @@protoc_insertion_point(field_release:proto.Call.callKey)
  if (!_internal_has_callkey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.callkey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.callkey_.IsDefault()) {
    _impl_.callkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Call::set_allocated_callkey(std::string* callkey) {
  if (callkey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.callkey_.SetAllocated(callkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.callkey_.IsDefault()) {
    _impl_.callkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Call.callKey)
}

// -------------------------------------------------------------------

// Chat

// optional string displayName = 1;
inline bool Chat::_internal_has_displayname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Chat::has_displayname() const {
  return _internal_has_displayname();
}
inline void Chat::clear_displayname() {
  _impl_.displayname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Chat::displayname() const {
  // @@protoc_insertion_point(field_get:proto.Chat.displayName)
  return _internal_displayname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chat::set_displayname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.displayname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Chat.displayName)
}
inline std::string* Chat::mutable_displayname() {
  std::string* _s = _internal_mutable_displayname();
  // @@protoc_insertion_point(field_mutable:proto.Chat.displayName)
  return _s;
}
inline const std::string& Chat::_internal_displayname() const {
  return _impl_.displayname_.Get();
}
inline void Chat::_internal_set_displayname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.displayname_.Set(value, GetArenaForAllocation());
}
inline std::string* Chat::_internal_mutable_displayname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.displayname_.Mutable(GetArenaForAllocation());
}
inline std::string* Chat::release_displayname() {
  // @@protoc_insertion_point(field_release:proto.Chat.displayName)
  if (!_internal_has_displayname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.displayname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displayname_.IsDefault()) {
    _impl_.displayname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Chat::set_allocated_displayname(std::string* displayname) {
  if (displayname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.displayname_.SetAllocated(displayname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displayname_.IsDefault()) {
    _impl_.displayname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Chat.displayName)
}

// optional string id = 2;
inline bool Chat::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Chat::has_id() const {
  return _internal_has_id();
}
inline void Chat::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Chat::id() const {
  // @@protoc_insertion_point(field_get:proto.Chat.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chat::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Chat.id)
}
inline std::string* Chat::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:proto.Chat.id)
  return _s;
}
inline const std::string& Chat::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Chat::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Chat::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Chat::release_id() {
  // @@protoc_insertion_point(field_release:proto.Chat.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Chat::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Chat.id)
}

// -------------------------------------------------------------------

// ProtocolMessage

// optional .proto.MessageKey key = 1;
inline bool ProtocolMessage::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline bool ProtocolMessage::has_key() const {
  return _internal_has_key();
}
inline void ProtocolMessage::clear_key() {
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::MessageKey& ProtocolMessage::_internal_key() const {
  const ::proto::MessageKey* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::MessageKey&>(
      ::proto::_MessageKey_default_instance_);
}
inline const ::proto::MessageKey& ProtocolMessage::key() const {
  // @@protoc_insertion_point(field_get:proto.ProtocolMessage.key)
  return _internal_key();
}
inline void ProtocolMessage::unsafe_arena_set_allocated_key(
    ::proto::MessageKey* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ProtocolMessage.key)
}
inline ::proto::MessageKey* ProtocolMessage::release_key() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::MessageKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::MessageKey* ProtocolMessage::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:proto.ProtocolMessage.key)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::MessageKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::proto::MessageKey* ProtocolMessage::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::MessageKey>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::proto::MessageKey* ProtocolMessage::mutable_key() {
  ::proto::MessageKey* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:proto.ProtocolMessage.key)
  return _msg;
}
inline void ProtocolMessage::set_allocated_key(::proto::MessageKey* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:proto.ProtocolMessage.key)
}

// optional .proto.ProtocolMessage.ProtocolMessageType type = 2;
inline bool ProtocolMessage::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ProtocolMessage::has_type() const {
  return _internal_has_type();
}
inline void ProtocolMessage::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::proto::ProtocolMessage_ProtocolMessageType ProtocolMessage::_internal_type() const {
  return static_cast< ::proto::ProtocolMessage_ProtocolMessageType >(_impl_.type_);
}
inline ::proto::ProtocolMessage_ProtocolMessageType ProtocolMessage::type() const {
  // @@protoc_insertion_point(field_get:proto.ProtocolMessage.type)
  return _internal_type();
}
inline void ProtocolMessage::_internal_set_type(::proto::ProtocolMessage_ProtocolMessageType value) {
  assert(::proto::ProtocolMessage_ProtocolMessageType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.type_ = value;
}
inline void ProtocolMessage::set_type(::proto::ProtocolMessage_ProtocolMessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.ProtocolMessage.type)
}

// optional uint32 ephemeralExpiration = 4;
inline bool ProtocolMessage::_internal_has_ephemeralexpiration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ProtocolMessage::has_ephemeralexpiration() const {
  return _internal_has_ephemeralexpiration();
}
inline void ProtocolMessage::clear_ephemeralexpiration() {
  _impl_.ephemeralexpiration_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t ProtocolMessage::_internal_ephemeralexpiration() const {
  return _impl_.ephemeralexpiration_;
}
inline uint32_t ProtocolMessage::ephemeralexpiration() const {
  // @@protoc_insertion_point(field_get:proto.ProtocolMessage.ephemeralExpiration)
  return _internal_ephemeralexpiration();
}
inline void ProtocolMessage::_internal_set_ephemeralexpiration(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.ephemeralexpiration_ = value;
}
inline void ProtocolMessage::set_ephemeralexpiration(uint32_t value) {
  _internal_set_ephemeralexpiration(value);
  // @@protoc_insertion_point(field_set:proto.ProtocolMessage.ephemeralExpiration)
}

// optional int64 ephemeralSettingTimestamp = 5;
inline bool ProtocolMessage::_internal_has_ephemeralsettingtimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ProtocolMessage::has_ephemeralsettingtimestamp() const {
  return _internal_has_ephemeralsettingtimestamp();
}
inline void ProtocolMessage::clear_ephemeralsettingtimestamp() {
  _impl_.ephemeralsettingtimestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t ProtocolMessage::_internal_ephemeralsettingtimestamp() const {
  return _impl_.ephemeralsettingtimestamp_;
}
inline int64_t ProtocolMessage::ephemeralsettingtimestamp() const {
  // @@protoc_insertion_point(field_get:proto.ProtocolMessage.ephemeralSettingTimestamp)
  return _internal_ephemeralsettingtimestamp();
}
inline void ProtocolMessage::_internal_set_ephemeralsettingtimestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.ephemeralsettingtimestamp_ = value;
}
inline void ProtocolMessage::set_ephemeralsettingtimestamp(int64_t value) {
  _internal_set_ephemeralsettingtimestamp(value);
  // @@protoc_insertion_point(field_set:proto.ProtocolMessage.ephemeralSettingTimestamp)
}

// optional .proto.HistorySyncNotification historySyncNotification = 6;
inline bool ProtocolMessage::_internal_has_historysyncnotification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.historysyncnotification_ != nullptr);
  return value;
}
inline bool ProtocolMessage::has_historysyncnotification() const {
  return _internal_has_historysyncnotification();
}
inline void ProtocolMessage::clear_historysyncnotification() {
  if (_impl_.historysyncnotification_ != nullptr) _impl_.historysyncnotification_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::HistorySyncNotification& ProtocolMessage::_internal_historysyncnotification() const {
  const ::proto::HistorySyncNotification* p = _impl_.historysyncnotification_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::HistorySyncNotification&>(
      ::proto::_HistorySyncNotification_default_instance_);
}
inline const ::proto::HistorySyncNotification& ProtocolMessage::historysyncnotification() const {
  // @@protoc_insertion_point(field_get:proto.ProtocolMessage.historySyncNotification)
  return _internal_historysyncnotification();
}
inline void ProtocolMessage::unsafe_arena_set_allocated_historysyncnotification(
    ::proto::HistorySyncNotification* historysyncnotification) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.historysyncnotification_);
  }
  _impl_.historysyncnotification_ = historysyncnotification;
  if (historysyncnotification) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ProtocolMessage.historySyncNotification)
}
inline ::proto::HistorySyncNotification* ProtocolMessage::release_historysyncnotification() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::HistorySyncNotification* temp = _impl_.historysyncnotification_;
  _impl_.historysyncnotification_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::HistorySyncNotification* ProtocolMessage::unsafe_arena_release_historysyncnotification() {
  // @@protoc_insertion_point(field_release:proto.ProtocolMessage.historySyncNotification)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::HistorySyncNotification* temp = _impl_.historysyncnotification_;
  _impl_.historysyncnotification_ = nullptr;
  return temp;
}
inline ::proto::HistorySyncNotification* ProtocolMessage::_internal_mutable_historysyncnotification() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.historysyncnotification_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::HistorySyncNotification>(GetArenaForAllocation());
    _impl_.historysyncnotification_ = p;
  }
  return _impl_.historysyncnotification_;
}
inline ::proto::HistorySyncNotification* ProtocolMessage::mutable_historysyncnotification() {
  ::proto::HistorySyncNotification* _msg = _internal_mutable_historysyncnotification();
  // @@protoc_insertion_point(field_mutable:proto.ProtocolMessage.historySyncNotification)
  return _msg;
}
inline void ProtocolMessage::set_allocated_historysyncnotification(::proto::HistorySyncNotification* historysyncnotification) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.historysyncnotification_;
  }
  if (historysyncnotification) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(historysyncnotification);
    if (message_arena != submessage_arena) {
      historysyncnotification = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, historysyncnotification, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.historysyncnotification_ = historysyncnotification;
  // @@protoc_insertion_point(field_set_allocated:proto.ProtocolMessage.historySyncNotification)
}

// optional .proto.AppStateSyncKeyShare appStateSyncKeyShare = 7;
inline bool ProtocolMessage::_internal_has_appstatesynckeyshare() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.appstatesynckeyshare_ != nullptr);
  return value;
}
inline bool ProtocolMessage::has_appstatesynckeyshare() const {
  return _internal_has_appstatesynckeyshare();
}
inline void ProtocolMessage::clear_appstatesynckeyshare() {
  if (_impl_.appstatesynckeyshare_ != nullptr) _impl_.appstatesynckeyshare_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::proto::AppStateSyncKeyShare& ProtocolMessage::_internal_appstatesynckeyshare() const {
  const ::proto::AppStateSyncKeyShare* p = _impl_.appstatesynckeyshare_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AppStateSyncKeyShare&>(
      ::proto::_AppStateSyncKeyShare_default_instance_);
}
inline const ::proto::AppStateSyncKeyShare& ProtocolMessage::appstatesynckeyshare() const {
  // @@protoc_insertion_point(field_get:proto.ProtocolMessage.appStateSyncKeyShare)
  return _internal_appstatesynckeyshare();
}
inline void ProtocolMessage::unsafe_arena_set_allocated_appstatesynckeyshare(
    ::proto::AppStateSyncKeyShare* appstatesynckeyshare) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.appstatesynckeyshare_);
  }
  _impl_.appstatesynckeyshare_ = appstatesynckeyshare;
  if (appstatesynckeyshare) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ProtocolMessage.appStateSyncKeyShare)
}
inline ::proto::AppStateSyncKeyShare* ProtocolMessage::release_appstatesynckeyshare() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::AppStateSyncKeyShare* temp = _impl_.appstatesynckeyshare_;
  _impl_.appstatesynckeyshare_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AppStateSyncKeyShare* ProtocolMessage::unsafe_arena_release_appstatesynckeyshare() {
  // @@protoc_insertion_point(field_release:proto.ProtocolMessage.appStateSyncKeyShare)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::AppStateSyncKeyShare* temp = _impl_.appstatesynckeyshare_;
  _impl_.appstatesynckeyshare_ = nullptr;
  return temp;
}
inline ::proto::AppStateSyncKeyShare* ProtocolMessage::_internal_mutable_appstatesynckeyshare() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.appstatesynckeyshare_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AppStateSyncKeyShare>(GetArenaForAllocation());
    _impl_.appstatesynckeyshare_ = p;
  }
  return _impl_.appstatesynckeyshare_;
}
inline ::proto::AppStateSyncKeyShare* ProtocolMessage::mutable_appstatesynckeyshare() {
  ::proto::AppStateSyncKeyShare* _msg = _internal_mutable_appstatesynckeyshare();
  // @@protoc_insertion_point(field_mutable:proto.ProtocolMessage.appStateSyncKeyShare)
  return _msg;
}
inline void ProtocolMessage::set_allocated_appstatesynckeyshare(::proto::AppStateSyncKeyShare* appstatesynckeyshare) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.appstatesynckeyshare_;
  }
  if (appstatesynckeyshare) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(appstatesynckeyshare);
    if (message_arena != submessage_arena) {
      appstatesynckeyshare = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, appstatesynckeyshare, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.appstatesynckeyshare_ = appstatesynckeyshare;
  // @@protoc_insertion_point(field_set_allocated:proto.ProtocolMessage.appStateSyncKeyShare)
}

// optional .proto.AppStateSyncKeyRequest appStateSyncKeyRequest = 8;
inline bool ProtocolMessage::_internal_has_appstatesynckeyrequest() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.appstatesynckeyrequest_ != nullptr);
  return value;
}
inline bool ProtocolMessage::has_appstatesynckeyrequest() const {
  return _internal_has_appstatesynckeyrequest();
}
inline void ProtocolMessage::clear_appstatesynckeyrequest() {
  if (_impl_.appstatesynckeyrequest_ != nullptr) _impl_.appstatesynckeyrequest_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::proto::AppStateSyncKeyRequest& ProtocolMessage::_internal_appstatesynckeyrequest() const {
  const ::proto::AppStateSyncKeyRequest* p = _impl_.appstatesynckeyrequest_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AppStateSyncKeyRequest&>(
      ::proto::_AppStateSyncKeyRequest_default_instance_);
}
inline const ::proto::AppStateSyncKeyRequest& ProtocolMessage::appstatesynckeyrequest() const {
  // @@protoc_insertion_point(field_get:proto.ProtocolMessage.appStateSyncKeyRequest)
  return _internal_appstatesynckeyrequest();
}
inline void ProtocolMessage::unsafe_arena_set_allocated_appstatesynckeyrequest(
    ::proto::AppStateSyncKeyRequest* appstatesynckeyrequest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.appstatesynckeyrequest_);
  }
  _impl_.appstatesynckeyrequest_ = appstatesynckeyrequest;
  if (appstatesynckeyrequest) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ProtocolMessage.appStateSyncKeyRequest)
}
inline ::proto::AppStateSyncKeyRequest* ProtocolMessage::release_appstatesynckeyrequest() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::proto::AppStateSyncKeyRequest* temp = _impl_.appstatesynckeyrequest_;
  _impl_.appstatesynckeyrequest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AppStateSyncKeyRequest* ProtocolMessage::unsafe_arena_release_appstatesynckeyrequest() {
  // @@protoc_insertion_point(field_release:proto.ProtocolMessage.appStateSyncKeyRequest)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::proto::AppStateSyncKeyRequest* temp = _impl_.appstatesynckeyrequest_;
  _impl_.appstatesynckeyrequest_ = nullptr;
  return temp;
}
inline ::proto::AppStateSyncKeyRequest* ProtocolMessage::_internal_mutable_appstatesynckeyrequest() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.appstatesynckeyrequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AppStateSyncKeyRequest>(GetArenaForAllocation());
    _impl_.appstatesynckeyrequest_ = p;
  }
  return _impl_.appstatesynckeyrequest_;
}
inline ::proto::AppStateSyncKeyRequest* ProtocolMessage::mutable_appstatesynckeyrequest() {
  ::proto::AppStateSyncKeyRequest* _msg = _internal_mutable_appstatesynckeyrequest();
  // @@protoc_insertion_point(field_mutable:proto.ProtocolMessage.appStateSyncKeyRequest)
  return _msg;
}
inline void ProtocolMessage::set_allocated_appstatesynckeyrequest(::proto::AppStateSyncKeyRequest* appstatesynckeyrequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.appstatesynckeyrequest_;
  }
  if (appstatesynckeyrequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(appstatesynckeyrequest);
    if (message_arena != submessage_arena) {
      appstatesynckeyrequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, appstatesynckeyrequest, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.appstatesynckeyrequest_ = appstatesynckeyrequest;
  // @@protoc_insertion_point(field_set_allocated:proto.ProtocolMessage.appStateSyncKeyRequest)
}

// optional .proto.InitialSecurityNotificationSettingSync initialSecurityNotificationSettingSync = 9;
inline bool ProtocolMessage::_internal_has_initialsecuritynotificationsettingsync() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.initialsecuritynotificationsettingsync_ != nullptr);
  return value;
}
inline bool ProtocolMessage::has_initialsecuritynotificationsettingsync() const {
  return _internal_has_initialsecuritynotificationsettingsync();
}
inline void ProtocolMessage::clear_initialsecuritynotificationsettingsync() {
  if (_impl_.initialsecuritynotificationsettingsync_ != nullptr) _impl_.initialsecuritynotificationsettingsync_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::proto::InitialSecurityNotificationSettingSync& ProtocolMessage::_internal_initialsecuritynotificationsettingsync() const {
  const ::proto::InitialSecurityNotificationSettingSync* p = _impl_.initialsecuritynotificationsettingsync_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::InitialSecurityNotificationSettingSync&>(
      ::proto::_InitialSecurityNotificationSettingSync_default_instance_);
}
inline const ::proto::InitialSecurityNotificationSettingSync& ProtocolMessage::initialsecuritynotificationsettingsync() const {
  // @@protoc_insertion_point(field_get:proto.ProtocolMessage.initialSecurityNotificationSettingSync)
  return _internal_initialsecuritynotificationsettingsync();
}
inline void ProtocolMessage::unsafe_arena_set_allocated_initialsecuritynotificationsettingsync(
    ::proto::InitialSecurityNotificationSettingSync* initialsecuritynotificationsettingsync) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.initialsecuritynotificationsettingsync_);
  }
  _impl_.initialsecuritynotificationsettingsync_ = initialsecuritynotificationsettingsync;
  if (initialsecuritynotificationsettingsync) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ProtocolMessage.initialSecurityNotificationSettingSync)
}
inline ::proto::InitialSecurityNotificationSettingSync* ProtocolMessage::release_initialsecuritynotificationsettingsync() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::proto::InitialSecurityNotificationSettingSync* temp = _impl_.initialsecuritynotificationsettingsync_;
  _impl_.initialsecuritynotificationsettingsync_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::InitialSecurityNotificationSettingSync* ProtocolMessage::unsafe_arena_release_initialsecuritynotificationsettingsync() {
  // @@protoc_insertion_point(field_release:proto.ProtocolMessage.initialSecurityNotificationSettingSync)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::proto::InitialSecurityNotificationSettingSync* temp = _impl_.initialsecuritynotificationsettingsync_;
  _impl_.initialsecuritynotificationsettingsync_ = nullptr;
  return temp;
}
inline ::proto::InitialSecurityNotificationSettingSync* ProtocolMessage::_internal_mutable_initialsecuritynotificationsettingsync() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.initialsecuritynotificationsettingsync_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::InitialSecurityNotificationSettingSync>(GetArenaForAllocation());
    _impl_.initialsecuritynotificationsettingsync_ = p;
  }
  return _impl_.initialsecuritynotificationsettingsync_;
}
inline ::proto::InitialSecurityNotificationSettingSync* ProtocolMessage::mutable_initialsecuritynotificationsettingsync() {
  ::proto::InitialSecurityNotificationSettingSync* _msg = _internal_mutable_initialsecuritynotificationsettingsync();
  // @@protoc_insertion_point(field_mutable:proto.ProtocolMessage.initialSecurityNotificationSettingSync)
  return _msg;
}
inline void ProtocolMessage::set_allocated_initialsecuritynotificationsettingsync(::proto::InitialSecurityNotificationSettingSync* initialsecuritynotificationsettingsync) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.initialsecuritynotificationsettingsync_;
  }
  if (initialsecuritynotificationsettingsync) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(initialsecuritynotificationsettingsync);
    if (message_arena != submessage_arena) {
      initialsecuritynotificationsettingsync = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initialsecuritynotificationsettingsync, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.initialsecuritynotificationsettingsync_ = initialsecuritynotificationsettingsync;
  // @@protoc_insertion_point(field_set_allocated:proto.ProtocolMessage.initialSecurityNotificationSettingSync)
}

// optional .proto.AppStateFatalExceptionNotification appStateFatalExceptionNotification = 10;
inline bool ProtocolMessage::_internal_has_appstatefatalexceptionnotification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.appstatefatalexceptionnotification_ != nullptr);
  return value;
}
inline bool ProtocolMessage::has_appstatefatalexceptionnotification() const {
  return _internal_has_appstatefatalexceptionnotification();
}
inline void ProtocolMessage::clear_appstatefatalexceptionnotification() {
  if (_impl_.appstatefatalexceptionnotification_ != nullptr) _impl_.appstatefatalexceptionnotification_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::proto::AppStateFatalExceptionNotification& ProtocolMessage::_internal_appstatefatalexceptionnotification() const {
  const ::proto::AppStateFatalExceptionNotification* p = _impl_.appstatefatalexceptionnotification_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AppStateFatalExceptionNotification&>(
      ::proto::_AppStateFatalExceptionNotification_default_instance_);
}
inline const ::proto::AppStateFatalExceptionNotification& ProtocolMessage::appstatefatalexceptionnotification() const {
  // @@protoc_insertion_point(field_get:proto.ProtocolMessage.appStateFatalExceptionNotification)
  return _internal_appstatefatalexceptionnotification();
}
inline void ProtocolMessage::unsafe_arena_set_allocated_appstatefatalexceptionnotification(
    ::proto::AppStateFatalExceptionNotification* appstatefatalexceptionnotification) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.appstatefatalexceptionnotification_);
  }
  _impl_.appstatefatalexceptionnotification_ = appstatefatalexceptionnotification;
  if (appstatefatalexceptionnotification) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ProtocolMessage.appStateFatalExceptionNotification)
}
inline ::proto::AppStateFatalExceptionNotification* ProtocolMessage::release_appstatefatalexceptionnotification() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::proto::AppStateFatalExceptionNotification* temp = _impl_.appstatefatalexceptionnotification_;
  _impl_.appstatefatalexceptionnotification_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AppStateFatalExceptionNotification* ProtocolMessage::unsafe_arena_release_appstatefatalexceptionnotification() {
  // @@protoc_insertion_point(field_release:proto.ProtocolMessage.appStateFatalExceptionNotification)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::proto::AppStateFatalExceptionNotification* temp = _impl_.appstatefatalexceptionnotification_;
  _impl_.appstatefatalexceptionnotification_ = nullptr;
  return temp;
}
inline ::proto::AppStateFatalExceptionNotification* ProtocolMessage::_internal_mutable_appstatefatalexceptionnotification() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.appstatefatalexceptionnotification_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AppStateFatalExceptionNotification>(GetArenaForAllocation());
    _impl_.appstatefatalexceptionnotification_ = p;
  }
  return _impl_.appstatefatalexceptionnotification_;
}
inline ::proto::AppStateFatalExceptionNotification* ProtocolMessage::mutable_appstatefatalexceptionnotification() {
  ::proto::AppStateFatalExceptionNotification* _msg = _internal_mutable_appstatefatalexceptionnotification();
  // @@protoc_insertion_point(field_mutable:proto.ProtocolMessage.appStateFatalExceptionNotification)
  return _msg;
}
inline void ProtocolMessage::set_allocated_appstatefatalexceptionnotification(::proto::AppStateFatalExceptionNotification* appstatefatalexceptionnotification) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.appstatefatalexceptionnotification_;
  }
  if (appstatefatalexceptionnotification) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(appstatefatalexceptionnotification);
    if (message_arena != submessage_arena) {
      appstatefatalexceptionnotification = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, appstatefatalexceptionnotification, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.appstatefatalexceptionnotification_ = appstatefatalexceptionnotification;
  // @@protoc_insertion_point(field_set_allocated:proto.ProtocolMessage.appStateFatalExceptionNotification)
}

// -------------------------------------------------------------------

// HistorySyncNotification

// optional bytes fileSha256 = 1;
inline bool HistorySyncNotification::_internal_has_filesha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HistorySyncNotification::has_filesha256() const {
  return _internal_has_filesha256();
}
inline void HistorySyncNotification::clear_filesha256() {
  _impl_.filesha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HistorySyncNotification::filesha256() const {
  // @@protoc_insertion_point(field_get:proto.HistorySyncNotification.fileSha256)
  return _internal_filesha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HistorySyncNotification::set_filesha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.filesha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HistorySyncNotification.fileSha256)
}
inline std::string* HistorySyncNotification::mutable_filesha256() {
  std::string* _s = _internal_mutable_filesha256();
  // @@protoc_insertion_point(field_mutable:proto.HistorySyncNotification.fileSha256)
  return _s;
}
inline const std::string& HistorySyncNotification::_internal_filesha256() const {
  return _impl_.filesha256_.Get();
}
inline void HistorySyncNotification::_internal_set_filesha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filesha256_.Set(value, GetArenaForAllocation());
}
inline std::string* HistorySyncNotification::_internal_mutable_filesha256() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filesha256_.Mutable(GetArenaForAllocation());
}
inline std::string* HistorySyncNotification::release_filesha256() {
  // @@protoc_insertion_point(field_release:proto.HistorySyncNotification.fileSha256)
  if (!_internal_has_filesha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.filesha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filesha256_.IsDefault()) {
    _impl_.filesha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HistorySyncNotification::set_allocated_filesha256(std::string* filesha256) {
  if (filesha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filesha256_.SetAllocated(filesha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filesha256_.IsDefault()) {
    _impl_.filesha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HistorySyncNotification.fileSha256)
}

// optional uint64 fileLength = 2;
inline bool HistorySyncNotification::_internal_has_filelength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool HistorySyncNotification::has_filelength() const {
  return _internal_has_filelength();
}
inline void HistorySyncNotification::clear_filelength() {
  _impl_.filelength_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t HistorySyncNotification::_internal_filelength() const {
  return _impl_.filelength_;
}
inline uint64_t HistorySyncNotification::filelength() const {
  // @@protoc_insertion_point(field_get:proto.HistorySyncNotification.fileLength)
  return _internal_filelength();
}
inline void HistorySyncNotification::_internal_set_filelength(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.filelength_ = value;
}
inline void HistorySyncNotification::set_filelength(uint64_t value) {
  _internal_set_filelength(value);
  // @@protoc_insertion_point(field_set:proto.HistorySyncNotification.fileLength)
}

// optional bytes mediaKey = 3;
inline bool HistorySyncNotification::_internal_has_mediakey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HistorySyncNotification::has_mediakey() const {
  return _internal_has_mediakey();
}
inline void HistorySyncNotification::clear_mediakey() {
  _impl_.mediakey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HistorySyncNotification::mediakey() const {
  // @@protoc_insertion_point(field_get:proto.HistorySyncNotification.mediaKey)
  return _internal_mediakey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HistorySyncNotification::set_mediakey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.mediakey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HistorySyncNotification.mediaKey)
}
inline std::string* HistorySyncNotification::mutable_mediakey() {
  std::string* _s = _internal_mutable_mediakey();
  // @@protoc_insertion_point(field_mutable:proto.HistorySyncNotification.mediaKey)
  return _s;
}
inline const std::string& HistorySyncNotification::_internal_mediakey() const {
  return _impl_.mediakey_.Get();
}
inline void HistorySyncNotification::_internal_set_mediakey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mediakey_.Set(value, GetArenaForAllocation());
}
inline std::string* HistorySyncNotification::_internal_mutable_mediakey() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mediakey_.Mutable(GetArenaForAllocation());
}
inline std::string* HistorySyncNotification::release_mediakey() {
  // @@protoc_insertion_point(field_release:proto.HistorySyncNotification.mediaKey)
  if (!_internal_has_mediakey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.mediakey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mediakey_.IsDefault()) {
    _impl_.mediakey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HistorySyncNotification::set_allocated_mediakey(std::string* mediakey) {
  if (mediakey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mediakey_.SetAllocated(mediakey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mediakey_.IsDefault()) {
    _impl_.mediakey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HistorySyncNotification.mediaKey)
}

// optional bytes fileEncSha256 = 4;
inline bool HistorySyncNotification::_internal_has_fileencsha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HistorySyncNotification::has_fileencsha256() const {
  return _internal_has_fileencsha256();
}
inline void HistorySyncNotification::clear_fileencsha256() {
  _impl_.fileencsha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& HistorySyncNotification::fileencsha256() const {
  // @@protoc_insertion_point(field_get:proto.HistorySyncNotification.fileEncSha256)
  return _internal_fileencsha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HistorySyncNotification::set_fileencsha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.fileencsha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HistorySyncNotification.fileEncSha256)
}
inline std::string* HistorySyncNotification::mutable_fileencsha256() {
  std::string* _s = _internal_mutable_fileencsha256();
  // @@protoc_insertion_point(field_mutable:proto.HistorySyncNotification.fileEncSha256)
  return _s;
}
inline const std::string& HistorySyncNotification::_internal_fileencsha256() const {
  return _impl_.fileencsha256_.Get();
}
inline void HistorySyncNotification::_internal_set_fileencsha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.fileencsha256_.Set(value, GetArenaForAllocation());
}
inline std::string* HistorySyncNotification::_internal_mutable_fileencsha256() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.fileencsha256_.Mutable(GetArenaForAllocation());
}
inline std::string* HistorySyncNotification::release_fileencsha256() {
  // @@protoc_insertion_point(field_release:proto.HistorySyncNotification.fileEncSha256)
  if (!_internal_has_fileencsha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.fileencsha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fileencsha256_.IsDefault()) {
    _impl_.fileencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HistorySyncNotification::set_allocated_fileencsha256(std::string* fileencsha256) {
  if (fileencsha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.fileencsha256_.SetAllocated(fileencsha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fileencsha256_.IsDefault()) {
    _impl_.fileencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HistorySyncNotification.fileEncSha256)
}

// optional string directPath = 5;
inline bool HistorySyncNotification::_internal_has_directpath() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool HistorySyncNotification::has_directpath() const {
  return _internal_has_directpath();
}
inline void HistorySyncNotification::clear_directpath() {
  _impl_.directpath_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& HistorySyncNotification::directpath() const {
  // @@protoc_insertion_point(field_get:proto.HistorySyncNotification.directPath)
  return _internal_directpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HistorySyncNotification::set_directpath(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.directpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HistorySyncNotification.directPath)
}
inline std::string* HistorySyncNotification::mutable_directpath() {
  std::string* _s = _internal_mutable_directpath();
  // @@protoc_insertion_point(field_mutable:proto.HistorySyncNotification.directPath)
  return _s;
}
inline const std::string& HistorySyncNotification::_internal_directpath() const {
  return _impl_.directpath_.Get();
}
inline void HistorySyncNotification::_internal_set_directpath(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.directpath_.Set(value, GetArenaForAllocation());
}
inline std::string* HistorySyncNotification::_internal_mutable_directpath() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.directpath_.Mutable(GetArenaForAllocation());
}
inline std::string* HistorySyncNotification::release_directpath() {
  // @@protoc_insertion_point(field_release:proto.HistorySyncNotification.directPath)
  if (!_internal_has_directpath()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.directpath_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.directpath_.IsDefault()) {
    _impl_.directpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HistorySyncNotification::set_allocated_directpath(std::string* directpath) {
  if (directpath != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.directpath_.SetAllocated(directpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.directpath_.IsDefault()) {
    _impl_.directpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HistorySyncNotification.directPath)
}

// optional .proto.HistorySyncNotification.HistorySyncNotificationHistorySyncType syncType = 6;
inline bool HistorySyncNotification::_internal_has_synctype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool HistorySyncNotification::has_synctype() const {
  return _internal_has_synctype();
}
inline void HistorySyncNotification::clear_synctype() {
  _impl_.synctype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::proto::HistorySyncNotification_HistorySyncNotificationHistorySyncType HistorySyncNotification::_internal_synctype() const {
  return static_cast< ::proto::HistorySyncNotification_HistorySyncNotificationHistorySyncType >(_impl_.synctype_);
}
inline ::proto::HistorySyncNotification_HistorySyncNotificationHistorySyncType HistorySyncNotification::synctype() const {
  // @@protoc_insertion_point(field_get:proto.HistorySyncNotification.syncType)
  return _internal_synctype();
}
inline void HistorySyncNotification::_internal_set_synctype(::proto::HistorySyncNotification_HistorySyncNotificationHistorySyncType value) {
  assert(::proto::HistorySyncNotification_HistorySyncNotificationHistorySyncType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.synctype_ = value;
}
inline void HistorySyncNotification::set_synctype(::proto::HistorySyncNotification_HistorySyncNotificationHistorySyncType value) {
  _internal_set_synctype(value);
  // @@protoc_insertion_point(field_set:proto.HistorySyncNotification.syncType)
}

// optional uint32 chunkOrder = 7;
inline bool HistorySyncNotification::_internal_has_chunkorder() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool HistorySyncNotification::has_chunkorder() const {
  return _internal_has_chunkorder();
}
inline void HistorySyncNotification::clear_chunkorder() {
  _impl_.chunkorder_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t HistorySyncNotification::_internal_chunkorder() const {
  return _impl_.chunkorder_;
}
inline uint32_t HistorySyncNotification::chunkorder() const {
  // @@protoc_insertion_point(field_get:proto.HistorySyncNotification.chunkOrder)
  return _internal_chunkorder();
}
inline void HistorySyncNotification::_internal_set_chunkorder(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.chunkorder_ = value;
}
inline void HistorySyncNotification::set_chunkorder(uint32_t value) {
  _internal_set_chunkorder(value);
  // @@protoc_insertion_point(field_set:proto.HistorySyncNotification.chunkOrder)
}

// optional string originalMessageId = 8;
inline bool HistorySyncNotification::_internal_has_originalmessageid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool HistorySyncNotification::has_originalmessageid() const {
  return _internal_has_originalmessageid();
}
inline void HistorySyncNotification::clear_originalmessageid() {
  _impl_.originalmessageid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& HistorySyncNotification::originalmessageid() const {
  // @@protoc_insertion_point(field_get:proto.HistorySyncNotification.originalMessageId)
  return _internal_originalmessageid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HistorySyncNotification::set_originalmessageid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.originalmessageid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HistorySyncNotification.originalMessageId)
}
inline std::string* HistorySyncNotification::mutable_originalmessageid() {
  std::string* _s = _internal_mutable_originalmessageid();
  // @@protoc_insertion_point(field_mutable:proto.HistorySyncNotification.originalMessageId)
  return _s;
}
inline const std::string& HistorySyncNotification::_internal_originalmessageid() const {
  return _impl_.originalmessageid_.Get();
}
inline void HistorySyncNotification::_internal_set_originalmessageid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.originalmessageid_.Set(value, GetArenaForAllocation());
}
inline std::string* HistorySyncNotification::_internal_mutable_originalmessageid() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.originalmessageid_.Mutable(GetArenaForAllocation());
}
inline std::string* HistorySyncNotification::release_originalmessageid() {
  // @@protoc_insertion_point(field_release:proto.HistorySyncNotification.originalMessageId)
  if (!_internal_has_originalmessageid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.originalmessageid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalmessageid_.IsDefault()) {
    _impl_.originalmessageid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HistorySyncNotification::set_allocated_originalmessageid(std::string* originalmessageid) {
  if (originalmessageid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.originalmessageid_.SetAllocated(originalmessageid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalmessageid_.IsDefault()) {
    _impl_.originalmessageid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HistorySyncNotification.originalMessageId)
}

// -------------------------------------------------------------------

// AppStateSyncKey

// optional .proto.AppStateSyncKeyId keyId = 1;
inline bool AppStateSyncKey::_internal_has_keyid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.keyid_ != nullptr);
  return value;
}
inline bool AppStateSyncKey::has_keyid() const {
  return _internal_has_keyid();
}
inline void AppStateSyncKey::clear_keyid() {
  if (_impl_.keyid_ != nullptr) _impl_.keyid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::AppStateSyncKeyId& AppStateSyncKey::_internal_keyid() const {
  const ::proto::AppStateSyncKeyId* p = _impl_.keyid_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AppStateSyncKeyId&>(
      ::proto::_AppStateSyncKeyId_default_instance_);
}
inline const ::proto::AppStateSyncKeyId& AppStateSyncKey::keyid() const {
  // @@protoc_insertion_point(field_get:proto.AppStateSyncKey.keyId)
  return _internal_keyid();
}
inline void AppStateSyncKey::unsafe_arena_set_allocated_keyid(
    ::proto::AppStateSyncKeyId* keyid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.keyid_);
  }
  _impl_.keyid_ = keyid;
  if (keyid) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.AppStateSyncKey.keyId)
}
inline ::proto::AppStateSyncKeyId* AppStateSyncKey::release_keyid() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::AppStateSyncKeyId* temp = _impl_.keyid_;
  _impl_.keyid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AppStateSyncKeyId* AppStateSyncKey::unsafe_arena_release_keyid() {
  // @@protoc_insertion_point(field_release:proto.AppStateSyncKey.keyId)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::AppStateSyncKeyId* temp = _impl_.keyid_;
  _impl_.keyid_ = nullptr;
  return temp;
}
inline ::proto::AppStateSyncKeyId* AppStateSyncKey::_internal_mutable_keyid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.keyid_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AppStateSyncKeyId>(GetArenaForAllocation());
    _impl_.keyid_ = p;
  }
  return _impl_.keyid_;
}
inline ::proto::AppStateSyncKeyId* AppStateSyncKey::mutable_keyid() {
  ::proto::AppStateSyncKeyId* _msg = _internal_mutable_keyid();
  // @@protoc_insertion_point(field_mutable:proto.AppStateSyncKey.keyId)
  return _msg;
}
inline void AppStateSyncKey::set_allocated_keyid(::proto::AppStateSyncKeyId* keyid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.keyid_;
  }
  if (keyid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(keyid);
    if (message_arena != submessage_arena) {
      keyid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keyid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.keyid_ = keyid;
  // @@protoc_insertion_point(field_set_allocated:proto.AppStateSyncKey.keyId)
}

// optional .proto.AppStateSyncKeyData keyData = 2;
inline bool AppStateSyncKey::_internal_has_keydata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.keydata_ != nullptr);
  return value;
}
inline bool AppStateSyncKey::has_keydata() const {
  return _internal_has_keydata();
}
inline void AppStateSyncKey::clear_keydata() {
  if (_impl_.keydata_ != nullptr) _impl_.keydata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::AppStateSyncKeyData& AppStateSyncKey::_internal_keydata() const {
  const ::proto::AppStateSyncKeyData* p = _impl_.keydata_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AppStateSyncKeyData&>(
      ::proto::_AppStateSyncKeyData_default_instance_);
}
inline const ::proto::AppStateSyncKeyData& AppStateSyncKey::keydata() const {
  // @@protoc_insertion_point(field_get:proto.AppStateSyncKey.keyData)
  return _internal_keydata();
}
inline void AppStateSyncKey::unsafe_arena_set_allocated_keydata(
    ::proto::AppStateSyncKeyData* keydata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.keydata_);
  }
  _impl_.keydata_ = keydata;
  if (keydata) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.AppStateSyncKey.keyData)
}
inline ::proto::AppStateSyncKeyData* AppStateSyncKey::release_keydata() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::AppStateSyncKeyData* temp = _impl_.keydata_;
  _impl_.keydata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AppStateSyncKeyData* AppStateSyncKey::unsafe_arena_release_keydata() {
  // @@protoc_insertion_point(field_release:proto.AppStateSyncKey.keyData)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::AppStateSyncKeyData* temp = _impl_.keydata_;
  _impl_.keydata_ = nullptr;
  return temp;
}
inline ::proto::AppStateSyncKeyData* AppStateSyncKey::_internal_mutable_keydata() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.keydata_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AppStateSyncKeyData>(GetArenaForAllocation());
    _impl_.keydata_ = p;
  }
  return _impl_.keydata_;
}
inline ::proto::AppStateSyncKeyData* AppStateSyncKey::mutable_keydata() {
  ::proto::AppStateSyncKeyData* _msg = _internal_mutable_keydata();
  // @@protoc_insertion_point(field_mutable:proto.AppStateSyncKey.keyData)
  return _msg;
}
inline void AppStateSyncKey::set_allocated_keydata(::proto::AppStateSyncKeyData* keydata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.keydata_;
  }
  if (keydata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(keydata);
    if (message_arena != submessage_arena) {
      keydata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keydata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.keydata_ = keydata;
  // @@protoc_insertion_point(field_set_allocated:proto.AppStateSyncKey.keyData)
}

// -------------------------------------------------------------------

// AppStateSyncKeyId

// optional bytes keyId = 1;
inline bool AppStateSyncKeyId::_internal_has_keyid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AppStateSyncKeyId::has_keyid() const {
  return _internal_has_keyid();
}
inline void AppStateSyncKeyId::clear_keyid() {
  _impl_.keyid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppStateSyncKeyId::keyid() const {
  // @@protoc_insertion_point(field_get:proto.AppStateSyncKeyId.keyId)
  return _internal_keyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppStateSyncKeyId::set_keyid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.keyid_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.AppStateSyncKeyId.keyId)
}
inline std::string* AppStateSyncKeyId::mutable_keyid() {
  std::string* _s = _internal_mutable_keyid();
  // @@protoc_insertion_point(field_mutable:proto.AppStateSyncKeyId.keyId)
  return _s;
}
inline const std::string& AppStateSyncKeyId::_internal_keyid() const {
  return _impl_.keyid_.Get();
}
inline void AppStateSyncKeyId::_internal_set_keyid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.keyid_.Set(value, GetArenaForAllocation());
}
inline std::string* AppStateSyncKeyId::_internal_mutable_keyid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.keyid_.Mutable(GetArenaForAllocation());
}
inline std::string* AppStateSyncKeyId::release_keyid() {
  // @@protoc_insertion_point(field_release:proto.AppStateSyncKeyId.keyId)
  if (!_internal_has_keyid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.keyid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.keyid_.IsDefault()) {
    _impl_.keyid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppStateSyncKeyId::set_allocated_keyid(std::string* keyid) {
  if (keyid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.keyid_.SetAllocated(keyid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.keyid_.IsDefault()) {
    _impl_.keyid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.AppStateSyncKeyId.keyId)
}

// -------------------------------------------------------------------

// AppStateSyncKeyFingerprint

// optional uint32 rawId = 1;
inline bool AppStateSyncKeyFingerprint::_internal_has_rawid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AppStateSyncKeyFingerprint::has_rawid() const {
  return _internal_has_rawid();
}
inline void AppStateSyncKeyFingerprint::clear_rawid() {
  _impl_.rawid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t AppStateSyncKeyFingerprint::_internal_rawid() const {
  return _impl_.rawid_;
}
inline uint32_t AppStateSyncKeyFingerprint::rawid() const {
  // @@protoc_insertion_point(field_get:proto.AppStateSyncKeyFingerprint.rawId)
  return _internal_rawid();
}
inline void AppStateSyncKeyFingerprint::_internal_set_rawid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rawid_ = value;
}
inline void AppStateSyncKeyFingerprint::set_rawid(uint32_t value) {
  _internal_set_rawid(value);
  // @@protoc_insertion_point(field_set:proto.AppStateSyncKeyFingerprint.rawId)
}

// optional uint32 currentIndex = 2;
inline bool AppStateSyncKeyFingerprint::_internal_has_currentindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AppStateSyncKeyFingerprint::has_currentindex() const {
  return _internal_has_currentindex();
}
inline void AppStateSyncKeyFingerprint::clear_currentindex() {
  _impl_.currentindex_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t AppStateSyncKeyFingerprint::_internal_currentindex() const {
  return _impl_.currentindex_;
}
inline uint32_t AppStateSyncKeyFingerprint::currentindex() const {
  // @@protoc_insertion_point(field_get:proto.AppStateSyncKeyFingerprint.currentIndex)
  return _internal_currentindex();
}
inline void AppStateSyncKeyFingerprint::_internal_set_currentindex(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.currentindex_ = value;
}
inline void AppStateSyncKeyFingerprint::set_currentindex(uint32_t value) {
  _internal_set_currentindex(value);
  // @@protoc_insertion_point(field_set:proto.AppStateSyncKeyFingerprint.currentIndex)
}

// repeated uint32 deviceIndexes = 3 [packed = true];
inline int AppStateSyncKeyFingerprint::_internal_deviceindexes_size() const {
  return _impl_.deviceindexes_.size();
}
inline int AppStateSyncKeyFingerprint::deviceindexes_size() const {
  return _internal_deviceindexes_size();
}
inline void AppStateSyncKeyFingerprint::clear_deviceindexes() {
  _impl_.deviceindexes_.Clear();
}
inline uint32_t AppStateSyncKeyFingerprint::_internal_deviceindexes(int index) const {
  return _impl_.deviceindexes_.Get(index);
}
inline uint32_t AppStateSyncKeyFingerprint::deviceindexes(int index) const {
  // @@protoc_insertion_point(field_get:proto.AppStateSyncKeyFingerprint.deviceIndexes)
  return _internal_deviceindexes(index);
}
inline void AppStateSyncKeyFingerprint::set_deviceindexes(int index, uint32_t value) {
  _impl_.deviceindexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.AppStateSyncKeyFingerprint.deviceIndexes)
}
inline void AppStateSyncKeyFingerprint::_internal_add_deviceindexes(uint32_t value) {
  _impl_.deviceindexes_.Add(value);
}
inline void AppStateSyncKeyFingerprint::add_deviceindexes(uint32_t value) {
  _internal_add_deviceindexes(value);
  // @@protoc_insertion_point(field_add:proto.AppStateSyncKeyFingerprint.deviceIndexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
AppStateSyncKeyFingerprint::_internal_deviceindexes() const {
  return _impl_.deviceindexes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
AppStateSyncKeyFingerprint::deviceindexes() const {
  // @@protoc_insertion_point(field_list:proto.AppStateSyncKeyFingerprint.deviceIndexes)
  return _internal_deviceindexes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
AppStateSyncKeyFingerprint::_internal_mutable_deviceindexes() {
  return &_impl_.deviceindexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
AppStateSyncKeyFingerprint::mutable_deviceindexes() {
  // @@protoc_insertion_point(field_mutable_list:proto.AppStateSyncKeyFingerprint.deviceIndexes)
  return _internal_mutable_deviceindexes();
}

// -------------------------------------------------------------------

// AppStateSyncKeyData

// optional bytes keyData = 1;
inline bool AppStateSyncKeyData::_internal_has_keydata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AppStateSyncKeyData::has_keydata() const {
  return _internal_has_keydata();
}
inline void AppStateSyncKeyData::clear_keydata() {
  _impl_.keydata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppStateSyncKeyData::keydata() const {
  // @@protoc_insertion_point(field_get:proto.AppStateSyncKeyData.keyData)
  return _internal_keydata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppStateSyncKeyData::set_keydata(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.keydata_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.AppStateSyncKeyData.keyData)
}
inline std::string* AppStateSyncKeyData::mutable_keydata() {
  std::string* _s = _internal_mutable_keydata();
  // @@protoc_insertion_point(field_mutable:proto.AppStateSyncKeyData.keyData)
  return _s;
}
inline const std::string& AppStateSyncKeyData::_internal_keydata() const {
  return _impl_.keydata_.Get();
}
inline void AppStateSyncKeyData::_internal_set_keydata(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.keydata_.Set(value, GetArenaForAllocation());
}
inline std::string* AppStateSyncKeyData::_internal_mutable_keydata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.keydata_.Mutable(GetArenaForAllocation());
}
inline std::string* AppStateSyncKeyData::release_keydata() {
  // @@protoc_insertion_point(field_release:proto.AppStateSyncKeyData.keyData)
  if (!_internal_has_keydata()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.keydata_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.keydata_.IsDefault()) {
    _impl_.keydata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppStateSyncKeyData::set_allocated_keydata(std::string* keydata) {
  if (keydata != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.keydata_.SetAllocated(keydata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.keydata_.IsDefault()) {
    _impl_.keydata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.AppStateSyncKeyData.keyData)
}

// optional .proto.AppStateSyncKeyFingerprint fingerprint = 2;
inline bool AppStateSyncKeyData::_internal_has_fingerprint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fingerprint_ != nullptr);
  return value;
}
inline bool AppStateSyncKeyData::has_fingerprint() const {
  return _internal_has_fingerprint();
}
inline void AppStateSyncKeyData::clear_fingerprint() {
  if (_impl_.fingerprint_ != nullptr) _impl_.fingerprint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::AppStateSyncKeyFingerprint& AppStateSyncKeyData::_internal_fingerprint() const {
  const ::proto::AppStateSyncKeyFingerprint* p = _impl_.fingerprint_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AppStateSyncKeyFingerprint&>(
      ::proto::_AppStateSyncKeyFingerprint_default_instance_);
}
inline const ::proto::AppStateSyncKeyFingerprint& AppStateSyncKeyData::fingerprint() const {
  // @@protoc_insertion_point(field_get:proto.AppStateSyncKeyData.fingerprint)
  return _internal_fingerprint();
}
inline void AppStateSyncKeyData::unsafe_arena_set_allocated_fingerprint(
    ::proto::AppStateSyncKeyFingerprint* fingerprint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fingerprint_);
  }
  _impl_.fingerprint_ = fingerprint;
  if (fingerprint) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.AppStateSyncKeyData.fingerprint)
}
inline ::proto::AppStateSyncKeyFingerprint* AppStateSyncKeyData::release_fingerprint() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::AppStateSyncKeyFingerprint* temp = _impl_.fingerprint_;
  _impl_.fingerprint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AppStateSyncKeyFingerprint* AppStateSyncKeyData::unsafe_arena_release_fingerprint() {
  // @@protoc_insertion_point(field_release:proto.AppStateSyncKeyData.fingerprint)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::AppStateSyncKeyFingerprint* temp = _impl_.fingerprint_;
  _impl_.fingerprint_ = nullptr;
  return temp;
}
inline ::proto::AppStateSyncKeyFingerprint* AppStateSyncKeyData::_internal_mutable_fingerprint() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.fingerprint_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AppStateSyncKeyFingerprint>(GetArenaForAllocation());
    _impl_.fingerprint_ = p;
  }
  return _impl_.fingerprint_;
}
inline ::proto::AppStateSyncKeyFingerprint* AppStateSyncKeyData::mutable_fingerprint() {
  ::proto::AppStateSyncKeyFingerprint* _msg = _internal_mutable_fingerprint();
  // @@protoc_insertion_point(field_mutable:proto.AppStateSyncKeyData.fingerprint)
  return _msg;
}
inline void AppStateSyncKeyData::set_allocated_fingerprint(::proto::AppStateSyncKeyFingerprint* fingerprint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fingerprint_;
  }
  if (fingerprint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fingerprint);
    if (message_arena != submessage_arena) {
      fingerprint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fingerprint, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.fingerprint_ = fingerprint;
  // @@protoc_insertion_point(field_set_allocated:proto.AppStateSyncKeyData.fingerprint)
}

// optional int64 timestamp = 3;
inline bool AppStateSyncKeyData::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AppStateSyncKeyData::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void AppStateSyncKeyData::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t AppStateSyncKeyData::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t AppStateSyncKeyData::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.AppStateSyncKeyData.timestamp)
  return _internal_timestamp();
}
inline void AppStateSyncKeyData::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.timestamp_ = value;
}
inline void AppStateSyncKeyData::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:proto.AppStateSyncKeyData.timestamp)
}

// -------------------------------------------------------------------

// AppStateSyncKeyShare

// repeated .proto.AppStateSyncKey keys = 1;
inline int AppStateSyncKeyShare::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int AppStateSyncKeyShare::keys_size() const {
  return _internal_keys_size();
}
inline void AppStateSyncKeyShare::clear_keys() {
  _impl_.keys_.Clear();
}
inline ::proto::AppStateSyncKey* AppStateSyncKeyShare::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:proto.AppStateSyncKeyShare.keys)
  return _impl_.keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AppStateSyncKey >*
AppStateSyncKeyShare::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:proto.AppStateSyncKeyShare.keys)
  return &_impl_.keys_;
}
inline const ::proto::AppStateSyncKey& AppStateSyncKeyShare::_internal_keys(int index) const {
  return _impl_.keys_.Get(index);
}
inline const ::proto::AppStateSyncKey& AppStateSyncKeyShare::keys(int index) const {
  // @@protoc_insertion_point(field_get:proto.AppStateSyncKeyShare.keys)
  return _internal_keys(index);
}
inline ::proto::AppStateSyncKey* AppStateSyncKeyShare::_internal_add_keys() {
  return _impl_.keys_.Add();
}
inline ::proto::AppStateSyncKey* AppStateSyncKeyShare::add_keys() {
  ::proto::AppStateSyncKey* _add = _internal_add_keys();
  // @@protoc_insertion_point(field_add:proto.AppStateSyncKeyShare.keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AppStateSyncKey >&
AppStateSyncKeyShare::keys() const {
  // @@protoc_insertion_point(field_list:proto.AppStateSyncKeyShare.keys)
  return _impl_.keys_;
}

// -------------------------------------------------------------------

// AppStateSyncKeyRequest

// repeated .proto.AppStateSyncKeyId keyIds = 1;
inline int AppStateSyncKeyRequest::_internal_keyids_size() const {
  return _impl_.keyids_.size();
}
inline int AppStateSyncKeyRequest::keyids_size() const {
  return _internal_keyids_size();
}
inline void AppStateSyncKeyRequest::clear_keyids() {
  _impl_.keyids_.Clear();
}
inline ::proto::AppStateSyncKeyId* AppStateSyncKeyRequest::mutable_keyids(int index) {
  // @@protoc_insertion_point(field_mutable:proto.AppStateSyncKeyRequest.keyIds)
  return _impl_.keyids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AppStateSyncKeyId >*
AppStateSyncKeyRequest::mutable_keyids() {
  // @@protoc_insertion_point(field_mutable_list:proto.AppStateSyncKeyRequest.keyIds)
  return &_impl_.keyids_;
}
inline const ::proto::AppStateSyncKeyId& AppStateSyncKeyRequest::_internal_keyids(int index) const {
  return _impl_.keyids_.Get(index);
}
inline const ::proto::AppStateSyncKeyId& AppStateSyncKeyRequest::keyids(int index) const {
  // @@protoc_insertion_point(field_get:proto.AppStateSyncKeyRequest.keyIds)
  return _internal_keyids(index);
}
inline ::proto::AppStateSyncKeyId* AppStateSyncKeyRequest::_internal_add_keyids() {
  return _impl_.keyids_.Add();
}
inline ::proto::AppStateSyncKeyId* AppStateSyncKeyRequest::add_keyids() {
  ::proto::AppStateSyncKeyId* _add = _internal_add_keyids();
  // @@protoc_insertion_point(field_add:proto.AppStateSyncKeyRequest.keyIds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AppStateSyncKeyId >&
AppStateSyncKeyRequest::keyids() const {
  // @@protoc_insertion_point(field_list:proto.AppStateSyncKeyRequest.keyIds)
  return _impl_.keyids_;
}

// -------------------------------------------------------------------

// AppStateFatalExceptionNotification

// repeated string collectionNames = 1;
inline int AppStateFatalExceptionNotification::_internal_collectionnames_size() const {
  return _impl_.collectionnames_.size();
}
inline int AppStateFatalExceptionNotification::collectionnames_size() const {
  return _internal_collectionnames_size();
}
inline void AppStateFatalExceptionNotification::clear_collectionnames() {
  _impl_.collectionnames_.Clear();
}
inline std::string* AppStateFatalExceptionNotification::add_collectionnames() {
  std::string* _s = _internal_add_collectionnames();
  // @@protoc_insertion_point(field_add_mutable:proto.AppStateFatalExceptionNotification.collectionNames)
  return _s;
}
inline const std::string& AppStateFatalExceptionNotification::_internal_collectionnames(int index) const {
  return _impl_.collectionnames_.Get(index);
}
inline const std::string& AppStateFatalExceptionNotification::collectionnames(int index) const {
  // @@protoc_insertion_point(field_get:proto.AppStateFatalExceptionNotification.collectionNames)
  return _internal_collectionnames(index);
}
inline std::string* AppStateFatalExceptionNotification::mutable_collectionnames(int index) {
  // @@protoc_insertion_point(field_mutable:proto.AppStateFatalExceptionNotification.collectionNames)
  return _impl_.collectionnames_.Mutable(index);
}
inline void AppStateFatalExceptionNotification::set_collectionnames(int index, const std::string& value) {
  _impl_.collectionnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.AppStateFatalExceptionNotification.collectionNames)
}
inline void AppStateFatalExceptionNotification::set_collectionnames(int index, std::string&& value) {
  _impl_.collectionnames_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.AppStateFatalExceptionNotification.collectionNames)
}
inline void AppStateFatalExceptionNotification::set_collectionnames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.collectionnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.AppStateFatalExceptionNotification.collectionNames)
}
inline void AppStateFatalExceptionNotification::set_collectionnames(int index, const char* value, size_t size) {
  _impl_.collectionnames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.AppStateFatalExceptionNotification.collectionNames)
}
inline std::string* AppStateFatalExceptionNotification::_internal_add_collectionnames() {
  return _impl_.collectionnames_.Add();
}
inline void AppStateFatalExceptionNotification::add_collectionnames(const std::string& value) {
  _impl_.collectionnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.AppStateFatalExceptionNotification.collectionNames)
}
inline void AppStateFatalExceptionNotification::add_collectionnames(std::string&& value) {
  _impl_.collectionnames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.AppStateFatalExceptionNotification.collectionNames)
}
inline void AppStateFatalExceptionNotification::add_collectionnames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.collectionnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.AppStateFatalExceptionNotification.collectionNames)
}
inline void AppStateFatalExceptionNotification::add_collectionnames(const char* value, size_t size) {
  _impl_.collectionnames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.AppStateFatalExceptionNotification.collectionNames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AppStateFatalExceptionNotification::collectionnames() const {
  // @@protoc_insertion_point(field_list:proto.AppStateFatalExceptionNotification.collectionNames)
  return _impl_.collectionnames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AppStateFatalExceptionNotification::mutable_collectionnames() {
  // @@protoc_insertion_point(field_mutable_list:proto.AppStateFatalExceptionNotification.collectionNames)
  return &_impl_.collectionnames_;
}

// optional int64 timestamp = 2;
inline bool AppStateFatalExceptionNotification::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AppStateFatalExceptionNotification::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void AppStateFatalExceptionNotification::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t AppStateFatalExceptionNotification::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t AppStateFatalExceptionNotification::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.AppStateFatalExceptionNotification.timestamp)
  return _internal_timestamp();
}
inline void AppStateFatalExceptionNotification::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ = value;
}
inline void AppStateFatalExceptionNotification::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:proto.AppStateFatalExceptionNotification.timestamp)
}

// -------------------------------------------------------------------

// InitialSecurityNotificationSettingSync

// optional bool securityNotificationEnabled = 1;
inline bool InitialSecurityNotificationSettingSync::_internal_has_securitynotificationenabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InitialSecurityNotificationSettingSync::has_securitynotificationenabled() const {
  return _internal_has_securitynotificationenabled();
}
inline void InitialSecurityNotificationSettingSync::clear_securitynotificationenabled() {
  _impl_.securitynotificationenabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool InitialSecurityNotificationSettingSync::_internal_securitynotificationenabled() const {
  return _impl_.securitynotificationenabled_;
}
inline bool InitialSecurityNotificationSettingSync::securitynotificationenabled() const {
  // @@protoc_insertion_point(field_get:proto.InitialSecurityNotificationSettingSync.securityNotificationEnabled)
  return _internal_securitynotificationenabled();
}
inline void InitialSecurityNotificationSettingSync::_internal_set_securitynotificationenabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.securitynotificationenabled_ = value;
}
inline void InitialSecurityNotificationSettingSync::set_securitynotificationenabled(bool value) {
  _internal_set_securitynotificationenabled(value);
  // @@protoc_insertion_point(field_set:proto.InitialSecurityNotificationSettingSync.securityNotificationEnabled)
}

// -------------------------------------------------------------------

// ContactsArrayMessage

// optional string displayName = 1;
inline bool ContactsArrayMessage::_internal_has_displayname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContactsArrayMessage::has_displayname() const {
  return _internal_has_displayname();
}
inline void ContactsArrayMessage::clear_displayname() {
  _impl_.displayname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContactsArrayMessage::displayname() const {
  // @@protoc_insertion_point(field_get:proto.ContactsArrayMessage.displayName)
  return _internal_displayname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContactsArrayMessage::set_displayname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.displayname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ContactsArrayMessage.displayName)
}
inline std::string* ContactsArrayMessage::mutable_displayname() {
  std::string* _s = _internal_mutable_displayname();
  // @@protoc_insertion_point(field_mutable:proto.ContactsArrayMessage.displayName)
  return _s;
}
inline const std::string& ContactsArrayMessage::_internal_displayname() const {
  return _impl_.displayname_.Get();
}
inline void ContactsArrayMessage::_internal_set_displayname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.displayname_.Set(value, GetArenaForAllocation());
}
inline std::string* ContactsArrayMessage::_internal_mutable_displayname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.displayname_.Mutable(GetArenaForAllocation());
}
inline std::string* ContactsArrayMessage::release_displayname() {
  // @@protoc_insertion_point(field_release:proto.ContactsArrayMessage.displayName)
  if (!_internal_has_displayname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.displayname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displayname_.IsDefault()) {
    _impl_.displayname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContactsArrayMessage::set_allocated_displayname(std::string* displayname) {
  if (displayname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.displayname_.SetAllocated(displayname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displayname_.IsDefault()) {
    _impl_.displayname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ContactsArrayMessage.displayName)
}

// repeated .proto.ContactMessage contacts = 2;
inline int ContactsArrayMessage::_internal_contacts_size() const {
  return _impl_.contacts_.size();
}
inline int ContactsArrayMessage::contacts_size() const {
  return _internal_contacts_size();
}
inline void ContactsArrayMessage::clear_contacts() {
  _impl_.contacts_.Clear();
}
inline ::proto::ContactMessage* ContactsArrayMessage::mutable_contacts(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ContactsArrayMessage.contacts)
  return _impl_.contacts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ContactMessage >*
ContactsArrayMessage::mutable_contacts() {
  // @@protoc_insertion_point(field_mutable_list:proto.ContactsArrayMessage.contacts)
  return &_impl_.contacts_;
}
inline const ::proto::ContactMessage& ContactsArrayMessage::_internal_contacts(int index) const {
  return _impl_.contacts_.Get(index);
}
inline const ::proto::ContactMessage& ContactsArrayMessage::contacts(int index) const {
  // @@protoc_insertion_point(field_get:proto.ContactsArrayMessage.contacts)
  return _internal_contacts(index);
}
inline ::proto::ContactMessage* ContactsArrayMessage::_internal_add_contacts() {
  return _impl_.contacts_.Add();
}
inline ::proto::ContactMessage* ContactsArrayMessage::add_contacts() {
  ::proto::ContactMessage* _add = _internal_add_contacts();
  // @@protoc_insertion_point(field_add:proto.ContactsArrayMessage.contacts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ContactMessage >&
ContactsArrayMessage::contacts() const {
  // @@protoc_insertion_point(field_list:proto.ContactsArrayMessage.contacts)
  return _impl_.contacts_;
}

// optional .proto.ContextInfo contextInfo = 17;
inline bool ContactsArrayMessage::_internal_has_contextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contextinfo_ != nullptr);
  return value;
}
inline bool ContactsArrayMessage::has_contextinfo() const {
  return _internal_has_contextinfo();
}
inline void ContactsArrayMessage::clear_contextinfo() {
  if (_impl_.contextinfo_ != nullptr) _impl_.contextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::ContextInfo& ContactsArrayMessage::_internal_contextinfo() const {
  const ::proto::ContextInfo* p = _impl_.contextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContextInfo&>(
      ::proto::_ContextInfo_default_instance_);
}
inline const ::proto::ContextInfo& ContactsArrayMessage::contextinfo() const {
  // @@protoc_insertion_point(field_get:proto.ContactsArrayMessage.contextInfo)
  return _internal_contextinfo();
}
inline void ContactsArrayMessage::unsafe_arena_set_allocated_contextinfo(
    ::proto::ContextInfo* contextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextinfo_);
  }
  _impl_.contextinfo_ = contextinfo;
  if (contextinfo) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ContactsArrayMessage.contextInfo)
}
inline ::proto::ContextInfo* ContactsArrayMessage::release_contextinfo() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContextInfo* ContactsArrayMessage::unsafe_arena_release_contextinfo() {
  // @@protoc_insertion_point(field_release:proto.ContactsArrayMessage.contextInfo)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
  return temp;
}
inline ::proto::ContextInfo* ContactsArrayMessage::_internal_mutable_contextinfo() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.contextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContextInfo>(GetArenaForAllocation());
    _impl_.contextinfo_ = p;
  }
  return _impl_.contextinfo_;
}
inline ::proto::ContextInfo* ContactsArrayMessage::mutable_contextinfo() {
  ::proto::ContextInfo* _msg = _internal_mutable_contextinfo();
  // @@protoc_insertion_point(field_mutable:proto.ContactsArrayMessage.contextInfo)
  return _msg;
}
inline void ContactsArrayMessage::set_allocated_contextinfo(::proto::ContextInfo* contextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contextinfo_;
  }
  if (contextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contextinfo);
    if (message_arena != submessage_arena) {
      contextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.contextinfo_ = contextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.ContactsArrayMessage.contextInfo)
}

// -------------------------------------------------------------------

// HSMCurrency

// optional string currencyCode = 1;
inline bool HSMCurrency::_internal_has_currencycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HSMCurrency::has_currencycode() const {
  return _internal_has_currencycode();
}
inline void HSMCurrency::clear_currencycode() {
  _impl_.currencycode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HSMCurrency::currencycode() const {
  // @@protoc_insertion_point(field_get:proto.HSMCurrency.currencyCode)
  return _internal_currencycode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HSMCurrency::set_currencycode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.currencycode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HSMCurrency.currencyCode)
}
inline std::string* HSMCurrency::mutable_currencycode() {
  std::string* _s = _internal_mutable_currencycode();
  // @@protoc_insertion_point(field_mutable:proto.HSMCurrency.currencyCode)
  return _s;
}
inline const std::string& HSMCurrency::_internal_currencycode() const {
  return _impl_.currencycode_.Get();
}
inline void HSMCurrency::_internal_set_currencycode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.currencycode_.Set(value, GetArenaForAllocation());
}
inline std::string* HSMCurrency::_internal_mutable_currencycode() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.currencycode_.Mutable(GetArenaForAllocation());
}
inline std::string* HSMCurrency::release_currencycode() {
  // @@protoc_insertion_point(field_release:proto.HSMCurrency.currencyCode)
  if (!_internal_has_currencycode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.currencycode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currencycode_.IsDefault()) {
    _impl_.currencycode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HSMCurrency::set_allocated_currencycode(std::string* currencycode) {
  if (currencycode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.currencycode_.SetAllocated(currencycode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currencycode_.IsDefault()) {
    _impl_.currencycode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HSMCurrency.currencyCode)
}

// optional int64 amount1000 = 2;
inline bool HSMCurrency::_internal_has_amount1000() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HSMCurrency::has_amount1000() const {
  return _internal_has_amount1000();
}
inline void HSMCurrency::clear_amount1000() {
  _impl_.amount1000_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t HSMCurrency::_internal_amount1000() const {
  return _impl_.amount1000_;
}
inline int64_t HSMCurrency::amount1000() const {
  // @@protoc_insertion_point(field_get:proto.HSMCurrency.amount1000)
  return _internal_amount1000();
}
inline void HSMCurrency::_internal_set_amount1000(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.amount1000_ = value;
}
inline void HSMCurrency::set_amount1000(int64_t value) {
  _internal_set_amount1000(value);
  // @@protoc_insertion_point(field_set:proto.HSMCurrency.amount1000)
}

// -------------------------------------------------------------------

// HSMDateTimeComponent

// optional .proto.HSMDateTimeComponent.HSMDateTimeComponentDayOfWeekType dayOfWeek = 1;
inline bool HSMDateTimeComponent::_internal_has_dayofweek() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool HSMDateTimeComponent::has_dayofweek() const {
  return _internal_has_dayofweek();
}
inline void HSMDateTimeComponent::clear_dayofweek() {
  _impl_.dayofweek_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::proto::HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType HSMDateTimeComponent::_internal_dayofweek() const {
  return static_cast< ::proto::HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType >(_impl_.dayofweek_);
}
inline ::proto::HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType HSMDateTimeComponent::dayofweek() const {
  // @@protoc_insertion_point(field_get:proto.HSMDateTimeComponent.dayOfWeek)
  return _internal_dayofweek();
}
inline void HSMDateTimeComponent::_internal_set_dayofweek(::proto::HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType value) {
  assert(::proto::HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.dayofweek_ = value;
}
inline void HSMDateTimeComponent::set_dayofweek(::proto::HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType value) {
  _internal_set_dayofweek(value);
  // @@protoc_insertion_point(field_set:proto.HSMDateTimeComponent.dayOfWeek)
}

// optional uint32 year = 2;
inline bool HSMDateTimeComponent::_internal_has_year() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HSMDateTimeComponent::has_year() const {
  return _internal_has_year();
}
inline void HSMDateTimeComponent::clear_year() {
  _impl_.year_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t HSMDateTimeComponent::_internal_year() const {
  return _impl_.year_;
}
inline uint32_t HSMDateTimeComponent::year() const {
  // @@protoc_insertion_point(field_get:proto.HSMDateTimeComponent.year)
  return _internal_year();
}
inline void HSMDateTimeComponent::_internal_set_year(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.year_ = value;
}
inline void HSMDateTimeComponent::set_year(uint32_t value) {
  _internal_set_year(value);
  // @@protoc_insertion_point(field_set:proto.HSMDateTimeComponent.year)
}

// optional uint32 month = 3;
inline bool HSMDateTimeComponent::_internal_has_month() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HSMDateTimeComponent::has_month() const {
  return _internal_has_month();
}
inline void HSMDateTimeComponent::clear_month() {
  _impl_.month_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t HSMDateTimeComponent::_internal_month() const {
  return _impl_.month_;
}
inline uint32_t HSMDateTimeComponent::month() const {
  // @@protoc_insertion_point(field_get:proto.HSMDateTimeComponent.month)
  return _internal_month();
}
inline void HSMDateTimeComponent::_internal_set_month(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.month_ = value;
}
inline void HSMDateTimeComponent::set_month(uint32_t value) {
  _internal_set_month(value);
  // @@protoc_insertion_point(field_set:proto.HSMDateTimeComponent.month)
}

// optional uint32 dayOfMonth = 4;
inline bool HSMDateTimeComponent::_internal_has_dayofmonth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HSMDateTimeComponent::has_dayofmonth() const {
  return _internal_has_dayofmonth();
}
inline void HSMDateTimeComponent::clear_dayofmonth() {
  _impl_.dayofmonth_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t HSMDateTimeComponent::_internal_dayofmonth() const {
  return _impl_.dayofmonth_;
}
inline uint32_t HSMDateTimeComponent::dayofmonth() const {
  // @@protoc_insertion_point(field_get:proto.HSMDateTimeComponent.dayOfMonth)
  return _internal_dayofmonth();
}
inline void HSMDateTimeComponent::_internal_set_dayofmonth(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.dayofmonth_ = value;
}
inline void HSMDateTimeComponent::set_dayofmonth(uint32_t value) {
  _internal_set_dayofmonth(value);
  // @@protoc_insertion_point(field_set:proto.HSMDateTimeComponent.dayOfMonth)
}

// optional uint32 hour = 5;
inline bool HSMDateTimeComponent::_internal_has_hour() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool HSMDateTimeComponent::has_hour() const {
  return _internal_has_hour();
}
inline void HSMDateTimeComponent::clear_hour() {
  _impl_.hour_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t HSMDateTimeComponent::_internal_hour() const {
  return _impl_.hour_;
}
inline uint32_t HSMDateTimeComponent::hour() const {
  // @@protoc_insertion_point(field_get:proto.HSMDateTimeComponent.hour)
  return _internal_hour();
}
inline void HSMDateTimeComponent::_internal_set_hour(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.hour_ = value;
}
inline void HSMDateTimeComponent::set_hour(uint32_t value) {
  _internal_set_hour(value);
  // @@protoc_insertion_point(field_set:proto.HSMDateTimeComponent.hour)
}

// optional uint32 minute = 6;
inline bool HSMDateTimeComponent::_internal_has_minute() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool HSMDateTimeComponent::has_minute() const {
  return _internal_has_minute();
}
inline void HSMDateTimeComponent::clear_minute() {
  _impl_.minute_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t HSMDateTimeComponent::_internal_minute() const {
  return _impl_.minute_;
}
inline uint32_t HSMDateTimeComponent::minute() const {
  // @@protoc_insertion_point(field_get:proto.HSMDateTimeComponent.minute)
  return _internal_minute();
}
inline void HSMDateTimeComponent::_internal_set_minute(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.minute_ = value;
}
inline void HSMDateTimeComponent::set_minute(uint32_t value) {
  _internal_set_minute(value);
  // @@protoc_insertion_point(field_set:proto.HSMDateTimeComponent.minute)
}

// optional .proto.HSMDateTimeComponent.HSMDateTimeComponentCalendarType calendar = 7;
inline bool HSMDateTimeComponent::_internal_has_calendar() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool HSMDateTimeComponent::has_calendar() const {
  return _internal_has_calendar();
}
inline void HSMDateTimeComponent::clear_calendar() {
  _impl_.calendar_ = 1;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::proto::HSMDateTimeComponent_HSMDateTimeComponentCalendarType HSMDateTimeComponent::_internal_calendar() const {
  return static_cast< ::proto::HSMDateTimeComponent_HSMDateTimeComponentCalendarType >(_impl_.calendar_);
}
inline ::proto::HSMDateTimeComponent_HSMDateTimeComponentCalendarType HSMDateTimeComponent::calendar() const {
  // @@protoc_insertion_point(field_get:proto.HSMDateTimeComponent.calendar)
  return _internal_calendar();
}
inline void HSMDateTimeComponent::_internal_set_calendar(::proto::HSMDateTimeComponent_HSMDateTimeComponentCalendarType value) {
  assert(::proto::HSMDateTimeComponent_HSMDateTimeComponentCalendarType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.calendar_ = value;
}
inline void HSMDateTimeComponent::set_calendar(::proto::HSMDateTimeComponent_HSMDateTimeComponentCalendarType value) {
  _internal_set_calendar(value);
  // @@protoc_insertion_point(field_set:proto.HSMDateTimeComponent.calendar)
}

// -------------------------------------------------------------------

// HSMDateTimeUnixEpoch

// optional int64 timestamp = 1;
inline bool HSMDateTimeUnixEpoch::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HSMDateTimeUnixEpoch::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void HSMDateTimeUnixEpoch::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t HSMDateTimeUnixEpoch::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t HSMDateTimeUnixEpoch::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.HSMDateTimeUnixEpoch.timestamp)
  return _internal_timestamp();
}
inline void HSMDateTimeUnixEpoch::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ = value;
}
inline void HSMDateTimeUnixEpoch::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:proto.HSMDateTimeUnixEpoch.timestamp)
}

// -------------------------------------------------------------------

// HSMDateTime

// .proto.HSMDateTimeComponent component = 1;
inline bool HSMDateTime::_internal_has_component() const {
  return datetimeOneof_case() == kComponent;
}
inline bool HSMDateTime::has_component() const {
  return _internal_has_component();
}
inline void HSMDateTime::set_has_component() {
  _impl_._oneof_case_[0] = kComponent;
}
inline void HSMDateTime::clear_component() {
  if (_internal_has_component()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.datetimeOneof_.component_;
    }
    clear_has_datetimeOneof();
  }
}
inline ::proto::HSMDateTimeComponent* HSMDateTime::release_component() {
  // @@protoc_insertion_point(field_release:proto.HSMDateTime.component)
  if (_internal_has_component()) {
    clear_has_datetimeOneof();
    ::proto::HSMDateTimeComponent* temp = _impl_.datetimeOneof_.component_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.datetimeOneof_.component_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::HSMDateTimeComponent& HSMDateTime::_internal_component() const {
  return _internal_has_component()
      ? *_impl_.datetimeOneof_.component_
      : reinterpret_cast< ::proto::HSMDateTimeComponent&>(::proto::_HSMDateTimeComponent_default_instance_);
}
inline const ::proto::HSMDateTimeComponent& HSMDateTime::component() const {
  // @@protoc_insertion_point(field_get:proto.HSMDateTime.component)
  return _internal_component();
}
inline ::proto::HSMDateTimeComponent* HSMDateTime::unsafe_arena_release_component() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.HSMDateTime.component)
  if (_internal_has_component()) {
    clear_has_datetimeOneof();
    ::proto::HSMDateTimeComponent* temp = _impl_.datetimeOneof_.component_;
    _impl_.datetimeOneof_.component_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HSMDateTime::unsafe_arena_set_allocated_component(::proto::HSMDateTimeComponent* component) {
  clear_datetimeOneof();
  if (component) {
    set_has_component();
    _impl_.datetimeOneof_.component_ = component;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HSMDateTime.component)
}
inline ::proto::HSMDateTimeComponent* HSMDateTime::_internal_mutable_component() {
  if (!_internal_has_component()) {
    clear_datetimeOneof();
    set_has_component();
    _impl_.datetimeOneof_.component_ = CreateMaybeMessage< ::proto::HSMDateTimeComponent >(GetArenaForAllocation());
  }
  return _impl_.datetimeOneof_.component_;
}
inline ::proto::HSMDateTimeComponent* HSMDateTime::mutable_component() {
  ::proto::HSMDateTimeComponent* _msg = _internal_mutable_component();
  // @@protoc_insertion_point(field_mutable:proto.HSMDateTime.component)
  return _msg;
}

// .proto.HSMDateTimeUnixEpoch unixEpoch = 2;
inline bool HSMDateTime::_internal_has_unixepoch() const {
  return datetimeOneof_case() == kUnixEpoch;
}
inline bool HSMDateTime::has_unixepoch() const {
  return _internal_has_unixepoch();
}
inline void HSMDateTime::set_has_unixepoch() {
  _impl_._oneof_case_[0] = kUnixEpoch;
}
inline void HSMDateTime::clear_unixepoch() {
  if (_internal_has_unixepoch()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.datetimeOneof_.unixepoch_;
    }
    clear_has_datetimeOneof();
  }
}
inline ::proto::HSMDateTimeUnixEpoch* HSMDateTime::release_unixepoch() {
  // @@protoc_insertion_point(field_release:proto.HSMDateTime.unixEpoch)
  if (_internal_has_unixepoch()) {
    clear_has_datetimeOneof();
    ::proto::HSMDateTimeUnixEpoch* temp = _impl_.datetimeOneof_.unixepoch_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.datetimeOneof_.unixepoch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::HSMDateTimeUnixEpoch& HSMDateTime::_internal_unixepoch() const {
  return _internal_has_unixepoch()
      ? *_impl_.datetimeOneof_.unixepoch_
      : reinterpret_cast< ::proto::HSMDateTimeUnixEpoch&>(::proto::_HSMDateTimeUnixEpoch_default_instance_);
}
inline const ::proto::HSMDateTimeUnixEpoch& HSMDateTime::unixepoch() const {
  // @@protoc_insertion_point(field_get:proto.HSMDateTime.unixEpoch)
  return _internal_unixepoch();
}
inline ::proto::HSMDateTimeUnixEpoch* HSMDateTime::unsafe_arena_release_unixepoch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.HSMDateTime.unixEpoch)
  if (_internal_has_unixepoch()) {
    clear_has_datetimeOneof();
    ::proto::HSMDateTimeUnixEpoch* temp = _impl_.datetimeOneof_.unixepoch_;
    _impl_.datetimeOneof_.unixepoch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HSMDateTime::unsafe_arena_set_allocated_unixepoch(::proto::HSMDateTimeUnixEpoch* unixepoch) {
  clear_datetimeOneof();
  if (unixepoch) {
    set_has_unixepoch();
    _impl_.datetimeOneof_.unixepoch_ = unixepoch;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HSMDateTime.unixEpoch)
}
inline ::proto::HSMDateTimeUnixEpoch* HSMDateTime::_internal_mutable_unixepoch() {
  if (!_internal_has_unixepoch()) {
    clear_datetimeOneof();
    set_has_unixepoch();
    _impl_.datetimeOneof_.unixepoch_ = CreateMaybeMessage< ::proto::HSMDateTimeUnixEpoch >(GetArenaForAllocation());
  }
  return _impl_.datetimeOneof_.unixepoch_;
}
inline ::proto::HSMDateTimeUnixEpoch* HSMDateTime::mutable_unixepoch() {
  ::proto::HSMDateTimeUnixEpoch* _msg = _internal_mutable_unixepoch();
  // @@protoc_insertion_point(field_mutable:proto.HSMDateTime.unixEpoch)
  return _msg;
}

inline bool HSMDateTime::has_datetimeOneof() const {
  return datetimeOneof_case() != DATETIMEONEOF_NOT_SET;
}
inline void HSMDateTime::clear_has_datetimeOneof() {
  _impl_._oneof_case_[0] = DATETIMEONEOF_NOT_SET;
}
inline HSMDateTime::DatetimeOneofCase HSMDateTime::datetimeOneof_case() const {
  return HSMDateTime::DatetimeOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// HSMLocalizableParameter

// optional string default = 1;
inline bool HSMLocalizableParameter::_internal_has_default_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HSMLocalizableParameter::has_default_() const {
  return _internal_has_default_();
}
inline void HSMLocalizableParameter::clear_default_() {
  _impl_.default__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HSMLocalizableParameter::default_() const {
  // @@protoc_insertion_point(field_get:proto.HSMLocalizableParameter.default)
  return _internal_default_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HSMLocalizableParameter::set_default_(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.default__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HSMLocalizableParameter.default)
}
inline std::string* HSMLocalizableParameter::mutable_default_() {
  std::string* _s = _internal_mutable_default_();
  // @@protoc_insertion_point(field_mutable:proto.HSMLocalizableParameter.default)
  return _s;
}
inline const std::string& HSMLocalizableParameter::_internal_default_() const {
  return _impl_.default__.Get();
}
inline void HSMLocalizableParameter::_internal_set_default_(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.default__.Set(value, GetArenaForAllocation());
}
inline std::string* HSMLocalizableParameter::_internal_mutable_default_() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.default__.Mutable(GetArenaForAllocation());
}
inline std::string* HSMLocalizableParameter::release_default_() {
  // @@protoc_insertion_point(field_release:proto.HSMLocalizableParameter.default)
  if (!_internal_has_default_()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.default__.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.default__.IsDefault()) {
    _impl_.default__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HSMLocalizableParameter::set_allocated_default_(std::string* default_) {
  if (default_ != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.default__.SetAllocated(default_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.default__.IsDefault()) {
    _impl_.default__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HSMLocalizableParameter.default)
}

// .proto.HSMCurrency currency = 2;
inline bool HSMLocalizableParameter::_internal_has_currency() const {
  return paramOneof_case() == kCurrency;
}
inline bool HSMLocalizableParameter::has_currency() const {
  return _internal_has_currency();
}
inline void HSMLocalizableParameter::set_has_currency() {
  _impl_._oneof_case_[0] = kCurrency;
}
inline void HSMLocalizableParameter::clear_currency() {
  if (_internal_has_currency()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.paramOneof_.currency_;
    }
    clear_has_paramOneof();
  }
}
inline ::proto::HSMCurrency* HSMLocalizableParameter::release_currency() {
  // @@protoc_insertion_point(field_release:proto.HSMLocalizableParameter.currency)
  if (_internal_has_currency()) {
    clear_has_paramOneof();
    ::proto::HSMCurrency* temp = _impl_.paramOneof_.currency_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.paramOneof_.currency_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::HSMCurrency& HSMLocalizableParameter::_internal_currency() const {
  return _internal_has_currency()
      ? *_impl_.paramOneof_.currency_
      : reinterpret_cast< ::proto::HSMCurrency&>(::proto::_HSMCurrency_default_instance_);
}
inline const ::proto::HSMCurrency& HSMLocalizableParameter::currency() const {
  // @@protoc_insertion_point(field_get:proto.HSMLocalizableParameter.currency)
  return _internal_currency();
}
inline ::proto::HSMCurrency* HSMLocalizableParameter::unsafe_arena_release_currency() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.HSMLocalizableParameter.currency)
  if (_internal_has_currency()) {
    clear_has_paramOneof();
    ::proto::HSMCurrency* temp = _impl_.paramOneof_.currency_;
    _impl_.paramOneof_.currency_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HSMLocalizableParameter::unsafe_arena_set_allocated_currency(::proto::HSMCurrency* currency) {
  clear_paramOneof();
  if (currency) {
    set_has_currency();
    _impl_.paramOneof_.currency_ = currency;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HSMLocalizableParameter.currency)
}
inline ::proto::HSMCurrency* HSMLocalizableParameter::_internal_mutable_currency() {
  if (!_internal_has_currency()) {
    clear_paramOneof();
    set_has_currency();
    _impl_.paramOneof_.currency_ = CreateMaybeMessage< ::proto::HSMCurrency >(GetArenaForAllocation());
  }
  return _impl_.paramOneof_.currency_;
}
inline ::proto::HSMCurrency* HSMLocalizableParameter::mutable_currency() {
  ::proto::HSMCurrency* _msg = _internal_mutable_currency();
  // @@protoc_insertion_point(field_mutable:proto.HSMLocalizableParameter.currency)
  return _msg;
}

// .proto.HSMDateTime dateTime = 3;
inline bool HSMLocalizableParameter::_internal_has_datetime() const {
  return paramOneof_case() == kDateTime;
}
inline bool HSMLocalizableParameter::has_datetime() const {
  return _internal_has_datetime();
}
inline void HSMLocalizableParameter::set_has_datetime() {
  _impl_._oneof_case_[0] = kDateTime;
}
inline void HSMLocalizableParameter::clear_datetime() {
  if (_internal_has_datetime()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.paramOneof_.datetime_;
    }
    clear_has_paramOneof();
  }
}
inline ::proto::HSMDateTime* HSMLocalizableParameter::release_datetime() {
  // @@protoc_insertion_point(field_release:proto.HSMLocalizableParameter.dateTime)
  if (_internal_has_datetime()) {
    clear_has_paramOneof();
    ::proto::HSMDateTime* temp = _impl_.paramOneof_.datetime_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.paramOneof_.datetime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::HSMDateTime& HSMLocalizableParameter::_internal_datetime() const {
  return _internal_has_datetime()
      ? *_impl_.paramOneof_.datetime_
      : reinterpret_cast< ::proto::HSMDateTime&>(::proto::_HSMDateTime_default_instance_);
}
inline const ::proto::HSMDateTime& HSMLocalizableParameter::datetime() const {
  // @@protoc_insertion_point(field_get:proto.HSMLocalizableParameter.dateTime)
  return _internal_datetime();
}
inline ::proto::HSMDateTime* HSMLocalizableParameter::unsafe_arena_release_datetime() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.HSMLocalizableParameter.dateTime)
  if (_internal_has_datetime()) {
    clear_has_paramOneof();
    ::proto::HSMDateTime* temp = _impl_.paramOneof_.datetime_;
    _impl_.paramOneof_.datetime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HSMLocalizableParameter::unsafe_arena_set_allocated_datetime(::proto::HSMDateTime* datetime) {
  clear_paramOneof();
  if (datetime) {
    set_has_datetime();
    _impl_.paramOneof_.datetime_ = datetime;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HSMLocalizableParameter.dateTime)
}
inline ::proto::HSMDateTime* HSMLocalizableParameter::_internal_mutable_datetime() {
  if (!_internal_has_datetime()) {
    clear_paramOneof();
    set_has_datetime();
    _impl_.paramOneof_.datetime_ = CreateMaybeMessage< ::proto::HSMDateTime >(GetArenaForAllocation());
  }
  return _impl_.paramOneof_.datetime_;
}
inline ::proto::HSMDateTime* HSMLocalizableParameter::mutable_datetime() {
  ::proto::HSMDateTime* _msg = _internal_mutable_datetime();
  // @@protoc_insertion_point(field_mutable:proto.HSMLocalizableParameter.dateTime)
  return _msg;
}

inline bool HSMLocalizableParameter::has_paramOneof() const {
  return paramOneof_case() != PARAMONEOF_NOT_SET;
}
inline void HSMLocalizableParameter::clear_has_paramOneof() {
  _impl_._oneof_case_[0] = PARAMONEOF_NOT_SET;
}
inline HSMLocalizableParameter::ParamOneofCase HSMLocalizableParameter::paramOneof_case() const {
  return HSMLocalizableParameter::ParamOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// HighlyStructuredMessage

// optional string namespace = 1;
inline bool HighlyStructuredMessage::_internal_has_namespace_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HighlyStructuredMessage::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void HighlyStructuredMessage::clear_namespace_() {
  _impl_.namespace__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HighlyStructuredMessage::namespace_() const {
  // @@protoc_insertion_point(field_get:proto.HighlyStructuredMessage.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HighlyStructuredMessage::set_namespace_(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.namespace__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HighlyStructuredMessage.namespace)
}
inline std::string* HighlyStructuredMessage::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:proto.HighlyStructuredMessage.namespace)
  return _s;
}
inline const std::string& HighlyStructuredMessage::_internal_namespace_() const {
  return _impl_.namespace__.Get();
}
inline void HighlyStructuredMessage::_internal_set_namespace_(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.namespace__.Set(value, GetArenaForAllocation());
}
inline std::string* HighlyStructuredMessage::_internal_mutable_namespace_() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.namespace__.Mutable(GetArenaForAllocation());
}
inline std::string* HighlyStructuredMessage::release_namespace_() {
  // @@protoc_insertion_point(field_release:proto.HighlyStructuredMessage.namespace)
  if (!_internal_has_namespace_()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.namespace__.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HighlyStructuredMessage::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.namespace__.SetAllocated(namespace_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HighlyStructuredMessage.namespace)
}

// optional string elementName = 2;
inline bool HighlyStructuredMessage::_internal_has_elementname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HighlyStructuredMessage::has_elementname() const {
  return _internal_has_elementname();
}
inline void HighlyStructuredMessage::clear_elementname() {
  _impl_.elementname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HighlyStructuredMessage::elementname() const {
  // @@protoc_insertion_point(field_get:proto.HighlyStructuredMessage.elementName)
  return _internal_elementname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HighlyStructuredMessage::set_elementname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.elementname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HighlyStructuredMessage.elementName)
}
inline std::string* HighlyStructuredMessage::mutable_elementname() {
  std::string* _s = _internal_mutable_elementname();
  // @@protoc_insertion_point(field_mutable:proto.HighlyStructuredMessage.elementName)
  return _s;
}
inline const std::string& HighlyStructuredMessage::_internal_elementname() const {
  return _impl_.elementname_.Get();
}
inline void HighlyStructuredMessage::_internal_set_elementname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.elementname_.Set(value, GetArenaForAllocation());
}
inline std::string* HighlyStructuredMessage::_internal_mutable_elementname() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.elementname_.Mutable(GetArenaForAllocation());
}
inline std::string* HighlyStructuredMessage::release_elementname() {
  // @@protoc_insertion_point(field_release:proto.HighlyStructuredMessage.elementName)
  if (!_internal_has_elementname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.elementname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.elementname_.IsDefault()) {
    _impl_.elementname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HighlyStructuredMessage::set_allocated_elementname(std::string* elementname) {
  if (elementname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.elementname_.SetAllocated(elementname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.elementname_.IsDefault()) {
    _impl_.elementname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HighlyStructuredMessage.elementName)
}

// repeated string params = 3;
inline int HighlyStructuredMessage::_internal_params_size() const {
  return _impl_.params_.size();
}
inline int HighlyStructuredMessage::params_size() const {
  return _internal_params_size();
}
inline void HighlyStructuredMessage::clear_params() {
  _impl_.params_.Clear();
}
inline std::string* HighlyStructuredMessage::add_params() {
  std::string* _s = _internal_add_params();
  // @@protoc_insertion_point(field_add_mutable:proto.HighlyStructuredMessage.params)
  return _s;
}
inline const std::string& HighlyStructuredMessage::_internal_params(int index) const {
  return _impl_.params_.Get(index);
}
inline const std::string& HighlyStructuredMessage::params(int index) const {
  // @@protoc_insertion_point(field_get:proto.HighlyStructuredMessage.params)
  return _internal_params(index);
}
inline std::string* HighlyStructuredMessage::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:proto.HighlyStructuredMessage.params)
  return _impl_.params_.Mutable(index);
}
inline void HighlyStructuredMessage::set_params(int index, const std::string& value) {
  _impl_.params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.HighlyStructuredMessage.params)
}
inline void HighlyStructuredMessage::set_params(int index, std::string&& value) {
  _impl_.params_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.HighlyStructuredMessage.params)
}
inline void HighlyStructuredMessage::set_params(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.HighlyStructuredMessage.params)
}
inline void HighlyStructuredMessage::set_params(int index, const char* value, size_t size) {
  _impl_.params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.HighlyStructuredMessage.params)
}
inline std::string* HighlyStructuredMessage::_internal_add_params() {
  return _impl_.params_.Add();
}
inline void HighlyStructuredMessage::add_params(const std::string& value) {
  _impl_.params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.HighlyStructuredMessage.params)
}
inline void HighlyStructuredMessage::add_params(std::string&& value) {
  _impl_.params_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.HighlyStructuredMessage.params)
}
inline void HighlyStructuredMessage::add_params(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.HighlyStructuredMessage.params)
}
inline void HighlyStructuredMessage::add_params(const char* value, size_t size) {
  _impl_.params_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.HighlyStructuredMessage.params)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HighlyStructuredMessage::params() const {
  // @@protoc_insertion_point(field_list:proto.HighlyStructuredMessage.params)
  return _impl_.params_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HighlyStructuredMessage::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:proto.HighlyStructuredMessage.params)
  return &_impl_.params_;
}

// optional string fallbackLg = 4;
inline bool HighlyStructuredMessage::_internal_has_fallbacklg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HighlyStructuredMessage::has_fallbacklg() const {
  return _internal_has_fallbacklg();
}
inline void HighlyStructuredMessage::clear_fallbacklg() {
  _impl_.fallbacklg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& HighlyStructuredMessage::fallbacklg() const {
  // @@protoc_insertion_point(field_get:proto.HighlyStructuredMessage.fallbackLg)
  return _internal_fallbacklg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HighlyStructuredMessage::set_fallbacklg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.fallbacklg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HighlyStructuredMessage.fallbackLg)
}
inline std::string* HighlyStructuredMessage::mutable_fallbacklg() {
  std::string* _s = _internal_mutable_fallbacklg();
  // @@protoc_insertion_point(field_mutable:proto.HighlyStructuredMessage.fallbackLg)
  return _s;
}
inline const std::string& HighlyStructuredMessage::_internal_fallbacklg() const {
  return _impl_.fallbacklg_.Get();
}
inline void HighlyStructuredMessage::_internal_set_fallbacklg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.fallbacklg_.Set(value, GetArenaForAllocation());
}
inline std::string* HighlyStructuredMessage::_internal_mutable_fallbacklg() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.fallbacklg_.Mutable(GetArenaForAllocation());
}
inline std::string* HighlyStructuredMessage::release_fallbacklg() {
  // @@protoc_insertion_point(field_release:proto.HighlyStructuredMessage.fallbackLg)
  if (!_internal_has_fallbacklg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.fallbacklg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fallbacklg_.IsDefault()) {
    _impl_.fallbacklg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HighlyStructuredMessage::set_allocated_fallbacklg(std::string* fallbacklg) {
  if (fallbacklg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.fallbacklg_.SetAllocated(fallbacklg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fallbacklg_.IsDefault()) {
    _impl_.fallbacklg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HighlyStructuredMessage.fallbackLg)
}

// optional string fallbackLc = 5;
inline bool HighlyStructuredMessage::_internal_has_fallbacklc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool HighlyStructuredMessage::has_fallbacklc() const {
  return _internal_has_fallbacklc();
}
inline void HighlyStructuredMessage::clear_fallbacklc() {
  _impl_.fallbacklc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& HighlyStructuredMessage::fallbacklc() const {
  // @@protoc_insertion_point(field_get:proto.HighlyStructuredMessage.fallbackLc)
  return _internal_fallbacklc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HighlyStructuredMessage::set_fallbacklc(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.fallbacklc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HighlyStructuredMessage.fallbackLc)
}
inline std::string* HighlyStructuredMessage::mutable_fallbacklc() {
  std::string* _s = _internal_mutable_fallbacklc();
  // @@protoc_insertion_point(field_mutable:proto.HighlyStructuredMessage.fallbackLc)
  return _s;
}
inline const std::string& HighlyStructuredMessage::_internal_fallbacklc() const {
  return _impl_.fallbacklc_.Get();
}
inline void HighlyStructuredMessage::_internal_set_fallbacklc(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.fallbacklc_.Set(value, GetArenaForAllocation());
}
inline std::string* HighlyStructuredMessage::_internal_mutable_fallbacklc() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.fallbacklc_.Mutable(GetArenaForAllocation());
}
inline std::string* HighlyStructuredMessage::release_fallbacklc() {
  // @@protoc_insertion_point(field_release:proto.HighlyStructuredMessage.fallbackLc)
  if (!_internal_has_fallbacklc()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.fallbacklc_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fallbacklc_.IsDefault()) {
    _impl_.fallbacklc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HighlyStructuredMessage::set_allocated_fallbacklc(std::string* fallbacklc) {
  if (fallbacklc != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.fallbacklc_.SetAllocated(fallbacklc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fallbacklc_.IsDefault()) {
    _impl_.fallbacklc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HighlyStructuredMessage.fallbackLc)
}

// repeated .proto.HSMLocalizableParameter localizableParams = 6;
inline int HighlyStructuredMessage::_internal_localizableparams_size() const {
  return _impl_.localizableparams_.size();
}
inline int HighlyStructuredMessage::localizableparams_size() const {
  return _internal_localizableparams_size();
}
inline void HighlyStructuredMessage::clear_localizableparams() {
  _impl_.localizableparams_.Clear();
}
inline ::proto::HSMLocalizableParameter* HighlyStructuredMessage::mutable_localizableparams(int index) {
  // @@protoc_insertion_point(field_mutable:proto.HighlyStructuredMessage.localizableParams)
  return _impl_.localizableparams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::HSMLocalizableParameter >*
HighlyStructuredMessage::mutable_localizableparams() {
  // @@protoc_insertion_point(field_mutable_list:proto.HighlyStructuredMessage.localizableParams)
  return &_impl_.localizableparams_;
}
inline const ::proto::HSMLocalizableParameter& HighlyStructuredMessage::_internal_localizableparams(int index) const {
  return _impl_.localizableparams_.Get(index);
}
inline const ::proto::HSMLocalizableParameter& HighlyStructuredMessage::localizableparams(int index) const {
  // @@protoc_insertion_point(field_get:proto.HighlyStructuredMessage.localizableParams)
  return _internal_localizableparams(index);
}
inline ::proto::HSMLocalizableParameter* HighlyStructuredMessage::_internal_add_localizableparams() {
  return _impl_.localizableparams_.Add();
}
inline ::proto::HSMLocalizableParameter* HighlyStructuredMessage::add_localizableparams() {
  ::proto::HSMLocalizableParameter* _add = _internal_add_localizableparams();
  // @@protoc_insertion_point(field_add:proto.HighlyStructuredMessage.localizableParams)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::HSMLocalizableParameter >&
HighlyStructuredMessage::localizableparams() const {
  // @@protoc_insertion_point(field_list:proto.HighlyStructuredMessage.localizableParams)
  return _impl_.localizableparams_;
}

// optional string deterministicLg = 7;
inline bool HighlyStructuredMessage::_internal_has_deterministiclg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool HighlyStructuredMessage::has_deterministiclg() const {
  return _internal_has_deterministiclg();
}
inline void HighlyStructuredMessage::clear_deterministiclg() {
  _impl_.deterministiclg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& HighlyStructuredMessage::deterministiclg() const {
  // @@protoc_insertion_point(field_get:proto.HighlyStructuredMessage.deterministicLg)
  return _internal_deterministiclg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HighlyStructuredMessage::set_deterministiclg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.deterministiclg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HighlyStructuredMessage.deterministicLg)
}
inline std::string* HighlyStructuredMessage::mutable_deterministiclg() {
  std::string* _s = _internal_mutable_deterministiclg();
  // @@protoc_insertion_point(field_mutable:proto.HighlyStructuredMessage.deterministicLg)
  return _s;
}
inline const std::string& HighlyStructuredMessage::_internal_deterministiclg() const {
  return _impl_.deterministiclg_.Get();
}
inline void HighlyStructuredMessage::_internal_set_deterministiclg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.deterministiclg_.Set(value, GetArenaForAllocation());
}
inline std::string* HighlyStructuredMessage::_internal_mutable_deterministiclg() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.deterministiclg_.Mutable(GetArenaForAllocation());
}
inline std::string* HighlyStructuredMessage::release_deterministiclg() {
  // @@protoc_insertion_point(field_release:proto.HighlyStructuredMessage.deterministicLg)
  if (!_internal_has_deterministiclg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.deterministiclg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deterministiclg_.IsDefault()) {
    _impl_.deterministiclg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HighlyStructuredMessage::set_allocated_deterministiclg(std::string* deterministiclg) {
  if (deterministiclg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.deterministiclg_.SetAllocated(deterministiclg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deterministiclg_.IsDefault()) {
    _impl_.deterministiclg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HighlyStructuredMessage.deterministicLg)
}

// optional string deterministicLc = 8;
inline bool HighlyStructuredMessage::_internal_has_deterministiclc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool HighlyStructuredMessage::has_deterministiclc() const {
  return _internal_has_deterministiclc();
}
inline void HighlyStructuredMessage::clear_deterministiclc() {
  _impl_.deterministiclc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& HighlyStructuredMessage::deterministiclc() const {
  // @@protoc_insertion_point(field_get:proto.HighlyStructuredMessage.deterministicLc)
  return _internal_deterministiclc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HighlyStructuredMessage::set_deterministiclc(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.deterministiclc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HighlyStructuredMessage.deterministicLc)
}
inline std::string* HighlyStructuredMessage::mutable_deterministiclc() {
  std::string* _s = _internal_mutable_deterministiclc();
  // @@protoc_insertion_point(field_mutable:proto.HighlyStructuredMessage.deterministicLc)
  return _s;
}
inline const std::string& HighlyStructuredMessage::_internal_deterministiclc() const {
  return _impl_.deterministiclc_.Get();
}
inline void HighlyStructuredMessage::_internal_set_deterministiclc(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.deterministiclc_.Set(value, GetArenaForAllocation());
}
inline std::string* HighlyStructuredMessage::_internal_mutable_deterministiclc() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.deterministiclc_.Mutable(GetArenaForAllocation());
}
inline std::string* HighlyStructuredMessage::release_deterministiclc() {
  // @@protoc_insertion_point(field_release:proto.HighlyStructuredMessage.deterministicLc)
  if (!_internal_has_deterministiclc()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.deterministiclc_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deterministiclc_.IsDefault()) {
    _impl_.deterministiclc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HighlyStructuredMessage::set_allocated_deterministiclc(std::string* deterministiclc) {
  if (deterministiclc != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.deterministiclc_.SetAllocated(deterministiclc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deterministiclc_.IsDefault()) {
    _impl_.deterministiclc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HighlyStructuredMessage.deterministicLc)
}

// optional .proto.TemplateMessage hydratedHsm = 9;
inline bool HighlyStructuredMessage::_internal_has_hydratedhsm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hydratedhsm_ != nullptr);
  return value;
}
inline bool HighlyStructuredMessage::has_hydratedhsm() const {
  return _internal_has_hydratedhsm();
}
inline void HighlyStructuredMessage::clear_hydratedhsm() {
  if (_impl_.hydratedhsm_ != nullptr) _impl_.hydratedhsm_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::proto::TemplateMessage& HighlyStructuredMessage::_internal_hydratedhsm() const {
  const ::proto::TemplateMessage* p = _impl_.hydratedhsm_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::TemplateMessage&>(
      ::proto::_TemplateMessage_default_instance_);
}
inline const ::proto::TemplateMessage& HighlyStructuredMessage::hydratedhsm() const {
  // @@protoc_insertion_point(field_get:proto.HighlyStructuredMessage.hydratedHsm)
  return _internal_hydratedhsm();
}
inline void HighlyStructuredMessage::unsafe_arena_set_allocated_hydratedhsm(
    ::proto::TemplateMessage* hydratedhsm) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hydratedhsm_);
  }
  _impl_.hydratedhsm_ = hydratedhsm;
  if (hydratedhsm) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HighlyStructuredMessage.hydratedHsm)
}
inline ::proto::TemplateMessage* HighlyStructuredMessage::release_hydratedhsm() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::proto::TemplateMessage* temp = _impl_.hydratedhsm_;
  _impl_.hydratedhsm_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::TemplateMessage* HighlyStructuredMessage::unsafe_arena_release_hydratedhsm() {
  // @@protoc_insertion_point(field_release:proto.HighlyStructuredMessage.hydratedHsm)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::proto::TemplateMessage* temp = _impl_.hydratedhsm_;
  _impl_.hydratedhsm_ = nullptr;
  return temp;
}
inline ::proto::TemplateMessage* HighlyStructuredMessage::_internal_mutable_hydratedhsm() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.hydratedhsm_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::TemplateMessage>(GetArenaForAllocation());
    _impl_.hydratedhsm_ = p;
  }
  return _impl_.hydratedhsm_;
}
inline ::proto::TemplateMessage* HighlyStructuredMessage::mutable_hydratedhsm() {
  ::proto::TemplateMessage* _msg = _internal_mutable_hydratedhsm();
  // @@protoc_insertion_point(field_mutable:proto.HighlyStructuredMessage.hydratedHsm)
  return _msg;
}
inline void HighlyStructuredMessage::set_allocated_hydratedhsm(::proto::TemplateMessage* hydratedhsm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hydratedhsm_;
  }
  if (hydratedhsm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hydratedhsm);
    if (message_arena != submessage_arena) {
      hydratedhsm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hydratedhsm, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.hydratedhsm_ = hydratedhsm;
  // @@protoc_insertion_point(field_set_allocated:proto.HighlyStructuredMessage.hydratedHsm)
}

// -------------------------------------------------------------------

// SendPaymentMessage

// optional .proto.Message noteMessage = 2;
inline bool SendPaymentMessage::_internal_has_notemessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.notemessage_ != nullptr);
  return value;
}
inline bool SendPaymentMessage::has_notemessage() const {
  return _internal_has_notemessage();
}
inline void SendPaymentMessage::clear_notemessage() {
  if (_impl_.notemessage_ != nullptr) _impl_.notemessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::Message& SendPaymentMessage::_internal_notemessage() const {
  const ::proto::Message* p = _impl_.notemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Message&>(
      ::proto::_Message_default_instance_);
}
inline const ::proto::Message& SendPaymentMessage::notemessage() const {
  // @@protoc_insertion_point(field_get:proto.SendPaymentMessage.noteMessage)
  return _internal_notemessage();
}
inline void SendPaymentMessage::unsafe_arena_set_allocated_notemessage(
    ::proto::Message* notemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.notemessage_);
  }
  _impl_.notemessage_ = notemessage;
  if (notemessage) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SendPaymentMessage.noteMessage)
}
inline ::proto::Message* SendPaymentMessage::release_notemessage() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::Message* temp = _impl_.notemessage_;
  _impl_.notemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Message* SendPaymentMessage::unsafe_arena_release_notemessage() {
  // @@protoc_insertion_point(field_release:proto.SendPaymentMessage.noteMessage)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::Message* temp = _impl_.notemessage_;
  _impl_.notemessage_ = nullptr;
  return temp;
}
inline ::proto::Message* SendPaymentMessage::_internal_mutable_notemessage() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.notemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Message>(GetArenaForAllocation());
    _impl_.notemessage_ = p;
  }
  return _impl_.notemessage_;
}
inline ::proto::Message* SendPaymentMessage::mutable_notemessage() {
  ::proto::Message* _msg = _internal_mutable_notemessage();
  // @@protoc_insertion_point(field_mutable:proto.SendPaymentMessage.noteMessage)
  return _msg;
}
inline void SendPaymentMessage::set_allocated_notemessage(::proto::Message* notemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.notemessage_;
  }
  if (notemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(notemessage);
    if (message_arena != submessage_arena) {
      notemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, notemessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.notemessage_ = notemessage;
  // @@protoc_insertion_point(field_set_allocated:proto.SendPaymentMessage.noteMessage)
}

// optional .proto.MessageKey requestMessageKey = 3;
inline bool SendPaymentMessage::_internal_has_requestmessagekey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.requestmessagekey_ != nullptr);
  return value;
}
inline bool SendPaymentMessage::has_requestmessagekey() const {
  return _internal_has_requestmessagekey();
}
inline void SendPaymentMessage::clear_requestmessagekey() {
  if (_impl_.requestmessagekey_ != nullptr) _impl_.requestmessagekey_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::MessageKey& SendPaymentMessage::_internal_requestmessagekey() const {
  const ::proto::MessageKey* p = _impl_.requestmessagekey_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::MessageKey&>(
      ::proto::_MessageKey_default_instance_);
}
inline const ::proto::MessageKey& SendPaymentMessage::requestmessagekey() const {
  // @@protoc_insertion_point(field_get:proto.SendPaymentMessage.requestMessageKey)
  return _internal_requestmessagekey();
}
inline void SendPaymentMessage::unsafe_arena_set_allocated_requestmessagekey(
    ::proto::MessageKey* requestmessagekey) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requestmessagekey_);
  }
  _impl_.requestmessagekey_ = requestmessagekey;
  if (requestmessagekey) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SendPaymentMessage.requestMessageKey)
}
inline ::proto::MessageKey* SendPaymentMessage::release_requestmessagekey() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::MessageKey* temp = _impl_.requestmessagekey_;
  _impl_.requestmessagekey_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::MessageKey* SendPaymentMessage::unsafe_arena_release_requestmessagekey() {
  // @@protoc_insertion_point(field_release:proto.SendPaymentMessage.requestMessageKey)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::MessageKey* temp = _impl_.requestmessagekey_;
  _impl_.requestmessagekey_ = nullptr;
  return temp;
}
inline ::proto::MessageKey* SendPaymentMessage::_internal_mutable_requestmessagekey() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.requestmessagekey_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::MessageKey>(GetArenaForAllocation());
    _impl_.requestmessagekey_ = p;
  }
  return _impl_.requestmessagekey_;
}
inline ::proto::MessageKey* SendPaymentMessage::mutable_requestmessagekey() {
  ::proto::MessageKey* _msg = _internal_mutable_requestmessagekey();
  // @@protoc_insertion_point(field_mutable:proto.SendPaymentMessage.requestMessageKey)
  return _msg;
}
inline void SendPaymentMessage::set_allocated_requestmessagekey(::proto::MessageKey* requestmessagekey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.requestmessagekey_;
  }
  if (requestmessagekey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(requestmessagekey);
    if (message_arena != submessage_arena) {
      requestmessagekey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, requestmessagekey, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.requestmessagekey_ = requestmessagekey;
  // @@protoc_insertion_point(field_set_allocated:proto.SendPaymentMessage.requestMessageKey)
}

// -------------------------------------------------------------------

// RequestPaymentMessage

// optional .proto.Message noteMessage = 4;
inline bool RequestPaymentMessage::_internal_has_notemessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.notemessage_ != nullptr);
  return value;
}
inline bool RequestPaymentMessage::has_notemessage() const {
  return _internal_has_notemessage();
}
inline void RequestPaymentMessage::clear_notemessage() {
  if (_impl_.notemessage_ != nullptr) _impl_.notemessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::proto::Message& RequestPaymentMessage::_internal_notemessage() const {
  const ::proto::Message* p = _impl_.notemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Message&>(
      ::proto::_Message_default_instance_);
}
inline const ::proto::Message& RequestPaymentMessage::notemessage() const {
  // @@protoc_insertion_point(field_get:proto.RequestPaymentMessage.noteMessage)
  return _internal_notemessage();
}
inline void RequestPaymentMessage::unsafe_arena_set_allocated_notemessage(
    ::proto::Message* notemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.notemessage_);
  }
  _impl_.notemessage_ = notemessage;
  if (notemessage) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RequestPaymentMessage.noteMessage)
}
inline ::proto::Message* RequestPaymentMessage::release_notemessage() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::Message* temp = _impl_.notemessage_;
  _impl_.notemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Message* RequestPaymentMessage::unsafe_arena_release_notemessage() {
  // @@protoc_insertion_point(field_release:proto.RequestPaymentMessage.noteMessage)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::Message* temp = _impl_.notemessage_;
  _impl_.notemessage_ = nullptr;
  return temp;
}
inline ::proto::Message* RequestPaymentMessage::_internal_mutable_notemessage() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.notemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Message>(GetArenaForAllocation());
    _impl_.notemessage_ = p;
  }
  return _impl_.notemessage_;
}
inline ::proto::Message* RequestPaymentMessage::mutable_notemessage() {
  ::proto::Message* _msg = _internal_mutable_notemessage();
  // @@protoc_insertion_point(field_mutable:proto.RequestPaymentMessage.noteMessage)
  return _msg;
}
inline void RequestPaymentMessage::set_allocated_notemessage(::proto::Message* notemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.notemessage_;
  }
  if (notemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(notemessage);
    if (message_arena != submessage_arena) {
      notemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, notemessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.notemessage_ = notemessage;
  // @@protoc_insertion_point(field_set_allocated:proto.RequestPaymentMessage.noteMessage)
}

// optional string currencyCodeIso4217 = 1;
inline bool RequestPaymentMessage::_internal_has_currencycodeiso4217() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestPaymentMessage::has_currencycodeiso4217() const {
  return _internal_has_currencycodeiso4217();
}
inline void RequestPaymentMessage::clear_currencycodeiso4217() {
  _impl_.currencycodeiso4217_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestPaymentMessage::currencycodeiso4217() const {
  // @@protoc_insertion_point(field_get:proto.RequestPaymentMessage.currencyCodeIso4217)
  return _internal_currencycodeiso4217();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestPaymentMessage::set_currencycodeiso4217(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.currencycodeiso4217_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.RequestPaymentMessage.currencyCodeIso4217)
}
inline std::string* RequestPaymentMessage::mutable_currencycodeiso4217() {
  std::string* _s = _internal_mutable_currencycodeiso4217();
  // @@protoc_insertion_point(field_mutable:proto.RequestPaymentMessage.currencyCodeIso4217)
  return _s;
}
inline const std::string& RequestPaymentMessage::_internal_currencycodeiso4217() const {
  return _impl_.currencycodeiso4217_.Get();
}
inline void RequestPaymentMessage::_internal_set_currencycodeiso4217(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.currencycodeiso4217_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestPaymentMessage::_internal_mutable_currencycodeiso4217() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.currencycodeiso4217_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestPaymentMessage::release_currencycodeiso4217() {
  // @@protoc_insertion_point(field_release:proto.RequestPaymentMessage.currencyCodeIso4217)
  if (!_internal_has_currencycodeiso4217()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.currencycodeiso4217_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currencycodeiso4217_.IsDefault()) {
    _impl_.currencycodeiso4217_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RequestPaymentMessage::set_allocated_currencycodeiso4217(std::string* currencycodeiso4217) {
  if (currencycodeiso4217 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.currencycodeiso4217_.SetAllocated(currencycodeiso4217, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currencycodeiso4217_.IsDefault()) {
    _impl_.currencycodeiso4217_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.RequestPaymentMessage.currencyCodeIso4217)
}

// optional uint64 amount1000 = 2;
inline bool RequestPaymentMessage::_internal_has_amount1000() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RequestPaymentMessage::has_amount1000() const {
  return _internal_has_amount1000();
}
inline void RequestPaymentMessage::clear_amount1000() {
  _impl_.amount1000_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t RequestPaymentMessage::_internal_amount1000() const {
  return _impl_.amount1000_;
}
inline uint64_t RequestPaymentMessage::amount1000() const {
  // @@protoc_insertion_point(field_get:proto.RequestPaymentMessage.amount1000)
  return _internal_amount1000();
}
inline void RequestPaymentMessage::_internal_set_amount1000(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.amount1000_ = value;
}
inline void RequestPaymentMessage::set_amount1000(uint64_t value) {
  _internal_set_amount1000(value);
  // @@protoc_insertion_point(field_set:proto.RequestPaymentMessage.amount1000)
}

// optional string requestFrom = 3;
inline bool RequestPaymentMessage::_internal_has_requestfrom() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RequestPaymentMessage::has_requestfrom() const {
  return _internal_has_requestfrom();
}
inline void RequestPaymentMessage::clear_requestfrom() {
  _impl_.requestfrom_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RequestPaymentMessage::requestfrom() const {
  // @@protoc_insertion_point(field_get:proto.RequestPaymentMessage.requestFrom)
  return _internal_requestfrom();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestPaymentMessage::set_requestfrom(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.requestfrom_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.RequestPaymentMessage.requestFrom)
}
inline std::string* RequestPaymentMessage::mutable_requestfrom() {
  std::string* _s = _internal_mutable_requestfrom();
  // @@protoc_insertion_point(field_mutable:proto.RequestPaymentMessage.requestFrom)
  return _s;
}
inline const std::string& RequestPaymentMessage::_internal_requestfrom() const {
  return _impl_.requestfrom_.Get();
}
inline void RequestPaymentMessage::_internal_set_requestfrom(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.requestfrom_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestPaymentMessage::_internal_mutable_requestfrom() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.requestfrom_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestPaymentMessage::release_requestfrom() {
  // @@protoc_insertion_point(field_release:proto.RequestPaymentMessage.requestFrom)
  if (!_internal_has_requestfrom()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.requestfrom_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.requestfrom_.IsDefault()) {
    _impl_.requestfrom_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RequestPaymentMessage::set_allocated_requestfrom(std::string* requestfrom) {
  if (requestfrom != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.requestfrom_.SetAllocated(requestfrom, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.requestfrom_.IsDefault()) {
    _impl_.requestfrom_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.RequestPaymentMessage.requestFrom)
}

// optional int64 expiryTimestamp = 5;
inline bool RequestPaymentMessage::_internal_has_expirytimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RequestPaymentMessage::has_expirytimestamp() const {
  return _internal_has_expirytimestamp();
}
inline void RequestPaymentMessage::clear_expirytimestamp() {
  _impl_.expirytimestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t RequestPaymentMessage::_internal_expirytimestamp() const {
  return _impl_.expirytimestamp_;
}
inline int64_t RequestPaymentMessage::expirytimestamp() const {
  // @@protoc_insertion_point(field_get:proto.RequestPaymentMessage.expiryTimestamp)
  return _internal_expirytimestamp();
}
inline void RequestPaymentMessage::_internal_set_expirytimestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.expirytimestamp_ = value;
}
inline void RequestPaymentMessage::set_expirytimestamp(int64_t value) {
  _internal_set_expirytimestamp(value);
  // @@protoc_insertion_point(field_set:proto.RequestPaymentMessage.expiryTimestamp)
}

// optional .proto.PaymentMoney amount = 6;
inline bool RequestPaymentMessage::_internal_has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amount_ != nullptr);
  return value;
}
inline bool RequestPaymentMessage::has_amount() const {
  return _internal_has_amount();
}
inline void RequestPaymentMessage::clear_amount() {
  if (_impl_.amount_ != nullptr) _impl_.amount_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::proto::PaymentMoney& RequestPaymentMessage::_internal_amount() const {
  const ::proto::PaymentMoney* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::PaymentMoney&>(
      ::proto::_PaymentMoney_default_instance_);
}
inline const ::proto::PaymentMoney& RequestPaymentMessage::amount() const {
  // @@protoc_insertion_point(field_get:proto.RequestPaymentMessage.amount)
  return _internal_amount();
}
inline void RequestPaymentMessage::unsafe_arena_set_allocated_amount(
    ::proto::PaymentMoney* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RequestPaymentMessage.amount)
}
inline ::proto::PaymentMoney* RequestPaymentMessage::release_amount() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::proto::PaymentMoney* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::PaymentMoney* RequestPaymentMessage::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:proto.RequestPaymentMessage.amount)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::proto::PaymentMoney* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::proto::PaymentMoney* RequestPaymentMessage::_internal_mutable_amount() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::PaymentMoney>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::proto::PaymentMoney* RequestPaymentMessage::mutable_amount() {
  ::proto::PaymentMoney* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:proto.RequestPaymentMessage.amount)
  return _msg;
}
inline void RequestPaymentMessage::set_allocated_amount(::proto::PaymentMoney* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.amount_;
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(amount);
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:proto.RequestPaymentMessage.amount)
}

// -------------------------------------------------------------------

// DeclinePaymentRequestMessage

// optional .proto.MessageKey key = 1;
inline bool DeclinePaymentRequestMessage::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline bool DeclinePaymentRequestMessage::has_key() const {
  return _internal_has_key();
}
inline void DeclinePaymentRequestMessage::clear_key() {
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::MessageKey& DeclinePaymentRequestMessage::_internal_key() const {
  const ::proto::MessageKey* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::MessageKey&>(
      ::proto::_MessageKey_default_instance_);
}
inline const ::proto::MessageKey& DeclinePaymentRequestMessage::key() const {
  // @@protoc_insertion_point(field_get:proto.DeclinePaymentRequestMessage.key)
  return _internal_key();
}
inline void DeclinePaymentRequestMessage::unsafe_arena_set_allocated_key(
    ::proto::MessageKey* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.DeclinePaymentRequestMessage.key)
}
inline ::proto::MessageKey* DeclinePaymentRequestMessage::release_key() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::MessageKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::MessageKey* DeclinePaymentRequestMessage::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:proto.DeclinePaymentRequestMessage.key)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::MessageKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::proto::MessageKey* DeclinePaymentRequestMessage::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::MessageKey>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::proto::MessageKey* DeclinePaymentRequestMessage::mutable_key() {
  ::proto::MessageKey* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:proto.DeclinePaymentRequestMessage.key)
  return _msg;
}
inline void DeclinePaymentRequestMessage::set_allocated_key(::proto::MessageKey* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:proto.DeclinePaymentRequestMessage.key)
}

// -------------------------------------------------------------------

// CancelPaymentRequestMessage

// optional .proto.MessageKey key = 1;
inline bool CancelPaymentRequestMessage::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline bool CancelPaymentRequestMessage::has_key() const {
  return _internal_has_key();
}
inline void CancelPaymentRequestMessage::clear_key() {
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::MessageKey& CancelPaymentRequestMessage::_internal_key() const {
  const ::proto::MessageKey* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::MessageKey&>(
      ::proto::_MessageKey_default_instance_);
}
inline const ::proto::MessageKey& CancelPaymentRequestMessage::key() const {
  // @@protoc_insertion_point(field_get:proto.CancelPaymentRequestMessage.key)
  return _internal_key();
}
inline void CancelPaymentRequestMessage::unsafe_arena_set_allocated_key(
    ::proto::MessageKey* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.CancelPaymentRequestMessage.key)
}
inline ::proto::MessageKey* CancelPaymentRequestMessage::release_key() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::MessageKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::MessageKey* CancelPaymentRequestMessage::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:proto.CancelPaymentRequestMessage.key)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::MessageKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::proto::MessageKey* CancelPaymentRequestMessage::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::MessageKey>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::proto::MessageKey* CancelPaymentRequestMessage::mutable_key() {
  ::proto::MessageKey* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:proto.CancelPaymentRequestMessage.key)
  return _msg;
}
inline void CancelPaymentRequestMessage::set_allocated_key(::proto::MessageKey* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:proto.CancelPaymentRequestMessage.key)
}

// -------------------------------------------------------------------

// LiveLocationMessage

// optional double degreesLatitude = 1;
inline bool LiveLocationMessage::_internal_has_degreeslatitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LiveLocationMessage::has_degreeslatitude() const {
  return _internal_has_degreeslatitude();
}
inline void LiveLocationMessage::clear_degreeslatitude() {
  _impl_.degreeslatitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double LiveLocationMessage::_internal_degreeslatitude() const {
  return _impl_.degreeslatitude_;
}
inline double LiveLocationMessage::degreeslatitude() const {
  // @@protoc_insertion_point(field_get:proto.LiveLocationMessage.degreesLatitude)
  return _internal_degreeslatitude();
}
inline void LiveLocationMessage::_internal_set_degreeslatitude(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.degreeslatitude_ = value;
}
inline void LiveLocationMessage::set_degreeslatitude(double value) {
  _internal_set_degreeslatitude(value);
  // @@protoc_insertion_point(field_set:proto.LiveLocationMessage.degreesLatitude)
}

// optional double degreesLongitude = 2;
inline bool LiveLocationMessage::_internal_has_degreeslongitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LiveLocationMessage::has_degreeslongitude() const {
  return _internal_has_degreeslongitude();
}
inline void LiveLocationMessage::clear_degreeslongitude() {
  _impl_.degreeslongitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double LiveLocationMessage::_internal_degreeslongitude() const {
  return _impl_.degreeslongitude_;
}
inline double LiveLocationMessage::degreeslongitude() const {
  // @@protoc_insertion_point(field_get:proto.LiveLocationMessage.degreesLongitude)
  return _internal_degreeslongitude();
}
inline void LiveLocationMessage::_internal_set_degreeslongitude(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.degreeslongitude_ = value;
}
inline void LiveLocationMessage::set_degreeslongitude(double value) {
  _internal_set_degreeslongitude(value);
  // @@protoc_insertion_point(field_set:proto.LiveLocationMessage.degreesLongitude)
}

// optional uint32 accuracyInMeters = 3;
inline bool LiveLocationMessage::_internal_has_accuracyinmeters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LiveLocationMessage::has_accuracyinmeters() const {
  return _internal_has_accuracyinmeters();
}
inline void LiveLocationMessage::clear_accuracyinmeters() {
  _impl_.accuracyinmeters_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t LiveLocationMessage::_internal_accuracyinmeters() const {
  return _impl_.accuracyinmeters_;
}
inline uint32_t LiveLocationMessage::accuracyinmeters() const {
  // @@protoc_insertion_point(field_get:proto.LiveLocationMessage.accuracyInMeters)
  return _internal_accuracyinmeters();
}
inline void LiveLocationMessage::_internal_set_accuracyinmeters(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.accuracyinmeters_ = value;
}
inline void LiveLocationMessage::set_accuracyinmeters(uint32_t value) {
  _internal_set_accuracyinmeters(value);
  // @@protoc_insertion_point(field_set:proto.LiveLocationMessage.accuracyInMeters)
}

// optional float speedInMps = 4;
inline bool LiveLocationMessage::_internal_has_speedinmps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LiveLocationMessage::has_speedinmps() const {
  return _internal_has_speedinmps();
}
inline void LiveLocationMessage::clear_speedinmps() {
  _impl_.speedinmps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float LiveLocationMessage::_internal_speedinmps() const {
  return _impl_.speedinmps_;
}
inline float LiveLocationMessage::speedinmps() const {
  // @@protoc_insertion_point(field_get:proto.LiveLocationMessage.speedInMps)
  return _internal_speedinmps();
}
inline void LiveLocationMessage::_internal_set_speedinmps(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.speedinmps_ = value;
}
inline void LiveLocationMessage::set_speedinmps(float value) {
  _internal_set_speedinmps(value);
  // @@protoc_insertion_point(field_set:proto.LiveLocationMessage.speedInMps)
}

// optional uint32 degreesClockwiseFromMagneticNorth = 5;
inline bool LiveLocationMessage::_internal_has_degreesclockwisefrommagneticnorth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LiveLocationMessage::has_degreesclockwisefrommagneticnorth() const {
  return _internal_has_degreesclockwisefrommagneticnorth();
}
inline void LiveLocationMessage::clear_degreesclockwisefrommagneticnorth() {
  _impl_.degreesclockwisefrommagneticnorth_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t LiveLocationMessage::_internal_degreesclockwisefrommagneticnorth() const {
  return _impl_.degreesclockwisefrommagneticnorth_;
}
inline uint32_t LiveLocationMessage::degreesclockwisefrommagneticnorth() const {
  // @@protoc_insertion_point(field_get:proto.LiveLocationMessage.degreesClockwiseFromMagneticNorth)
  return _internal_degreesclockwisefrommagneticnorth();
}
inline void LiveLocationMessage::_internal_set_degreesclockwisefrommagneticnorth(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.degreesclockwisefrommagneticnorth_ = value;
}
inline void LiveLocationMessage::set_degreesclockwisefrommagneticnorth(uint32_t value) {
  _internal_set_degreesclockwisefrommagneticnorth(value);
  // @@protoc_insertion_point(field_set:proto.LiveLocationMessage.degreesClockwiseFromMagneticNorth)
}

// optional string caption = 6;
inline bool LiveLocationMessage::_internal_has_caption() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LiveLocationMessage::has_caption() const {
  return _internal_has_caption();
}
inline void LiveLocationMessage::clear_caption() {
  _impl_.caption_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LiveLocationMessage::caption() const {
  // @@protoc_insertion_point(field_get:proto.LiveLocationMessage.caption)
  return _internal_caption();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LiveLocationMessage::set_caption(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.caption_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.LiveLocationMessage.caption)
}
inline std::string* LiveLocationMessage::mutable_caption() {
  std::string* _s = _internal_mutable_caption();
  // @@protoc_insertion_point(field_mutable:proto.LiveLocationMessage.caption)
  return _s;
}
inline const std::string& LiveLocationMessage::_internal_caption() const {
  return _impl_.caption_.Get();
}
inline void LiveLocationMessage::_internal_set_caption(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.caption_.Set(value, GetArenaForAllocation());
}
inline std::string* LiveLocationMessage::_internal_mutable_caption() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.caption_.Mutable(GetArenaForAllocation());
}
inline std::string* LiveLocationMessage::release_caption() {
  // @@protoc_insertion_point(field_release:proto.LiveLocationMessage.caption)
  if (!_internal_has_caption()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.caption_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caption_.IsDefault()) {
    _impl_.caption_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LiveLocationMessage::set_allocated_caption(std::string* caption) {
  if (caption != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.caption_.SetAllocated(caption, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caption_.IsDefault()) {
    _impl_.caption_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.LiveLocationMessage.caption)
}

// optional int64 sequenceNumber = 7;
inline bool LiveLocationMessage::_internal_has_sequencenumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool LiveLocationMessage::has_sequencenumber() const {
  return _internal_has_sequencenumber();
}
inline void LiveLocationMessage::clear_sequencenumber() {
  _impl_.sequencenumber_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int64_t LiveLocationMessage::_internal_sequencenumber() const {
  return _impl_.sequencenumber_;
}
inline int64_t LiveLocationMessage::sequencenumber() const {
  // @@protoc_insertion_point(field_get:proto.LiveLocationMessage.sequenceNumber)
  return _internal_sequencenumber();
}
inline void LiveLocationMessage::_internal_set_sequencenumber(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.sequencenumber_ = value;
}
inline void LiveLocationMessage::set_sequencenumber(int64_t value) {
  _internal_set_sequencenumber(value);
  // @@protoc_insertion_point(field_set:proto.LiveLocationMessage.sequenceNumber)
}

// optional uint32 timeOffset = 8;
inline bool LiveLocationMessage::_internal_has_timeoffset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool LiveLocationMessage::has_timeoffset() const {
  return _internal_has_timeoffset();
}
inline void LiveLocationMessage::clear_timeoffset() {
  _impl_.timeoffset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t LiveLocationMessage::_internal_timeoffset() const {
  return _impl_.timeoffset_;
}
inline uint32_t LiveLocationMessage::timeoffset() const {
  // @@protoc_insertion_point(field_get:proto.LiveLocationMessage.timeOffset)
  return _internal_timeoffset();
}
inline void LiveLocationMessage::_internal_set_timeoffset(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.timeoffset_ = value;
}
inline void LiveLocationMessage::set_timeoffset(uint32_t value) {
  _internal_set_timeoffset(value);
  // @@protoc_insertion_point(field_set:proto.LiveLocationMessage.timeOffset)
}

// optional bytes jpegThumbnail = 16;
inline bool LiveLocationMessage::_internal_has_jpegthumbnail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LiveLocationMessage::has_jpegthumbnail() const {
  return _internal_has_jpegthumbnail();
}
inline void LiveLocationMessage::clear_jpegthumbnail() {
  _impl_.jpegthumbnail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LiveLocationMessage::jpegthumbnail() const {
  // @@protoc_insertion_point(field_get:proto.LiveLocationMessage.jpegThumbnail)
  return _internal_jpegthumbnail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LiveLocationMessage::set_jpegthumbnail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.jpegthumbnail_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.LiveLocationMessage.jpegThumbnail)
}
inline std::string* LiveLocationMessage::mutable_jpegthumbnail() {
  std::string* _s = _internal_mutable_jpegthumbnail();
  // @@protoc_insertion_point(field_mutable:proto.LiveLocationMessage.jpegThumbnail)
  return _s;
}
inline const std::string& LiveLocationMessage::_internal_jpegthumbnail() const {
  return _impl_.jpegthumbnail_.Get();
}
inline void LiveLocationMessage::_internal_set_jpegthumbnail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.jpegthumbnail_.Set(value, GetArenaForAllocation());
}
inline std::string* LiveLocationMessage::_internal_mutable_jpegthumbnail() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.jpegthumbnail_.Mutable(GetArenaForAllocation());
}
inline std::string* LiveLocationMessage::release_jpegthumbnail() {
  // @@protoc_insertion_point(field_release:proto.LiveLocationMessage.jpegThumbnail)
  if (!_internal_has_jpegthumbnail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.jpegthumbnail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jpegthumbnail_.IsDefault()) {
    _impl_.jpegthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LiveLocationMessage::set_allocated_jpegthumbnail(std::string* jpegthumbnail) {
  if (jpegthumbnail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.jpegthumbnail_.SetAllocated(jpegthumbnail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jpegthumbnail_.IsDefault()) {
    _impl_.jpegthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.LiveLocationMessage.jpegThumbnail)
}

// optional .proto.ContextInfo contextInfo = 17;
inline bool LiveLocationMessage::_internal_has_contextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contextinfo_ != nullptr);
  return value;
}
inline bool LiveLocationMessage::has_contextinfo() const {
  return _internal_has_contextinfo();
}
inline void LiveLocationMessage::clear_contextinfo() {
  if (_impl_.contextinfo_ != nullptr) _impl_.contextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::proto::ContextInfo& LiveLocationMessage::_internal_contextinfo() const {
  const ::proto::ContextInfo* p = _impl_.contextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContextInfo&>(
      ::proto::_ContextInfo_default_instance_);
}
inline const ::proto::ContextInfo& LiveLocationMessage::contextinfo() const {
  // @@protoc_insertion_point(field_get:proto.LiveLocationMessage.contextInfo)
  return _internal_contextinfo();
}
inline void LiveLocationMessage::unsafe_arena_set_allocated_contextinfo(
    ::proto::ContextInfo* contextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextinfo_);
  }
  _impl_.contextinfo_ = contextinfo;
  if (contextinfo) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.LiveLocationMessage.contextInfo)
}
inline ::proto::ContextInfo* LiveLocationMessage::release_contextinfo() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContextInfo* LiveLocationMessage::unsafe_arena_release_contextinfo() {
  // @@protoc_insertion_point(field_release:proto.LiveLocationMessage.contextInfo)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
  return temp;
}
inline ::proto::ContextInfo* LiveLocationMessage::_internal_mutable_contextinfo() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.contextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContextInfo>(GetArenaForAllocation());
    _impl_.contextinfo_ = p;
  }
  return _impl_.contextinfo_;
}
inline ::proto::ContextInfo* LiveLocationMessage::mutable_contextinfo() {
  ::proto::ContextInfo* _msg = _internal_mutable_contextinfo();
  // @@protoc_insertion_point(field_mutable:proto.LiveLocationMessage.contextInfo)
  return _msg;
}
inline void LiveLocationMessage::set_allocated_contextinfo(::proto::ContextInfo* contextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contextinfo_;
  }
  if (contextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contextinfo);
    if (message_arena != submessage_arena) {
      contextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.contextinfo_ = contextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.LiveLocationMessage.contextInfo)
}

// -------------------------------------------------------------------

// StickerMessage

// optional string url = 1;
inline bool StickerMessage::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StickerMessage::has_url() const {
  return _internal_has_url();
}
inline void StickerMessage::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StickerMessage::url() const {
  // @@protoc_insertion_point(field_get:proto.StickerMessage.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StickerMessage::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.StickerMessage.url)
}
inline std::string* StickerMessage::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:proto.StickerMessage.url)
  return _s;
}
inline const std::string& StickerMessage::_internal_url() const {
  return _impl_.url_.Get();
}
inline void StickerMessage::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* StickerMessage::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* StickerMessage::release_url() {
  // @@protoc_insertion_point(field_release:proto.StickerMessage.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StickerMessage::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.StickerMessage.url)
}

// optional bytes fileSha256 = 2;
inline bool StickerMessage::_internal_has_filesha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StickerMessage::has_filesha256() const {
  return _internal_has_filesha256();
}
inline void StickerMessage::clear_filesha256() {
  _impl_.filesha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StickerMessage::filesha256() const {
  // @@protoc_insertion_point(field_get:proto.StickerMessage.fileSha256)
  return _internal_filesha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StickerMessage::set_filesha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.filesha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.StickerMessage.fileSha256)
}
inline std::string* StickerMessage::mutable_filesha256() {
  std::string* _s = _internal_mutable_filesha256();
  // @@protoc_insertion_point(field_mutable:proto.StickerMessage.fileSha256)
  return _s;
}
inline const std::string& StickerMessage::_internal_filesha256() const {
  return _impl_.filesha256_.Get();
}
inline void StickerMessage::_internal_set_filesha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.filesha256_.Set(value, GetArenaForAllocation());
}
inline std::string* StickerMessage::_internal_mutable_filesha256() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.filesha256_.Mutable(GetArenaForAllocation());
}
inline std::string* StickerMessage::release_filesha256() {
  // @@protoc_insertion_point(field_release:proto.StickerMessage.fileSha256)
  if (!_internal_has_filesha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.filesha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filesha256_.IsDefault()) {
    _impl_.filesha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StickerMessage::set_allocated_filesha256(std::string* filesha256) {
  if (filesha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.filesha256_.SetAllocated(filesha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filesha256_.IsDefault()) {
    _impl_.filesha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.StickerMessage.fileSha256)
}

// optional bytes fileEncSha256 = 3;
inline bool StickerMessage::_internal_has_fileencsha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StickerMessage::has_fileencsha256() const {
  return _internal_has_fileencsha256();
}
inline void StickerMessage::clear_fileencsha256() {
  _impl_.fileencsha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StickerMessage::fileencsha256() const {
  // @@protoc_insertion_point(field_get:proto.StickerMessage.fileEncSha256)
  return _internal_fileencsha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StickerMessage::set_fileencsha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.fileencsha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.StickerMessage.fileEncSha256)
}
inline std::string* StickerMessage::mutable_fileencsha256() {
  std::string* _s = _internal_mutable_fileencsha256();
  // @@protoc_insertion_point(field_mutable:proto.StickerMessage.fileEncSha256)
  return _s;
}
inline const std::string& StickerMessage::_internal_fileencsha256() const {
  return _impl_.fileencsha256_.Get();
}
inline void StickerMessage::_internal_set_fileencsha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.fileencsha256_.Set(value, GetArenaForAllocation());
}
inline std::string* StickerMessage::_internal_mutable_fileencsha256() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.fileencsha256_.Mutable(GetArenaForAllocation());
}
inline std::string* StickerMessage::release_fileencsha256() {
  // @@protoc_insertion_point(field_release:proto.StickerMessage.fileEncSha256)
  if (!_internal_has_fileencsha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.fileencsha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fileencsha256_.IsDefault()) {
    _impl_.fileencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StickerMessage::set_allocated_fileencsha256(std::string* fileencsha256) {
  if (fileencsha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.fileencsha256_.SetAllocated(fileencsha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fileencsha256_.IsDefault()) {
    _impl_.fileencsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.StickerMessage.fileEncSha256)
}

// optional bytes mediaKey = 4;
inline bool StickerMessage::_internal_has_mediakey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StickerMessage::has_mediakey() const {
  return _internal_has_mediakey();
}
inline void StickerMessage::clear_mediakey() {
  _impl_.mediakey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& StickerMessage::mediakey() const {
  // @@protoc_insertion_point(field_get:proto.StickerMessage.mediaKey)
  return _internal_mediakey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StickerMessage::set_mediakey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.mediakey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.StickerMessage.mediaKey)
}
inline std::string* StickerMessage::mutable_mediakey() {
  std::string* _s = _internal_mutable_mediakey();
  // @@protoc_insertion_point(field_mutable:proto.StickerMessage.mediaKey)
  return _s;
}
inline const std::string& StickerMessage::_internal_mediakey() const {
  return _impl_.mediakey_.Get();
}
inline void StickerMessage::_internal_set_mediakey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mediakey_.Set(value, GetArenaForAllocation());
}
inline std::string* StickerMessage::_internal_mutable_mediakey() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.mediakey_.Mutable(GetArenaForAllocation());
}
inline std::string* StickerMessage::release_mediakey() {
  // @@protoc_insertion_point(field_release:proto.StickerMessage.mediaKey)
  if (!_internal_has_mediakey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.mediakey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mediakey_.IsDefault()) {
    _impl_.mediakey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StickerMessage::set_allocated_mediakey(std::string* mediakey) {
  if (mediakey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.mediakey_.SetAllocated(mediakey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mediakey_.IsDefault()) {
    _impl_.mediakey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.StickerMessage.mediaKey)
}

// optional string mimetype = 5;
inline bool StickerMessage::_internal_has_mimetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StickerMessage::has_mimetype() const {
  return _internal_has_mimetype();
}
inline void StickerMessage::clear_mimetype() {
  _impl_.mimetype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& StickerMessage::mimetype() const {
  // @@protoc_insertion_point(field_get:proto.StickerMessage.mimetype)
  return _internal_mimetype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StickerMessage::set_mimetype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.mimetype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.StickerMessage.mimetype)
}
inline std::string* StickerMessage::mutable_mimetype() {
  std::string* _s = _internal_mutable_mimetype();
  // @@protoc_insertion_point(field_mutable:proto.StickerMessage.mimetype)
  return _s;
}
inline const std::string& StickerMessage::_internal_mimetype() const {
  return _impl_.mimetype_.Get();
}
inline void StickerMessage::_internal_set_mimetype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.mimetype_.Set(value, GetArenaForAllocation());
}
inline std::string* StickerMessage::_internal_mutable_mimetype() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.mimetype_.Mutable(GetArenaForAllocation());
}
inline std::string* StickerMessage::release_mimetype() {
  // @@protoc_insertion_point(field_release:proto.StickerMessage.mimetype)
  if (!_internal_has_mimetype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.mimetype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mimetype_.IsDefault()) {
    _impl_.mimetype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StickerMessage::set_allocated_mimetype(std::string* mimetype) {
  if (mimetype != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.mimetype_.SetAllocated(mimetype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mimetype_.IsDefault()) {
    _impl_.mimetype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.StickerMessage.mimetype)
}

// optional uint32 height = 6;
inline bool StickerMessage::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool StickerMessage::has_height() const {
  return _internal_has_height();
}
inline void StickerMessage::clear_height() {
  _impl_.height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t StickerMessage::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t StickerMessage::height() const {
  // @@protoc_insertion_point(field_get:proto.StickerMessage.height)
  return _internal_height();
}
inline void StickerMessage::_internal_set_height(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.height_ = value;
}
inline void StickerMessage::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:proto.StickerMessage.height)
}

// optional uint32 width = 7;
inline bool StickerMessage::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool StickerMessage::has_width() const {
  return _internal_has_width();
}
inline void StickerMessage::clear_width() {
  _impl_.width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint32_t StickerMessage::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t StickerMessage::width() const {
  // @@protoc_insertion_point(field_get:proto.StickerMessage.width)
  return _internal_width();
}
inline void StickerMessage::_internal_set_width(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.width_ = value;
}
inline void StickerMessage::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:proto.StickerMessage.width)
}

// optional string directPath = 8;
inline bool StickerMessage::_internal_has_directpath() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StickerMessage::has_directpath() const {
  return _internal_has_directpath();
}
inline void StickerMessage::clear_directpath() {
  _impl_.directpath_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& StickerMessage::directpath() const {
  // @@protoc_insertion_point(field_get:proto.StickerMessage.directPath)
  return _internal_directpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StickerMessage::set_directpath(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.directpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.StickerMessage.directPath)
}
inline std::string* StickerMessage::mutable_directpath() {
  std::string* _s = _internal_mutable_directpath();
  // @@protoc_insertion_point(field_mutable:proto.StickerMessage.directPath)
  return _s;
}
inline const std::string& StickerMessage::_internal_directpath() const {
  return _impl_.directpath_.Get();
}
inline void StickerMessage::_internal_set_directpath(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.directpath_.Set(value, GetArenaForAllocation());
}
inline std::string* StickerMessage::_internal_mutable_directpath() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.directpath_.Mutable(GetArenaForAllocation());
}
inline std::string* StickerMessage::release_directpath() {
  // @@protoc_insertion_point(field_release:proto.StickerMessage.directPath)
  if (!_internal_has_directpath()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.directpath_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.directpath_.IsDefault()) {
    _impl_.directpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StickerMessage::set_allocated_directpath(std::string* directpath) {
  if (directpath != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.directpath_.SetAllocated(directpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.directpath_.IsDefault()) {
    _impl_.directpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.StickerMessage.directPath)
}

// optional uint64 fileLength = 9;
inline bool StickerMessage::_internal_has_filelength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool StickerMessage::has_filelength() const {
  return _internal_has_filelength();
}
inline void StickerMessage::clear_filelength() {
  _impl_.filelength_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint64_t StickerMessage::_internal_filelength() const {
  return _impl_.filelength_;
}
inline uint64_t StickerMessage::filelength() const {
  // @@protoc_insertion_point(field_get:proto.StickerMessage.fileLength)
  return _internal_filelength();
}
inline void StickerMessage::_internal_set_filelength(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.filelength_ = value;
}
inline void StickerMessage::set_filelength(uint64_t value) {
  _internal_set_filelength(value);
  // @@protoc_insertion_point(field_set:proto.StickerMessage.fileLength)
}

// optional int64 mediaKeyTimestamp = 10;
inline bool StickerMessage::_internal_has_mediakeytimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool StickerMessage::has_mediakeytimestamp() const {
  return _internal_has_mediakeytimestamp();
}
inline void StickerMessage::clear_mediakeytimestamp() {
  _impl_.mediakeytimestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int64_t StickerMessage::_internal_mediakeytimestamp() const {
  return _impl_.mediakeytimestamp_;
}
inline int64_t StickerMessage::mediakeytimestamp() const {
  // @@protoc_insertion_point(field_get:proto.StickerMessage.mediaKeyTimestamp)
  return _internal_mediakeytimestamp();
}
inline void StickerMessage::_internal_set_mediakeytimestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.mediakeytimestamp_ = value;
}
inline void StickerMessage::set_mediakeytimestamp(int64_t value) {
  _internal_set_mediakeytimestamp(value);
  // @@protoc_insertion_point(field_set:proto.StickerMessage.mediaKeyTimestamp)
}

// optional uint32 firstFrameLength = 11;
inline bool StickerMessage::_internal_has_firstframelength() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool StickerMessage::has_firstframelength() const {
  return _internal_has_firstframelength();
}
inline void StickerMessage::clear_firstframelength() {
  _impl_.firstframelength_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint32_t StickerMessage::_internal_firstframelength() const {
  return _impl_.firstframelength_;
}
inline uint32_t StickerMessage::firstframelength() const {
  // @@protoc_insertion_point(field_get:proto.StickerMessage.firstFrameLength)
  return _internal_firstframelength();
}
inline void StickerMessage::_internal_set_firstframelength(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.firstframelength_ = value;
}
inline void StickerMessage::set_firstframelength(uint32_t value) {
  _internal_set_firstframelength(value);
  // @@protoc_insertion_point(field_set:proto.StickerMessage.firstFrameLength)
}

// optional bytes firstFrameSidecar = 12;
inline bool StickerMessage::_internal_has_firstframesidecar() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool StickerMessage::has_firstframesidecar() const {
  return _internal_has_firstframesidecar();
}
inline void StickerMessage::clear_firstframesidecar() {
  _impl_.firstframesidecar_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& StickerMessage::firstframesidecar() const {
  // @@protoc_insertion_point(field_get:proto.StickerMessage.firstFrameSidecar)
  return _internal_firstframesidecar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StickerMessage::set_firstframesidecar(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.firstframesidecar_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.StickerMessage.firstFrameSidecar)
}
inline std::string* StickerMessage::mutable_firstframesidecar() {
  std::string* _s = _internal_mutable_firstframesidecar();
  // @@protoc_insertion_point(field_mutable:proto.StickerMessage.firstFrameSidecar)
  return _s;
}
inline const std::string& StickerMessage::_internal_firstframesidecar() const {
  return _impl_.firstframesidecar_.Get();
}
inline void StickerMessage::_internal_set_firstframesidecar(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.firstframesidecar_.Set(value, GetArenaForAllocation());
}
inline std::string* StickerMessage::_internal_mutable_firstframesidecar() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.firstframesidecar_.Mutable(GetArenaForAllocation());
}
inline std::string* StickerMessage::release_firstframesidecar() {
  // @@protoc_insertion_point(field_release:proto.StickerMessage.firstFrameSidecar)
  if (!_internal_has_firstframesidecar()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.firstframesidecar_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.firstframesidecar_.IsDefault()) {
    _impl_.firstframesidecar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StickerMessage::set_allocated_firstframesidecar(std::string* firstframesidecar) {
  if (firstframesidecar != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.firstframesidecar_.SetAllocated(firstframesidecar, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.firstframesidecar_.IsDefault()) {
    _impl_.firstframesidecar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.StickerMessage.firstFrameSidecar)
}

// optional bool isAnimated = 13;
inline bool StickerMessage::_internal_has_isanimated() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool StickerMessage::has_isanimated() const {
  return _internal_has_isanimated();
}
inline void StickerMessage::clear_isanimated() {
  _impl_.isanimated_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool StickerMessage::_internal_isanimated() const {
  return _impl_.isanimated_;
}
inline bool StickerMessage::isanimated() const {
  // @@protoc_insertion_point(field_get:proto.StickerMessage.isAnimated)
  return _internal_isanimated();
}
inline void StickerMessage::_internal_set_isanimated(bool value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.isanimated_ = value;
}
inline void StickerMessage::set_isanimated(bool value) {
  _internal_set_isanimated(value);
  // @@protoc_insertion_point(field_set:proto.StickerMessage.isAnimated)
}

// optional bytes pngThumbnail = 16;
inline bool StickerMessage::_internal_has_pngthumbnail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool StickerMessage::has_pngthumbnail() const {
  return _internal_has_pngthumbnail();
}
inline void StickerMessage::clear_pngthumbnail() {
  _impl_.pngthumbnail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& StickerMessage::pngthumbnail() const {
  // @@protoc_insertion_point(field_get:proto.StickerMessage.pngThumbnail)
  return _internal_pngthumbnail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StickerMessage::set_pngthumbnail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.pngthumbnail_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.StickerMessage.pngThumbnail)
}
inline std::string* StickerMessage::mutable_pngthumbnail() {
  std::string* _s = _internal_mutable_pngthumbnail();
  // @@protoc_insertion_point(field_mutable:proto.StickerMessage.pngThumbnail)
  return _s;
}
inline const std::string& StickerMessage::_internal_pngthumbnail() const {
  return _impl_.pngthumbnail_.Get();
}
inline void StickerMessage::_internal_set_pngthumbnail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.pngthumbnail_.Set(value, GetArenaForAllocation());
}
inline std::string* StickerMessage::_internal_mutable_pngthumbnail() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.pngthumbnail_.Mutable(GetArenaForAllocation());
}
inline std::string* StickerMessage::release_pngthumbnail() {
  // @@protoc_insertion_point(field_release:proto.StickerMessage.pngThumbnail)
  if (!_internal_has_pngthumbnail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.pngthumbnail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pngthumbnail_.IsDefault()) {
    _impl_.pngthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StickerMessage::set_allocated_pngthumbnail(std::string* pngthumbnail) {
  if (pngthumbnail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.pngthumbnail_.SetAllocated(pngthumbnail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pngthumbnail_.IsDefault()) {
    _impl_.pngthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.StickerMessage.pngThumbnail)
}

// optional .proto.ContextInfo contextInfo = 17;
inline bool StickerMessage::_internal_has_contextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contextinfo_ != nullptr);
  return value;
}
inline bool StickerMessage::has_contextinfo() const {
  return _internal_has_contextinfo();
}
inline void StickerMessage::clear_contextinfo() {
  if (_impl_.contextinfo_ != nullptr) _impl_.contextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::proto::ContextInfo& StickerMessage::_internal_contextinfo() const {
  const ::proto::ContextInfo* p = _impl_.contextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContextInfo&>(
      ::proto::_ContextInfo_default_instance_);
}
inline const ::proto::ContextInfo& StickerMessage::contextinfo() const {
  // @@protoc_insertion_point(field_get:proto.StickerMessage.contextInfo)
  return _internal_contextinfo();
}
inline void StickerMessage::unsafe_arena_set_allocated_contextinfo(
    ::proto::ContextInfo* contextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextinfo_);
  }
  _impl_.contextinfo_ = contextinfo;
  if (contextinfo) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.StickerMessage.contextInfo)
}
inline ::proto::ContextInfo* StickerMessage::release_contextinfo() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContextInfo* StickerMessage::unsafe_arena_release_contextinfo() {
  // @@protoc_insertion_point(field_release:proto.StickerMessage.contextInfo)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
  return temp;
}
inline ::proto::ContextInfo* StickerMessage::_internal_mutable_contextinfo() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.contextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContextInfo>(GetArenaForAllocation());
    _impl_.contextinfo_ = p;
  }
  return _impl_.contextinfo_;
}
inline ::proto::ContextInfo* StickerMessage::mutable_contextinfo() {
  ::proto::ContextInfo* _msg = _internal_mutable_contextinfo();
  // @@protoc_insertion_point(field_mutable:proto.StickerMessage.contextInfo)
  return _msg;
}
inline void StickerMessage::set_allocated_contextinfo(::proto::ContextInfo* contextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contextinfo_;
  }
  if (contextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contextinfo);
    if (message_arena != submessage_arena) {
      contextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.contextinfo_ = contextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.StickerMessage.contextInfo)
}

// -------------------------------------------------------------------

// FourRowTemplate

// optional .proto.HighlyStructuredMessage content = 6;
inline bool FourRowTemplate::_internal_has_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.content_ != nullptr);
  return value;
}
inline bool FourRowTemplate::has_content() const {
  return _internal_has_content();
}
inline void FourRowTemplate::clear_content() {
  if (_impl_.content_ != nullptr) _impl_.content_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::HighlyStructuredMessage& FourRowTemplate::_internal_content() const {
  const ::proto::HighlyStructuredMessage* p = _impl_.content_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::HighlyStructuredMessage&>(
      ::proto::_HighlyStructuredMessage_default_instance_);
}
inline const ::proto::HighlyStructuredMessage& FourRowTemplate::content() const {
  // @@protoc_insertion_point(field_get:proto.FourRowTemplate.content)
  return _internal_content();
}
inline void FourRowTemplate::unsafe_arena_set_allocated_content(
    ::proto::HighlyStructuredMessage* content) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_);
  }
  _impl_.content_ = content;
  if (content) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FourRowTemplate.content)
}
inline ::proto::HighlyStructuredMessage* FourRowTemplate::release_content() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::HighlyStructuredMessage* temp = _impl_.content_;
  _impl_.content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::HighlyStructuredMessage* FourRowTemplate::unsafe_arena_release_content() {
  // @@protoc_insertion_point(field_release:proto.FourRowTemplate.content)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::HighlyStructuredMessage* temp = _impl_.content_;
  _impl_.content_ = nullptr;
  return temp;
}
inline ::proto::HighlyStructuredMessage* FourRowTemplate::_internal_mutable_content() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.content_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::HighlyStructuredMessage>(GetArenaForAllocation());
    _impl_.content_ = p;
  }
  return _impl_.content_;
}
inline ::proto::HighlyStructuredMessage* FourRowTemplate::mutable_content() {
  ::proto::HighlyStructuredMessage* _msg = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:proto.FourRowTemplate.content)
  return _msg;
}
inline void FourRowTemplate::set_allocated_content(::proto::HighlyStructuredMessage* content) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.content_;
  }
  if (content) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(content);
    if (message_arena != submessage_arena) {
      content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.content_ = content;
  // @@protoc_insertion_point(field_set_allocated:proto.FourRowTemplate.content)
}

// optional .proto.HighlyStructuredMessage footer = 7;
inline bool FourRowTemplate::_internal_has_footer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.footer_ != nullptr);
  return value;
}
inline bool FourRowTemplate::has_footer() const {
  return _internal_has_footer();
}
inline void FourRowTemplate::clear_footer() {
  if (_impl_.footer_ != nullptr) _impl_.footer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::HighlyStructuredMessage& FourRowTemplate::_internal_footer() const {
  const ::proto::HighlyStructuredMessage* p = _impl_.footer_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::HighlyStructuredMessage&>(
      ::proto::_HighlyStructuredMessage_default_instance_);
}
inline const ::proto::HighlyStructuredMessage& FourRowTemplate::footer() const {
  // @@protoc_insertion_point(field_get:proto.FourRowTemplate.footer)
  return _internal_footer();
}
inline void FourRowTemplate::unsafe_arena_set_allocated_footer(
    ::proto::HighlyStructuredMessage* footer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.footer_);
  }
  _impl_.footer_ = footer;
  if (footer) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FourRowTemplate.footer)
}
inline ::proto::HighlyStructuredMessage* FourRowTemplate::release_footer() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::HighlyStructuredMessage* temp = _impl_.footer_;
  _impl_.footer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::HighlyStructuredMessage* FourRowTemplate::unsafe_arena_release_footer() {
  // @@protoc_insertion_point(field_release:proto.FourRowTemplate.footer)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::HighlyStructuredMessage* temp = _impl_.footer_;
  _impl_.footer_ = nullptr;
  return temp;
}
inline ::proto::HighlyStructuredMessage* FourRowTemplate::_internal_mutable_footer() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.footer_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::HighlyStructuredMessage>(GetArenaForAllocation());
    _impl_.footer_ = p;
  }
  return _impl_.footer_;
}
inline ::proto::HighlyStructuredMessage* FourRowTemplate::mutable_footer() {
  ::proto::HighlyStructuredMessage* _msg = _internal_mutable_footer();
  // @@protoc_insertion_point(field_mutable:proto.FourRowTemplate.footer)
  return _msg;
}
inline void FourRowTemplate::set_allocated_footer(::proto::HighlyStructuredMessage* footer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.footer_;
  }
  if (footer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(footer);
    if (message_arena != submessage_arena) {
      footer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, footer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.footer_ = footer;
  // @@protoc_insertion_point(field_set_allocated:proto.FourRowTemplate.footer)
}

// repeated .proto.TemplateButton buttons = 8;
inline int FourRowTemplate::_internal_buttons_size() const {
  return _impl_.buttons_.size();
}
inline int FourRowTemplate::buttons_size() const {
  return _internal_buttons_size();
}
inline void FourRowTemplate::clear_buttons() {
  _impl_.buttons_.Clear();
}
inline ::proto::TemplateButton* FourRowTemplate::mutable_buttons(int index) {
  // @@protoc_insertion_point(field_mutable:proto.FourRowTemplate.buttons)
  return _impl_.buttons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TemplateButton >*
FourRowTemplate::mutable_buttons() {
  // @@protoc_insertion_point(field_mutable_list:proto.FourRowTemplate.buttons)
  return &_impl_.buttons_;
}
inline const ::proto::TemplateButton& FourRowTemplate::_internal_buttons(int index) const {
  return _impl_.buttons_.Get(index);
}
inline const ::proto::TemplateButton& FourRowTemplate::buttons(int index) const {
  // @@protoc_insertion_point(field_get:proto.FourRowTemplate.buttons)
  return _internal_buttons(index);
}
inline ::proto::TemplateButton* FourRowTemplate::_internal_add_buttons() {
  return _impl_.buttons_.Add();
}
inline ::proto::TemplateButton* FourRowTemplate::add_buttons() {
  ::proto::TemplateButton* _add = _internal_add_buttons();
  // @@protoc_insertion_point(field_add:proto.FourRowTemplate.buttons)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TemplateButton >&
FourRowTemplate::buttons() const {
  // @@protoc_insertion_point(field_list:proto.FourRowTemplate.buttons)
  return _impl_.buttons_;
}

// .proto.DocumentMessage documentMessage = 1;
inline bool FourRowTemplate::_internal_has_documentmessage() const {
  return title_case() == kDocumentMessage;
}
inline bool FourRowTemplate::has_documentmessage() const {
  return _internal_has_documentmessage();
}
inline void FourRowTemplate::set_has_documentmessage() {
  _impl_._oneof_case_[0] = kDocumentMessage;
}
inline void FourRowTemplate::clear_documentmessage() {
  if (_internal_has_documentmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.title_.documentmessage_;
    }
    clear_has_title();
  }
}
inline ::proto::DocumentMessage* FourRowTemplate::release_documentmessage() {
  // @@protoc_insertion_point(field_release:proto.FourRowTemplate.documentMessage)
  if (_internal_has_documentmessage()) {
    clear_has_title();
    ::proto::DocumentMessage* temp = _impl_.title_.documentmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.title_.documentmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::DocumentMessage& FourRowTemplate::_internal_documentmessage() const {
  return _internal_has_documentmessage()
      ? *_impl_.title_.documentmessage_
      : reinterpret_cast< ::proto::DocumentMessage&>(::proto::_DocumentMessage_default_instance_);
}
inline const ::proto::DocumentMessage& FourRowTemplate::documentmessage() const {
  // @@protoc_insertion_point(field_get:proto.FourRowTemplate.documentMessage)
  return _internal_documentmessage();
}
inline ::proto::DocumentMessage* FourRowTemplate::unsafe_arena_release_documentmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.FourRowTemplate.documentMessage)
  if (_internal_has_documentmessage()) {
    clear_has_title();
    ::proto::DocumentMessage* temp = _impl_.title_.documentmessage_;
    _impl_.title_.documentmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FourRowTemplate::unsafe_arena_set_allocated_documentmessage(::proto::DocumentMessage* documentmessage) {
  clear_title();
  if (documentmessage) {
    set_has_documentmessage();
    _impl_.title_.documentmessage_ = documentmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FourRowTemplate.documentMessage)
}
inline ::proto::DocumentMessage* FourRowTemplate::_internal_mutable_documentmessage() {
  if (!_internal_has_documentmessage()) {
    clear_title();
    set_has_documentmessage();
    _impl_.title_.documentmessage_ = CreateMaybeMessage< ::proto::DocumentMessage >(GetArenaForAllocation());
  }
  return _impl_.title_.documentmessage_;
}
inline ::proto::DocumentMessage* FourRowTemplate::mutable_documentmessage() {
  ::proto::DocumentMessage* _msg = _internal_mutable_documentmessage();
  // @@protoc_insertion_point(field_mutable:proto.FourRowTemplate.documentMessage)
  return _msg;
}

// .proto.HighlyStructuredMessage highlyStructuredMessage = 2;
inline bool FourRowTemplate::_internal_has_highlystructuredmessage() const {
  return title_case() == kHighlyStructuredMessage;
}
inline bool FourRowTemplate::has_highlystructuredmessage() const {
  return _internal_has_highlystructuredmessage();
}
inline void FourRowTemplate::set_has_highlystructuredmessage() {
  _impl_._oneof_case_[0] = kHighlyStructuredMessage;
}
inline void FourRowTemplate::clear_highlystructuredmessage() {
  if (_internal_has_highlystructuredmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.title_.highlystructuredmessage_;
    }
    clear_has_title();
  }
}
inline ::proto::HighlyStructuredMessage* FourRowTemplate::release_highlystructuredmessage() {
  // @@protoc_insertion_point(field_release:proto.FourRowTemplate.highlyStructuredMessage)
  if (_internal_has_highlystructuredmessage()) {
    clear_has_title();
    ::proto::HighlyStructuredMessage* temp = _impl_.title_.highlystructuredmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.title_.highlystructuredmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::HighlyStructuredMessage& FourRowTemplate::_internal_highlystructuredmessage() const {
  return _internal_has_highlystructuredmessage()
      ? *_impl_.title_.highlystructuredmessage_
      : reinterpret_cast< ::proto::HighlyStructuredMessage&>(::proto::_HighlyStructuredMessage_default_instance_);
}
inline const ::proto::HighlyStructuredMessage& FourRowTemplate::highlystructuredmessage() const {
  // @@protoc_insertion_point(field_get:proto.FourRowTemplate.highlyStructuredMessage)
  return _internal_highlystructuredmessage();
}
inline ::proto::HighlyStructuredMessage* FourRowTemplate::unsafe_arena_release_highlystructuredmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.FourRowTemplate.highlyStructuredMessage)
  if (_internal_has_highlystructuredmessage()) {
    clear_has_title();
    ::proto::HighlyStructuredMessage* temp = _impl_.title_.highlystructuredmessage_;
    _impl_.title_.highlystructuredmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FourRowTemplate::unsafe_arena_set_allocated_highlystructuredmessage(::proto::HighlyStructuredMessage* highlystructuredmessage) {
  clear_title();
  if (highlystructuredmessage) {
    set_has_highlystructuredmessage();
    _impl_.title_.highlystructuredmessage_ = highlystructuredmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FourRowTemplate.highlyStructuredMessage)
}
inline ::proto::HighlyStructuredMessage* FourRowTemplate::_internal_mutable_highlystructuredmessage() {
  if (!_internal_has_highlystructuredmessage()) {
    clear_title();
    set_has_highlystructuredmessage();
    _impl_.title_.highlystructuredmessage_ = CreateMaybeMessage< ::proto::HighlyStructuredMessage >(GetArenaForAllocation());
  }
  return _impl_.title_.highlystructuredmessage_;
}
inline ::proto::HighlyStructuredMessage* FourRowTemplate::mutable_highlystructuredmessage() {
  ::proto::HighlyStructuredMessage* _msg = _internal_mutable_highlystructuredmessage();
  // @@protoc_insertion_point(field_mutable:proto.FourRowTemplate.highlyStructuredMessage)
  return _msg;
}

// .proto.ImageMessage imageMessage = 3;
inline bool FourRowTemplate::_internal_has_imagemessage() const {
  return title_case() == kImageMessage;
}
inline bool FourRowTemplate::has_imagemessage() const {
  return _internal_has_imagemessage();
}
inline void FourRowTemplate::set_has_imagemessage() {
  _impl_._oneof_case_[0] = kImageMessage;
}
inline void FourRowTemplate::clear_imagemessage() {
  if (_internal_has_imagemessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.title_.imagemessage_;
    }
    clear_has_title();
  }
}
inline ::proto::ImageMessage* FourRowTemplate::release_imagemessage() {
  // @@protoc_insertion_point(field_release:proto.FourRowTemplate.imageMessage)
  if (_internal_has_imagemessage()) {
    clear_has_title();
    ::proto::ImageMessage* temp = _impl_.title_.imagemessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.title_.imagemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ImageMessage& FourRowTemplate::_internal_imagemessage() const {
  return _internal_has_imagemessage()
      ? *_impl_.title_.imagemessage_
      : reinterpret_cast< ::proto::ImageMessage&>(::proto::_ImageMessage_default_instance_);
}
inline const ::proto::ImageMessage& FourRowTemplate::imagemessage() const {
  // @@protoc_insertion_point(field_get:proto.FourRowTemplate.imageMessage)
  return _internal_imagemessage();
}
inline ::proto::ImageMessage* FourRowTemplate::unsafe_arena_release_imagemessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.FourRowTemplate.imageMessage)
  if (_internal_has_imagemessage()) {
    clear_has_title();
    ::proto::ImageMessage* temp = _impl_.title_.imagemessage_;
    _impl_.title_.imagemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FourRowTemplate::unsafe_arena_set_allocated_imagemessage(::proto::ImageMessage* imagemessage) {
  clear_title();
  if (imagemessage) {
    set_has_imagemessage();
    _impl_.title_.imagemessage_ = imagemessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FourRowTemplate.imageMessage)
}
inline ::proto::ImageMessage* FourRowTemplate::_internal_mutable_imagemessage() {
  if (!_internal_has_imagemessage()) {
    clear_title();
    set_has_imagemessage();
    _impl_.title_.imagemessage_ = CreateMaybeMessage< ::proto::ImageMessage >(GetArenaForAllocation());
  }
  return _impl_.title_.imagemessage_;
}
inline ::proto::ImageMessage* FourRowTemplate::mutable_imagemessage() {
  ::proto::ImageMessage* _msg = _internal_mutable_imagemessage();
  // @@protoc_insertion_point(field_mutable:proto.FourRowTemplate.imageMessage)
  return _msg;
}

// .proto.VideoMessage videoMessage = 4;
inline bool FourRowTemplate::_internal_has_videomessage() const {
  return title_case() == kVideoMessage;
}
inline bool FourRowTemplate::has_videomessage() const {
  return _internal_has_videomessage();
}
inline void FourRowTemplate::set_has_videomessage() {
  _impl_._oneof_case_[0] = kVideoMessage;
}
inline void FourRowTemplate::clear_videomessage() {
  if (_internal_has_videomessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.title_.videomessage_;
    }
    clear_has_title();
  }
}
inline ::proto::VideoMessage* FourRowTemplate::release_videomessage() {
  // @@protoc_insertion_point(field_release:proto.FourRowTemplate.videoMessage)
  if (_internal_has_videomessage()) {
    clear_has_title();
    ::proto::VideoMessage* temp = _impl_.title_.videomessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.title_.videomessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::VideoMessage& FourRowTemplate::_internal_videomessage() const {
  return _internal_has_videomessage()
      ? *_impl_.title_.videomessage_
      : reinterpret_cast< ::proto::VideoMessage&>(::proto::_VideoMessage_default_instance_);
}
inline const ::proto::VideoMessage& FourRowTemplate::videomessage() const {
  // @@protoc_insertion_point(field_get:proto.FourRowTemplate.videoMessage)
  return _internal_videomessage();
}
inline ::proto::VideoMessage* FourRowTemplate::unsafe_arena_release_videomessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.FourRowTemplate.videoMessage)
  if (_internal_has_videomessage()) {
    clear_has_title();
    ::proto::VideoMessage* temp = _impl_.title_.videomessage_;
    _impl_.title_.videomessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FourRowTemplate::unsafe_arena_set_allocated_videomessage(::proto::VideoMessage* videomessage) {
  clear_title();
  if (videomessage) {
    set_has_videomessage();
    _impl_.title_.videomessage_ = videomessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FourRowTemplate.videoMessage)
}
inline ::proto::VideoMessage* FourRowTemplate::_internal_mutable_videomessage() {
  if (!_internal_has_videomessage()) {
    clear_title();
    set_has_videomessage();
    _impl_.title_.videomessage_ = CreateMaybeMessage< ::proto::VideoMessage >(GetArenaForAllocation());
  }
  return _impl_.title_.videomessage_;
}
inline ::proto::VideoMessage* FourRowTemplate::mutable_videomessage() {
  ::proto::VideoMessage* _msg = _internal_mutable_videomessage();
  // @@protoc_insertion_point(field_mutable:proto.FourRowTemplate.videoMessage)
  return _msg;
}

// .proto.LocationMessage locationMessage = 5;
inline bool FourRowTemplate::_internal_has_locationmessage() const {
  return title_case() == kLocationMessage;
}
inline bool FourRowTemplate::has_locationmessage() const {
  return _internal_has_locationmessage();
}
inline void FourRowTemplate::set_has_locationmessage() {
  _impl_._oneof_case_[0] = kLocationMessage;
}
inline void FourRowTemplate::clear_locationmessage() {
  if (_internal_has_locationmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.title_.locationmessage_;
    }
    clear_has_title();
  }
}
inline ::proto::LocationMessage* FourRowTemplate::release_locationmessage() {
  // @@protoc_insertion_point(field_release:proto.FourRowTemplate.locationMessage)
  if (_internal_has_locationmessage()) {
    clear_has_title();
    ::proto::LocationMessage* temp = _impl_.title_.locationmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.title_.locationmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::LocationMessage& FourRowTemplate::_internal_locationmessage() const {
  return _internal_has_locationmessage()
      ? *_impl_.title_.locationmessage_
      : reinterpret_cast< ::proto::LocationMessage&>(::proto::_LocationMessage_default_instance_);
}
inline const ::proto::LocationMessage& FourRowTemplate::locationmessage() const {
  // @@protoc_insertion_point(field_get:proto.FourRowTemplate.locationMessage)
  return _internal_locationmessage();
}
inline ::proto::LocationMessage* FourRowTemplate::unsafe_arena_release_locationmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.FourRowTemplate.locationMessage)
  if (_internal_has_locationmessage()) {
    clear_has_title();
    ::proto::LocationMessage* temp = _impl_.title_.locationmessage_;
    _impl_.title_.locationmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FourRowTemplate::unsafe_arena_set_allocated_locationmessage(::proto::LocationMessage* locationmessage) {
  clear_title();
  if (locationmessage) {
    set_has_locationmessage();
    _impl_.title_.locationmessage_ = locationmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FourRowTemplate.locationMessage)
}
inline ::proto::LocationMessage* FourRowTemplate::_internal_mutable_locationmessage() {
  if (!_internal_has_locationmessage()) {
    clear_title();
    set_has_locationmessage();
    _impl_.title_.locationmessage_ = CreateMaybeMessage< ::proto::LocationMessage >(GetArenaForAllocation());
  }
  return _impl_.title_.locationmessage_;
}
inline ::proto::LocationMessage* FourRowTemplate::mutable_locationmessage() {
  ::proto::LocationMessage* _msg = _internal_mutable_locationmessage();
  // @@protoc_insertion_point(field_mutable:proto.FourRowTemplate.locationMessage)
  return _msg;
}

inline bool FourRowTemplate::has_title() const {
  return title_case() != TITLE_NOT_SET;
}
inline void FourRowTemplate::clear_has_title() {
  _impl_._oneof_case_[0] = TITLE_NOT_SET;
}
inline FourRowTemplate::TitleCase FourRowTemplate::title_case() const {
  return FourRowTemplate::TitleCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// HydratedFourRowTemplate

// optional string hydratedContentText = 6;
inline bool HydratedFourRowTemplate::_internal_has_hydratedcontenttext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HydratedFourRowTemplate::has_hydratedcontenttext() const {
  return _internal_has_hydratedcontenttext();
}
inline void HydratedFourRowTemplate::clear_hydratedcontenttext() {
  _impl_.hydratedcontenttext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HydratedFourRowTemplate::hydratedcontenttext() const {
  // @@protoc_insertion_point(field_get:proto.HydratedFourRowTemplate.hydratedContentText)
  return _internal_hydratedcontenttext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HydratedFourRowTemplate::set_hydratedcontenttext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.hydratedcontenttext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HydratedFourRowTemplate.hydratedContentText)
}
inline std::string* HydratedFourRowTemplate::mutable_hydratedcontenttext() {
  std::string* _s = _internal_mutable_hydratedcontenttext();
  // @@protoc_insertion_point(field_mutable:proto.HydratedFourRowTemplate.hydratedContentText)
  return _s;
}
inline const std::string& HydratedFourRowTemplate::_internal_hydratedcontenttext() const {
  return _impl_.hydratedcontenttext_.Get();
}
inline void HydratedFourRowTemplate::_internal_set_hydratedcontenttext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hydratedcontenttext_.Set(value, GetArenaForAllocation());
}
inline std::string* HydratedFourRowTemplate::_internal_mutable_hydratedcontenttext() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.hydratedcontenttext_.Mutable(GetArenaForAllocation());
}
inline std::string* HydratedFourRowTemplate::release_hydratedcontenttext() {
  // @@protoc_insertion_point(field_release:proto.HydratedFourRowTemplate.hydratedContentText)
  if (!_internal_has_hydratedcontenttext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.hydratedcontenttext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hydratedcontenttext_.IsDefault()) {
    _impl_.hydratedcontenttext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HydratedFourRowTemplate::set_allocated_hydratedcontenttext(std::string* hydratedcontenttext) {
  if (hydratedcontenttext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.hydratedcontenttext_.SetAllocated(hydratedcontenttext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hydratedcontenttext_.IsDefault()) {
    _impl_.hydratedcontenttext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HydratedFourRowTemplate.hydratedContentText)
}

// optional string hydratedFooterText = 7;
inline bool HydratedFourRowTemplate::_internal_has_hydratedfootertext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HydratedFourRowTemplate::has_hydratedfootertext() const {
  return _internal_has_hydratedfootertext();
}
inline void HydratedFourRowTemplate::clear_hydratedfootertext() {
  _impl_.hydratedfootertext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HydratedFourRowTemplate::hydratedfootertext() const {
  // @@protoc_insertion_point(field_get:proto.HydratedFourRowTemplate.hydratedFooterText)
  return _internal_hydratedfootertext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HydratedFourRowTemplate::set_hydratedfootertext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.hydratedfootertext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HydratedFourRowTemplate.hydratedFooterText)
}
inline std::string* HydratedFourRowTemplate::mutable_hydratedfootertext() {
  std::string* _s = _internal_mutable_hydratedfootertext();
  // @@protoc_insertion_point(field_mutable:proto.HydratedFourRowTemplate.hydratedFooterText)
  return _s;
}
inline const std::string& HydratedFourRowTemplate::_internal_hydratedfootertext() const {
  return _impl_.hydratedfootertext_.Get();
}
inline void HydratedFourRowTemplate::_internal_set_hydratedfootertext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.hydratedfootertext_.Set(value, GetArenaForAllocation());
}
inline std::string* HydratedFourRowTemplate::_internal_mutable_hydratedfootertext() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.hydratedfootertext_.Mutable(GetArenaForAllocation());
}
inline std::string* HydratedFourRowTemplate::release_hydratedfootertext() {
  // @@protoc_insertion_point(field_release:proto.HydratedFourRowTemplate.hydratedFooterText)
  if (!_internal_has_hydratedfootertext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.hydratedfootertext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hydratedfootertext_.IsDefault()) {
    _impl_.hydratedfootertext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HydratedFourRowTemplate::set_allocated_hydratedfootertext(std::string* hydratedfootertext) {
  if (hydratedfootertext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.hydratedfootertext_.SetAllocated(hydratedfootertext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hydratedfootertext_.IsDefault()) {
    _impl_.hydratedfootertext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HydratedFourRowTemplate.hydratedFooterText)
}

// repeated .proto.HydratedTemplateButton hydratedButtons = 8;
inline int HydratedFourRowTemplate::_internal_hydratedbuttons_size() const {
  return _impl_.hydratedbuttons_.size();
}
inline int HydratedFourRowTemplate::hydratedbuttons_size() const {
  return _internal_hydratedbuttons_size();
}
inline void HydratedFourRowTemplate::clear_hydratedbuttons() {
  _impl_.hydratedbuttons_.Clear();
}
inline ::proto::HydratedTemplateButton* HydratedFourRowTemplate::mutable_hydratedbuttons(int index) {
  // @@protoc_insertion_point(field_mutable:proto.HydratedFourRowTemplate.hydratedButtons)
  return _impl_.hydratedbuttons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::HydratedTemplateButton >*
HydratedFourRowTemplate::mutable_hydratedbuttons() {
  // @@protoc_insertion_point(field_mutable_list:proto.HydratedFourRowTemplate.hydratedButtons)
  return &_impl_.hydratedbuttons_;
}
inline const ::proto::HydratedTemplateButton& HydratedFourRowTemplate::_internal_hydratedbuttons(int index) const {
  return _impl_.hydratedbuttons_.Get(index);
}
inline const ::proto::HydratedTemplateButton& HydratedFourRowTemplate::hydratedbuttons(int index) const {
  // @@protoc_insertion_point(field_get:proto.HydratedFourRowTemplate.hydratedButtons)
  return _internal_hydratedbuttons(index);
}
inline ::proto::HydratedTemplateButton* HydratedFourRowTemplate::_internal_add_hydratedbuttons() {
  return _impl_.hydratedbuttons_.Add();
}
inline ::proto::HydratedTemplateButton* HydratedFourRowTemplate::add_hydratedbuttons() {
  ::proto::HydratedTemplateButton* _add = _internal_add_hydratedbuttons();
  // @@protoc_insertion_point(field_add:proto.HydratedFourRowTemplate.hydratedButtons)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::HydratedTemplateButton >&
HydratedFourRowTemplate::hydratedbuttons() const {
  // @@protoc_insertion_point(field_list:proto.HydratedFourRowTemplate.hydratedButtons)
  return _impl_.hydratedbuttons_;
}

// optional string templateId = 9;
inline bool HydratedFourRowTemplate::_internal_has_templateid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HydratedFourRowTemplate::has_templateid() const {
  return _internal_has_templateid();
}
inline void HydratedFourRowTemplate::clear_templateid() {
  _impl_.templateid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& HydratedFourRowTemplate::templateid() const {
  // @@protoc_insertion_point(field_get:proto.HydratedFourRowTemplate.templateId)
  return _internal_templateid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HydratedFourRowTemplate::set_templateid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.templateid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HydratedFourRowTemplate.templateId)
}
inline std::string* HydratedFourRowTemplate::mutable_templateid() {
  std::string* _s = _internal_mutable_templateid();
  // @@protoc_insertion_point(field_mutable:proto.HydratedFourRowTemplate.templateId)
  return _s;
}
inline const std::string& HydratedFourRowTemplate::_internal_templateid() const {
  return _impl_.templateid_.Get();
}
inline void HydratedFourRowTemplate::_internal_set_templateid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.templateid_.Set(value, GetArenaForAllocation());
}
inline std::string* HydratedFourRowTemplate::_internal_mutable_templateid() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.templateid_.Mutable(GetArenaForAllocation());
}
inline std::string* HydratedFourRowTemplate::release_templateid() {
  // @@protoc_insertion_point(field_release:proto.HydratedFourRowTemplate.templateId)
  if (!_internal_has_templateid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.templateid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.templateid_.IsDefault()) {
    _impl_.templateid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HydratedFourRowTemplate::set_allocated_templateid(std::string* templateid) {
  if (templateid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.templateid_.SetAllocated(templateid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.templateid_.IsDefault()) {
    _impl_.templateid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.HydratedFourRowTemplate.templateId)
}

// .proto.DocumentMessage documentMessage = 1;
inline bool HydratedFourRowTemplate::_internal_has_documentmessage() const {
  return title_case() == kDocumentMessage;
}
inline bool HydratedFourRowTemplate::has_documentmessage() const {
  return _internal_has_documentmessage();
}
inline void HydratedFourRowTemplate::set_has_documentmessage() {
  _impl_._oneof_case_[0] = kDocumentMessage;
}
inline void HydratedFourRowTemplate::clear_documentmessage() {
  if (_internal_has_documentmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.title_.documentmessage_;
    }
    clear_has_title();
  }
}
inline ::proto::DocumentMessage* HydratedFourRowTemplate::release_documentmessage() {
  // @@protoc_insertion_point(field_release:proto.HydratedFourRowTemplate.documentMessage)
  if (_internal_has_documentmessage()) {
    clear_has_title();
    ::proto::DocumentMessage* temp = _impl_.title_.documentmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.title_.documentmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::DocumentMessage& HydratedFourRowTemplate::_internal_documentmessage() const {
  return _internal_has_documentmessage()
      ? *_impl_.title_.documentmessage_
      : reinterpret_cast< ::proto::DocumentMessage&>(::proto::_DocumentMessage_default_instance_);
}
inline const ::proto::DocumentMessage& HydratedFourRowTemplate::documentmessage() const {
  // @@protoc_insertion_point(field_get:proto.HydratedFourRowTemplate.documentMessage)
  return _internal_documentmessage();
}
inline ::proto::DocumentMessage* HydratedFourRowTemplate::unsafe_arena_release_documentmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.HydratedFourRowTemplate.documentMessage)
  if (_internal_has_documentmessage()) {
    clear_has_title();
    ::proto::DocumentMessage* temp = _impl_.title_.documentmessage_;
    _impl_.title_.documentmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HydratedFourRowTemplate::unsafe_arena_set_allocated_documentmessage(::proto::DocumentMessage* documentmessage) {
  clear_title();
  if (documentmessage) {
    set_has_documentmessage();
    _impl_.title_.documentmessage_ = documentmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HydratedFourRowTemplate.documentMessage)
}
inline ::proto::DocumentMessage* HydratedFourRowTemplate::_internal_mutable_documentmessage() {
  if (!_internal_has_documentmessage()) {
    clear_title();
    set_has_documentmessage();
    _impl_.title_.documentmessage_ = CreateMaybeMessage< ::proto::DocumentMessage >(GetArenaForAllocation());
  }
  return _impl_.title_.documentmessage_;
}
inline ::proto::DocumentMessage* HydratedFourRowTemplate::mutable_documentmessage() {
  ::proto::DocumentMessage* _msg = _internal_mutable_documentmessage();
  // @@protoc_insertion_point(field_mutable:proto.HydratedFourRowTemplate.documentMessage)
  return _msg;
}

// string hydratedTitleText = 2;
inline bool HydratedFourRowTemplate::_internal_has_hydratedtitletext() const {
  return title_case() == kHydratedTitleText;
}
inline bool HydratedFourRowTemplate::has_hydratedtitletext() const {
  return _internal_has_hydratedtitletext();
}
inline void HydratedFourRowTemplate::set_has_hydratedtitletext() {
  _impl_._oneof_case_[0] = kHydratedTitleText;
}
inline void HydratedFourRowTemplate::clear_hydratedtitletext() {
  if (_internal_has_hydratedtitletext()) {
    _impl_.title_.hydratedtitletext_.Destroy();
    clear_has_title();
  }
}
inline const std::string& HydratedFourRowTemplate::hydratedtitletext() const {
  // @@protoc_insertion_point(field_get:proto.HydratedFourRowTemplate.hydratedTitleText)
  return _internal_hydratedtitletext();
}
template <typename ArgT0, typename... ArgT>
inline void HydratedFourRowTemplate::set_hydratedtitletext(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_hydratedtitletext()) {
    clear_title();
    set_has_hydratedtitletext();
    _impl_.title_.hydratedtitletext_.InitDefault();
  }
  _impl_.title_.hydratedtitletext_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.HydratedFourRowTemplate.hydratedTitleText)
}
inline std::string* HydratedFourRowTemplate::mutable_hydratedtitletext() {
  std::string* _s = _internal_mutable_hydratedtitletext();
  // @@protoc_insertion_point(field_mutable:proto.HydratedFourRowTemplate.hydratedTitleText)
  return _s;
}
inline const std::string& HydratedFourRowTemplate::_internal_hydratedtitletext() const {
  if (_internal_has_hydratedtitletext()) {
    return _impl_.title_.hydratedtitletext_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void HydratedFourRowTemplate::_internal_set_hydratedtitletext(const std::string& value) {
  if (!_internal_has_hydratedtitletext()) {
    clear_title();
    set_has_hydratedtitletext();
    _impl_.title_.hydratedtitletext_.InitDefault();
  }
  _impl_.title_.hydratedtitletext_.Set(value, GetArenaForAllocation());
}
inline std::string* HydratedFourRowTemplate::_internal_mutable_hydratedtitletext() {
  if (!_internal_has_hydratedtitletext()) {
    clear_title();
    set_has_hydratedtitletext();
    _impl_.title_.hydratedtitletext_.InitDefault();
  }
  return _impl_.title_.hydratedtitletext_.Mutable(      GetArenaForAllocation());
}
inline std::string* HydratedFourRowTemplate::release_hydratedtitletext() {
  // @@protoc_insertion_point(field_release:proto.HydratedFourRowTemplate.hydratedTitleText)
  if (_internal_has_hydratedtitletext()) {
    clear_has_title();
    return _impl_.title_.hydratedtitletext_.Release();
  } else {
    return nullptr;
  }
}
inline void HydratedFourRowTemplate::set_allocated_hydratedtitletext(std::string* hydratedtitletext) {
  if (has_title()) {
    clear_title();
  }
  if (hydratedtitletext != nullptr) {
    set_has_hydratedtitletext();
    _impl_.title_.hydratedtitletext_.InitAllocated(hydratedtitletext, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.HydratedFourRowTemplate.hydratedTitleText)
}

// .proto.ImageMessage imageMessage = 3;
inline bool HydratedFourRowTemplate::_internal_has_imagemessage() const {
  return title_case() == kImageMessage;
}
inline bool HydratedFourRowTemplate::has_imagemessage() const {
  return _internal_has_imagemessage();
}
inline void HydratedFourRowTemplate::set_has_imagemessage() {
  _impl_._oneof_case_[0] = kImageMessage;
}
inline void HydratedFourRowTemplate::clear_imagemessage() {
  if (_internal_has_imagemessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.title_.imagemessage_;
    }
    clear_has_title();
  }
}
inline ::proto::ImageMessage* HydratedFourRowTemplate::release_imagemessage() {
  // @@protoc_insertion_point(field_release:proto.HydratedFourRowTemplate.imageMessage)
  if (_internal_has_imagemessage()) {
    clear_has_title();
    ::proto::ImageMessage* temp = _impl_.title_.imagemessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.title_.imagemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ImageMessage& HydratedFourRowTemplate::_internal_imagemessage() const {
  return _internal_has_imagemessage()
      ? *_impl_.title_.imagemessage_
      : reinterpret_cast< ::proto::ImageMessage&>(::proto::_ImageMessage_default_instance_);
}
inline const ::proto::ImageMessage& HydratedFourRowTemplate::imagemessage() const {
  // @@protoc_insertion_point(field_get:proto.HydratedFourRowTemplate.imageMessage)
  return _internal_imagemessage();
}
inline ::proto::ImageMessage* HydratedFourRowTemplate::unsafe_arena_release_imagemessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.HydratedFourRowTemplate.imageMessage)
  if (_internal_has_imagemessage()) {
    clear_has_title();
    ::proto::ImageMessage* temp = _impl_.title_.imagemessage_;
    _impl_.title_.imagemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HydratedFourRowTemplate::unsafe_arena_set_allocated_imagemessage(::proto::ImageMessage* imagemessage) {
  clear_title();
  if (imagemessage) {
    set_has_imagemessage();
    _impl_.title_.imagemessage_ = imagemessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HydratedFourRowTemplate.imageMessage)
}
inline ::proto::ImageMessage* HydratedFourRowTemplate::_internal_mutable_imagemessage() {
  if (!_internal_has_imagemessage()) {
    clear_title();
    set_has_imagemessage();
    _impl_.title_.imagemessage_ = CreateMaybeMessage< ::proto::ImageMessage >(GetArenaForAllocation());
  }
  return _impl_.title_.imagemessage_;
}
inline ::proto::ImageMessage* HydratedFourRowTemplate::mutable_imagemessage() {
  ::proto::ImageMessage* _msg = _internal_mutable_imagemessage();
  // @@protoc_insertion_point(field_mutable:proto.HydratedFourRowTemplate.imageMessage)
  return _msg;
}

// .proto.VideoMessage videoMessage = 4;
inline bool HydratedFourRowTemplate::_internal_has_videomessage() const {
  return title_case() == kVideoMessage;
}
inline bool HydratedFourRowTemplate::has_videomessage() const {
  return _internal_has_videomessage();
}
inline void HydratedFourRowTemplate::set_has_videomessage() {
  _impl_._oneof_case_[0] = kVideoMessage;
}
inline void HydratedFourRowTemplate::clear_videomessage() {
  if (_internal_has_videomessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.title_.videomessage_;
    }
    clear_has_title();
  }
}
inline ::proto::VideoMessage* HydratedFourRowTemplate::release_videomessage() {
  // @@protoc_insertion_point(field_release:proto.HydratedFourRowTemplate.videoMessage)
  if (_internal_has_videomessage()) {
    clear_has_title();
    ::proto::VideoMessage* temp = _impl_.title_.videomessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.title_.videomessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::VideoMessage& HydratedFourRowTemplate::_internal_videomessage() const {
  return _internal_has_videomessage()
      ? *_impl_.title_.videomessage_
      : reinterpret_cast< ::proto::VideoMessage&>(::proto::_VideoMessage_default_instance_);
}
inline const ::proto::VideoMessage& HydratedFourRowTemplate::videomessage() const {
  // @@protoc_insertion_point(field_get:proto.HydratedFourRowTemplate.videoMessage)
  return _internal_videomessage();
}
inline ::proto::VideoMessage* HydratedFourRowTemplate::unsafe_arena_release_videomessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.HydratedFourRowTemplate.videoMessage)
  if (_internal_has_videomessage()) {
    clear_has_title();
    ::proto::VideoMessage* temp = _impl_.title_.videomessage_;
    _impl_.title_.videomessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HydratedFourRowTemplate::unsafe_arena_set_allocated_videomessage(::proto::VideoMessage* videomessage) {
  clear_title();
  if (videomessage) {
    set_has_videomessage();
    _impl_.title_.videomessage_ = videomessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HydratedFourRowTemplate.videoMessage)
}
inline ::proto::VideoMessage* HydratedFourRowTemplate::_internal_mutable_videomessage() {
  if (!_internal_has_videomessage()) {
    clear_title();
    set_has_videomessage();
    _impl_.title_.videomessage_ = CreateMaybeMessage< ::proto::VideoMessage >(GetArenaForAllocation());
  }
  return _impl_.title_.videomessage_;
}
inline ::proto::VideoMessage* HydratedFourRowTemplate::mutable_videomessage() {
  ::proto::VideoMessage* _msg = _internal_mutable_videomessage();
  // @@protoc_insertion_point(field_mutable:proto.HydratedFourRowTemplate.videoMessage)
  return _msg;
}

// .proto.LocationMessage locationMessage = 5;
inline bool HydratedFourRowTemplate::_internal_has_locationmessage() const {
  return title_case() == kLocationMessage;
}
inline bool HydratedFourRowTemplate::has_locationmessage() const {
  return _internal_has_locationmessage();
}
inline void HydratedFourRowTemplate::set_has_locationmessage() {
  _impl_._oneof_case_[0] = kLocationMessage;
}
inline void HydratedFourRowTemplate::clear_locationmessage() {
  if (_internal_has_locationmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.title_.locationmessage_;
    }
    clear_has_title();
  }
}
inline ::proto::LocationMessage* HydratedFourRowTemplate::release_locationmessage() {
  // @@protoc_insertion_point(field_release:proto.HydratedFourRowTemplate.locationMessage)
  if (_internal_has_locationmessage()) {
    clear_has_title();
    ::proto::LocationMessage* temp = _impl_.title_.locationmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.title_.locationmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::LocationMessage& HydratedFourRowTemplate::_internal_locationmessage() const {
  return _internal_has_locationmessage()
      ? *_impl_.title_.locationmessage_
      : reinterpret_cast< ::proto::LocationMessage&>(::proto::_LocationMessage_default_instance_);
}
inline const ::proto::LocationMessage& HydratedFourRowTemplate::locationmessage() const {
  // @@protoc_insertion_point(field_get:proto.HydratedFourRowTemplate.locationMessage)
  return _internal_locationmessage();
}
inline ::proto::LocationMessage* HydratedFourRowTemplate::unsafe_arena_release_locationmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.HydratedFourRowTemplate.locationMessage)
  if (_internal_has_locationmessage()) {
    clear_has_title();
    ::proto::LocationMessage* temp = _impl_.title_.locationmessage_;
    _impl_.title_.locationmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HydratedFourRowTemplate::unsafe_arena_set_allocated_locationmessage(::proto::LocationMessage* locationmessage) {
  clear_title();
  if (locationmessage) {
    set_has_locationmessage();
    _impl_.title_.locationmessage_ = locationmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.HydratedFourRowTemplate.locationMessage)
}
inline ::proto::LocationMessage* HydratedFourRowTemplate::_internal_mutable_locationmessage() {
  if (!_internal_has_locationmessage()) {
    clear_title();
    set_has_locationmessage();
    _impl_.title_.locationmessage_ = CreateMaybeMessage< ::proto::LocationMessage >(GetArenaForAllocation());
  }
  return _impl_.title_.locationmessage_;
}
inline ::proto::LocationMessage* HydratedFourRowTemplate::mutable_locationmessage() {
  ::proto::LocationMessage* _msg = _internal_mutable_locationmessage();
  // @@protoc_insertion_point(field_mutable:proto.HydratedFourRowTemplate.locationMessage)
  return _msg;
}

inline bool HydratedFourRowTemplate::has_title() const {
  return title_case() != TITLE_NOT_SET;
}
inline void HydratedFourRowTemplate::clear_has_title() {
  _impl_._oneof_case_[0] = TITLE_NOT_SET;
}
inline HydratedFourRowTemplate::TitleCase HydratedFourRowTemplate::title_case() const {
  return HydratedFourRowTemplate::TitleCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TemplateMessage

// optional .proto.ContextInfo contextInfo = 3;
inline bool TemplateMessage::_internal_has_contextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contextinfo_ != nullptr);
  return value;
}
inline bool TemplateMessage::has_contextinfo() const {
  return _internal_has_contextinfo();
}
inline void TemplateMessage::clear_contextinfo() {
  if (_impl_.contextinfo_ != nullptr) _impl_.contextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::ContextInfo& TemplateMessage::_internal_contextinfo() const {
  const ::proto::ContextInfo* p = _impl_.contextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContextInfo&>(
      ::proto::_ContextInfo_default_instance_);
}
inline const ::proto::ContextInfo& TemplateMessage::contextinfo() const {
  // @@protoc_insertion_point(field_get:proto.TemplateMessage.contextInfo)
  return _internal_contextinfo();
}
inline void TemplateMessage::unsafe_arena_set_allocated_contextinfo(
    ::proto::ContextInfo* contextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextinfo_);
  }
  _impl_.contextinfo_ = contextinfo;
  if (contextinfo) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TemplateMessage.contextInfo)
}
inline ::proto::ContextInfo* TemplateMessage::release_contextinfo() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContextInfo* TemplateMessage::unsafe_arena_release_contextinfo() {
  // @@protoc_insertion_point(field_release:proto.TemplateMessage.contextInfo)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
  return temp;
}
inline ::proto::ContextInfo* TemplateMessage::_internal_mutable_contextinfo() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.contextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContextInfo>(GetArenaForAllocation());
    _impl_.contextinfo_ = p;
  }
  return _impl_.contextinfo_;
}
inline ::proto::ContextInfo* TemplateMessage::mutable_contextinfo() {
  ::proto::ContextInfo* _msg = _internal_mutable_contextinfo();
  // @@protoc_insertion_point(field_mutable:proto.TemplateMessage.contextInfo)
  return _msg;
}
inline void TemplateMessage::set_allocated_contextinfo(::proto::ContextInfo* contextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contextinfo_;
  }
  if (contextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contextinfo);
    if (message_arena != submessage_arena) {
      contextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.contextinfo_ = contextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.TemplateMessage.contextInfo)
}

// optional .proto.HydratedFourRowTemplate hydratedTemplate = 4;
inline bool TemplateMessage::_internal_has_hydratedtemplate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hydratedtemplate_ != nullptr);
  return value;
}
inline bool TemplateMessage::has_hydratedtemplate() const {
  return _internal_has_hydratedtemplate();
}
inline void TemplateMessage::clear_hydratedtemplate() {
  if (_impl_.hydratedtemplate_ != nullptr) _impl_.hydratedtemplate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::HydratedFourRowTemplate& TemplateMessage::_internal_hydratedtemplate() const {
  const ::proto::HydratedFourRowTemplate* p = _impl_.hydratedtemplate_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::HydratedFourRowTemplate&>(
      ::proto::_HydratedFourRowTemplate_default_instance_);
}
inline const ::proto::HydratedFourRowTemplate& TemplateMessage::hydratedtemplate() const {
  // @@protoc_insertion_point(field_get:proto.TemplateMessage.hydratedTemplate)
  return _internal_hydratedtemplate();
}
inline void TemplateMessage::unsafe_arena_set_allocated_hydratedtemplate(
    ::proto::HydratedFourRowTemplate* hydratedtemplate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hydratedtemplate_);
  }
  _impl_.hydratedtemplate_ = hydratedtemplate;
  if (hydratedtemplate) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TemplateMessage.hydratedTemplate)
}
inline ::proto::HydratedFourRowTemplate* TemplateMessage::release_hydratedtemplate() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::HydratedFourRowTemplate* temp = _impl_.hydratedtemplate_;
  _impl_.hydratedtemplate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::HydratedFourRowTemplate* TemplateMessage::unsafe_arena_release_hydratedtemplate() {
  // @@protoc_insertion_point(field_release:proto.TemplateMessage.hydratedTemplate)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::HydratedFourRowTemplate* temp = _impl_.hydratedtemplate_;
  _impl_.hydratedtemplate_ = nullptr;
  return temp;
}
inline ::proto::HydratedFourRowTemplate* TemplateMessage::_internal_mutable_hydratedtemplate() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.hydratedtemplate_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::HydratedFourRowTemplate>(GetArenaForAllocation());
    _impl_.hydratedtemplate_ = p;
  }
  return _impl_.hydratedtemplate_;
}
inline ::proto::HydratedFourRowTemplate* TemplateMessage::mutable_hydratedtemplate() {
  ::proto::HydratedFourRowTemplate* _msg = _internal_mutable_hydratedtemplate();
  // @@protoc_insertion_point(field_mutable:proto.TemplateMessage.hydratedTemplate)
  return _msg;
}
inline void TemplateMessage::set_allocated_hydratedtemplate(::proto::HydratedFourRowTemplate* hydratedtemplate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hydratedtemplate_;
  }
  if (hydratedtemplate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hydratedtemplate);
    if (message_arena != submessage_arena) {
      hydratedtemplate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hydratedtemplate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.hydratedtemplate_ = hydratedtemplate;
  // @@protoc_insertion_point(field_set_allocated:proto.TemplateMessage.hydratedTemplate)
}

// .proto.FourRowTemplate fourRowTemplate = 1;
inline bool TemplateMessage::_internal_has_fourrowtemplate() const {
  return format_case() == kFourRowTemplate;
}
inline bool TemplateMessage::has_fourrowtemplate() const {
  return _internal_has_fourrowtemplate();
}
inline void TemplateMessage::set_has_fourrowtemplate() {
  _impl_._oneof_case_[0] = kFourRowTemplate;
}
inline void TemplateMessage::clear_fourrowtemplate() {
  if (_internal_has_fourrowtemplate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.format_.fourrowtemplate_;
    }
    clear_has_format();
  }
}
inline ::proto::FourRowTemplate* TemplateMessage::release_fourrowtemplate() {
  // @@protoc_insertion_point(field_release:proto.TemplateMessage.fourRowTemplate)
  if (_internal_has_fourrowtemplate()) {
    clear_has_format();
    ::proto::FourRowTemplate* temp = _impl_.format_.fourrowtemplate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.format_.fourrowtemplate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::FourRowTemplate& TemplateMessage::_internal_fourrowtemplate() const {
  return _internal_has_fourrowtemplate()
      ? *_impl_.format_.fourrowtemplate_
      : reinterpret_cast< ::proto::FourRowTemplate&>(::proto::_FourRowTemplate_default_instance_);
}
inline const ::proto::FourRowTemplate& TemplateMessage::fourrowtemplate() const {
  // @@protoc_insertion_point(field_get:proto.TemplateMessage.fourRowTemplate)
  return _internal_fourrowtemplate();
}
inline ::proto::FourRowTemplate* TemplateMessage::unsafe_arena_release_fourrowtemplate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TemplateMessage.fourRowTemplate)
  if (_internal_has_fourrowtemplate()) {
    clear_has_format();
    ::proto::FourRowTemplate* temp = _impl_.format_.fourrowtemplate_;
    _impl_.format_.fourrowtemplate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TemplateMessage::unsafe_arena_set_allocated_fourrowtemplate(::proto::FourRowTemplate* fourrowtemplate) {
  clear_format();
  if (fourrowtemplate) {
    set_has_fourrowtemplate();
    _impl_.format_.fourrowtemplate_ = fourrowtemplate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TemplateMessage.fourRowTemplate)
}
inline ::proto::FourRowTemplate* TemplateMessage::_internal_mutable_fourrowtemplate() {
  if (!_internal_has_fourrowtemplate()) {
    clear_format();
    set_has_fourrowtemplate();
    _impl_.format_.fourrowtemplate_ = CreateMaybeMessage< ::proto::FourRowTemplate >(GetArenaForAllocation());
  }
  return _impl_.format_.fourrowtemplate_;
}
inline ::proto::FourRowTemplate* TemplateMessage::mutable_fourrowtemplate() {
  ::proto::FourRowTemplate* _msg = _internal_mutable_fourrowtemplate();
  // @@protoc_insertion_point(field_mutable:proto.TemplateMessage.fourRowTemplate)
  return _msg;
}

// .proto.HydratedFourRowTemplate hydratedFourRowTemplate = 2;
inline bool TemplateMessage::_internal_has_hydratedfourrowtemplate() const {
  return format_case() == kHydratedFourRowTemplate;
}
inline bool TemplateMessage::has_hydratedfourrowtemplate() const {
  return _internal_has_hydratedfourrowtemplate();
}
inline void TemplateMessage::set_has_hydratedfourrowtemplate() {
  _impl_._oneof_case_[0] = kHydratedFourRowTemplate;
}
inline void TemplateMessage::clear_hydratedfourrowtemplate() {
  if (_internal_has_hydratedfourrowtemplate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.format_.hydratedfourrowtemplate_;
    }
    clear_has_format();
  }
}
inline ::proto::HydratedFourRowTemplate* TemplateMessage::release_hydratedfourrowtemplate() {
  // @@protoc_insertion_point(field_release:proto.TemplateMessage.hydratedFourRowTemplate)
  if (_internal_has_hydratedfourrowtemplate()) {
    clear_has_format();
    ::proto::HydratedFourRowTemplate* temp = _impl_.format_.hydratedfourrowtemplate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.format_.hydratedfourrowtemplate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::HydratedFourRowTemplate& TemplateMessage::_internal_hydratedfourrowtemplate() const {
  return _internal_has_hydratedfourrowtemplate()
      ? *_impl_.format_.hydratedfourrowtemplate_
      : reinterpret_cast< ::proto::HydratedFourRowTemplate&>(::proto::_HydratedFourRowTemplate_default_instance_);
}
inline const ::proto::HydratedFourRowTemplate& TemplateMessage::hydratedfourrowtemplate() const {
  // @@protoc_insertion_point(field_get:proto.TemplateMessage.hydratedFourRowTemplate)
  return _internal_hydratedfourrowtemplate();
}
inline ::proto::HydratedFourRowTemplate* TemplateMessage::unsafe_arena_release_hydratedfourrowtemplate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TemplateMessage.hydratedFourRowTemplate)
  if (_internal_has_hydratedfourrowtemplate()) {
    clear_has_format();
    ::proto::HydratedFourRowTemplate* temp = _impl_.format_.hydratedfourrowtemplate_;
    _impl_.format_.hydratedfourrowtemplate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TemplateMessage::unsafe_arena_set_allocated_hydratedfourrowtemplate(::proto::HydratedFourRowTemplate* hydratedfourrowtemplate) {
  clear_format();
  if (hydratedfourrowtemplate) {
    set_has_hydratedfourrowtemplate();
    _impl_.format_.hydratedfourrowtemplate_ = hydratedfourrowtemplate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TemplateMessage.hydratedFourRowTemplate)
}
inline ::proto::HydratedFourRowTemplate* TemplateMessage::_internal_mutable_hydratedfourrowtemplate() {
  if (!_internal_has_hydratedfourrowtemplate()) {
    clear_format();
    set_has_hydratedfourrowtemplate();
    _impl_.format_.hydratedfourrowtemplate_ = CreateMaybeMessage< ::proto::HydratedFourRowTemplate >(GetArenaForAllocation());
  }
  return _impl_.format_.hydratedfourrowtemplate_;
}
inline ::proto::HydratedFourRowTemplate* TemplateMessage::mutable_hydratedfourrowtemplate() {
  ::proto::HydratedFourRowTemplate* _msg = _internal_mutable_hydratedfourrowtemplate();
  // @@protoc_insertion_point(field_mutable:proto.TemplateMessage.hydratedFourRowTemplate)
  return _msg;
}

inline bool TemplateMessage::has_format() const {
  return format_case() != FORMAT_NOT_SET;
}
inline void TemplateMessage::clear_has_format() {
  _impl_._oneof_case_[0] = FORMAT_NOT_SET;
}
inline TemplateMessage::FormatCase TemplateMessage::format_case() const {
  return TemplateMessage::FormatCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TemplateButtonReplyMessage

// optional string selectedId = 1;
inline bool TemplateButtonReplyMessage::_internal_has_selectedid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TemplateButtonReplyMessage::has_selectedid() const {
  return _internal_has_selectedid();
}
inline void TemplateButtonReplyMessage::clear_selectedid() {
  _impl_.selectedid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TemplateButtonReplyMessage::selectedid() const {
  // @@protoc_insertion_point(field_get:proto.TemplateButtonReplyMessage.selectedId)
  return _internal_selectedid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TemplateButtonReplyMessage::set_selectedid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.selectedid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.TemplateButtonReplyMessage.selectedId)
}
inline std::string* TemplateButtonReplyMessage::mutable_selectedid() {
  std::string* _s = _internal_mutable_selectedid();
  // @@protoc_insertion_point(field_mutable:proto.TemplateButtonReplyMessage.selectedId)
  return _s;
}
inline const std::string& TemplateButtonReplyMessage::_internal_selectedid() const {
  return _impl_.selectedid_.Get();
}
inline void TemplateButtonReplyMessage::_internal_set_selectedid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.selectedid_.Set(value, GetArenaForAllocation());
}
inline std::string* TemplateButtonReplyMessage::_internal_mutable_selectedid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.selectedid_.Mutable(GetArenaForAllocation());
}
inline std::string* TemplateButtonReplyMessage::release_selectedid() {
  // @@protoc_insertion_point(field_release:proto.TemplateButtonReplyMessage.selectedId)
  if (!_internal_has_selectedid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.selectedid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.selectedid_.IsDefault()) {
    _impl_.selectedid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TemplateButtonReplyMessage::set_allocated_selectedid(std::string* selectedid) {
  if (selectedid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.selectedid_.SetAllocated(selectedid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.selectedid_.IsDefault()) {
    _impl_.selectedid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.TemplateButtonReplyMessage.selectedId)
}

// optional string selectedDisplayText = 2;
inline bool TemplateButtonReplyMessage::_internal_has_selecteddisplaytext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TemplateButtonReplyMessage::has_selecteddisplaytext() const {
  return _internal_has_selecteddisplaytext();
}
inline void TemplateButtonReplyMessage::clear_selecteddisplaytext() {
  _impl_.selecteddisplaytext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TemplateButtonReplyMessage::selecteddisplaytext() const {
  // @@protoc_insertion_point(field_get:proto.TemplateButtonReplyMessage.selectedDisplayText)
  return _internal_selecteddisplaytext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TemplateButtonReplyMessage::set_selecteddisplaytext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.selecteddisplaytext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.TemplateButtonReplyMessage.selectedDisplayText)
}
inline std::string* TemplateButtonReplyMessage::mutable_selecteddisplaytext() {
  std::string* _s = _internal_mutable_selecteddisplaytext();
  // @@protoc_insertion_point(field_mutable:proto.TemplateButtonReplyMessage.selectedDisplayText)
  return _s;
}
inline const std::string& TemplateButtonReplyMessage::_internal_selecteddisplaytext() const {
  return _impl_.selecteddisplaytext_.Get();
}
inline void TemplateButtonReplyMessage::_internal_set_selecteddisplaytext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.selecteddisplaytext_.Set(value, GetArenaForAllocation());
}
inline std::string* TemplateButtonReplyMessage::_internal_mutable_selecteddisplaytext() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.selecteddisplaytext_.Mutable(GetArenaForAllocation());
}
inline std::string* TemplateButtonReplyMessage::release_selecteddisplaytext() {
  // @@protoc_insertion_point(field_release:proto.TemplateButtonReplyMessage.selectedDisplayText)
  if (!_internal_has_selecteddisplaytext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.selecteddisplaytext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.selecteddisplaytext_.IsDefault()) {
    _impl_.selecteddisplaytext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TemplateButtonReplyMessage::set_allocated_selecteddisplaytext(std::string* selecteddisplaytext) {
  if (selecteddisplaytext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.selecteddisplaytext_.SetAllocated(selecteddisplaytext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.selecteddisplaytext_.IsDefault()) {
    _impl_.selecteddisplaytext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.TemplateButtonReplyMessage.selectedDisplayText)
}

// optional .proto.ContextInfo contextInfo = 3;
inline bool TemplateButtonReplyMessage::_internal_has_contextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contextinfo_ != nullptr);
  return value;
}
inline bool TemplateButtonReplyMessage::has_contextinfo() const {
  return _internal_has_contextinfo();
}
inline void TemplateButtonReplyMessage::clear_contextinfo() {
  if (_impl_.contextinfo_ != nullptr) _impl_.contextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::proto::ContextInfo& TemplateButtonReplyMessage::_internal_contextinfo() const {
  const ::proto::ContextInfo* p = _impl_.contextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContextInfo&>(
      ::proto::_ContextInfo_default_instance_);
}
inline const ::proto::ContextInfo& TemplateButtonReplyMessage::contextinfo() const {
  // @@protoc_insertion_point(field_get:proto.TemplateButtonReplyMessage.contextInfo)
  return _internal_contextinfo();
}
inline void TemplateButtonReplyMessage::unsafe_arena_set_allocated_contextinfo(
    ::proto::ContextInfo* contextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextinfo_);
  }
  _impl_.contextinfo_ = contextinfo;
  if (contextinfo) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TemplateButtonReplyMessage.contextInfo)
}
inline ::proto::ContextInfo* TemplateButtonReplyMessage::release_contextinfo() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContextInfo* TemplateButtonReplyMessage::unsafe_arena_release_contextinfo() {
  // @@protoc_insertion_point(field_release:proto.TemplateButtonReplyMessage.contextInfo)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
  return temp;
}
inline ::proto::ContextInfo* TemplateButtonReplyMessage::_internal_mutable_contextinfo() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.contextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContextInfo>(GetArenaForAllocation());
    _impl_.contextinfo_ = p;
  }
  return _impl_.contextinfo_;
}
inline ::proto::ContextInfo* TemplateButtonReplyMessage::mutable_contextinfo() {
  ::proto::ContextInfo* _msg = _internal_mutable_contextinfo();
  // @@protoc_insertion_point(field_mutable:proto.TemplateButtonReplyMessage.contextInfo)
  return _msg;
}
inline void TemplateButtonReplyMessage::set_allocated_contextinfo(::proto::ContextInfo* contextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contextinfo_;
  }
  if (contextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contextinfo);
    if (message_arena != submessage_arena) {
      contextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.contextinfo_ = contextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.TemplateButtonReplyMessage.contextInfo)
}

// optional uint32 selectedIndex = 4;
inline bool TemplateButtonReplyMessage::_internal_has_selectedindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TemplateButtonReplyMessage::has_selectedindex() const {
  return _internal_has_selectedindex();
}
inline void TemplateButtonReplyMessage::clear_selectedindex() {
  _impl_.selectedindex_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t TemplateButtonReplyMessage::_internal_selectedindex() const {
  return _impl_.selectedindex_;
}
inline uint32_t TemplateButtonReplyMessage::selectedindex() const {
  // @@protoc_insertion_point(field_get:proto.TemplateButtonReplyMessage.selectedIndex)
  return _internal_selectedindex();
}
inline void TemplateButtonReplyMessage::_internal_set_selectedindex(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.selectedindex_ = value;
}
inline void TemplateButtonReplyMessage::set_selectedindex(uint32_t value) {
  _internal_set_selectedindex(value);
  // @@protoc_insertion_point(field_set:proto.TemplateButtonReplyMessage.selectedIndex)
}

// -------------------------------------------------------------------

// CatalogSnapshot

// optional .proto.ImageMessage catalogImage = 1;
inline bool CatalogSnapshot::_internal_has_catalogimage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.catalogimage_ != nullptr);
  return value;
}
inline bool CatalogSnapshot::has_catalogimage() const {
  return _internal_has_catalogimage();
}
inline void CatalogSnapshot::clear_catalogimage() {
  if (_impl_.catalogimage_ != nullptr) _impl_.catalogimage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::proto::ImageMessage& CatalogSnapshot::_internal_catalogimage() const {
  const ::proto::ImageMessage* p = _impl_.catalogimage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ImageMessage&>(
      ::proto::_ImageMessage_default_instance_);
}
inline const ::proto::ImageMessage& CatalogSnapshot::catalogimage() const {
  // @@protoc_insertion_point(field_get:proto.CatalogSnapshot.catalogImage)
  return _internal_catalogimage();
}
inline void CatalogSnapshot::unsafe_arena_set_allocated_catalogimage(
    ::proto::ImageMessage* catalogimage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.catalogimage_);
  }
  _impl_.catalogimage_ = catalogimage;
  if (catalogimage) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.CatalogSnapshot.catalogImage)
}
inline ::proto::ImageMessage* CatalogSnapshot::release_catalogimage() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::ImageMessage* temp = _impl_.catalogimage_;
  _impl_.catalogimage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ImageMessage* CatalogSnapshot::unsafe_arena_release_catalogimage() {
  // @@protoc_insertion_point(field_release:proto.CatalogSnapshot.catalogImage)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::ImageMessage* temp = _impl_.catalogimage_;
  _impl_.catalogimage_ = nullptr;
  return temp;
}
inline ::proto::ImageMessage* CatalogSnapshot::_internal_mutable_catalogimage() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.catalogimage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ImageMessage>(GetArenaForAllocation());
    _impl_.catalogimage_ = p;
  }
  return _impl_.catalogimage_;
}
inline ::proto::ImageMessage* CatalogSnapshot::mutable_catalogimage() {
  ::proto::ImageMessage* _msg = _internal_mutable_catalogimage();
  // @@protoc_insertion_point(field_mutable:proto.CatalogSnapshot.catalogImage)
  return _msg;
}
inline void CatalogSnapshot::set_allocated_catalogimage(::proto::ImageMessage* catalogimage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.catalogimage_;
  }
  if (catalogimage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(catalogimage);
    if (message_arena != submessage_arena) {
      catalogimage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, catalogimage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.catalogimage_ = catalogimage;
  // @@protoc_insertion_point(field_set_allocated:proto.CatalogSnapshot.catalogImage)
}

// optional string title = 2;
inline bool CatalogSnapshot::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CatalogSnapshot::has_title() const {
  return _internal_has_title();
}
inline void CatalogSnapshot::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CatalogSnapshot::title() const {
  // @@protoc_insertion_point(field_get:proto.CatalogSnapshot.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CatalogSnapshot::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.CatalogSnapshot.title)
}
inline std::string* CatalogSnapshot::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:proto.CatalogSnapshot.title)
  return _s;
}
inline const std::string& CatalogSnapshot::_internal_title() const {
  return _impl_.title_.Get();
}
inline void CatalogSnapshot::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* CatalogSnapshot::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* CatalogSnapshot::release_title() {
  // @@protoc_insertion_point(field_release:proto.CatalogSnapshot.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CatalogSnapshot::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.CatalogSnapshot.title)
}

// optional string description = 3;
inline bool CatalogSnapshot::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CatalogSnapshot::has_description() const {
  return _internal_has_description();
}
inline void CatalogSnapshot::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CatalogSnapshot::description() const {
  // @@protoc_insertion_point(field_get:proto.CatalogSnapshot.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CatalogSnapshot::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.CatalogSnapshot.description)
}
inline std::string* CatalogSnapshot::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:proto.CatalogSnapshot.description)
  return _s;
}
inline const std::string& CatalogSnapshot::_internal_description() const {
  return _impl_.description_.Get();
}
inline void CatalogSnapshot::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* CatalogSnapshot::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* CatalogSnapshot::release_description() {
  // @@protoc_insertion_point(field_release:proto.CatalogSnapshot.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CatalogSnapshot::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.CatalogSnapshot.description)
}

// -------------------------------------------------------------------

// ProductSnapshot

// optional .proto.ImageMessage productImage = 1;
inline bool ProductSnapshot::_internal_has_productimage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.productimage_ != nullptr);
  return value;
}
inline bool ProductSnapshot::has_productimage() const {
  return _internal_has_productimage();
}
inline void ProductSnapshot::clear_productimage() {
  if (_impl_.productimage_ != nullptr) _impl_.productimage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::proto::ImageMessage& ProductSnapshot::_internal_productimage() const {
  const ::proto::ImageMessage* p = _impl_.productimage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ImageMessage&>(
      ::proto::_ImageMessage_default_instance_);
}
inline const ::proto::ImageMessage& ProductSnapshot::productimage() const {
  // @@protoc_insertion_point(field_get:proto.ProductSnapshot.productImage)
  return _internal_productimage();
}
inline void ProductSnapshot::unsafe_arena_set_allocated_productimage(
    ::proto::ImageMessage* productimage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.productimage_);
  }
  _impl_.productimage_ = productimage;
  if (productimage) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ProductSnapshot.productImage)
}
inline ::proto::ImageMessage* ProductSnapshot::release_productimage() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::proto::ImageMessage* temp = _impl_.productimage_;
  _impl_.productimage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ImageMessage* ProductSnapshot::unsafe_arena_release_productimage() {
  // @@protoc_insertion_point(field_release:proto.ProductSnapshot.productImage)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::proto::ImageMessage* temp = _impl_.productimage_;
  _impl_.productimage_ = nullptr;
  return temp;
}
inline ::proto::ImageMessage* ProductSnapshot::_internal_mutable_productimage() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.productimage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ImageMessage>(GetArenaForAllocation());
    _impl_.productimage_ = p;
  }
  return _impl_.productimage_;
}
inline ::proto::ImageMessage* ProductSnapshot::mutable_productimage() {
  ::proto::ImageMessage* _msg = _internal_mutable_productimage();
  // @@protoc_insertion_point(field_mutable:proto.ProductSnapshot.productImage)
  return _msg;
}
inline void ProductSnapshot::set_allocated_productimage(::proto::ImageMessage* productimage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.productimage_;
  }
  if (productimage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(productimage);
    if (message_arena != submessage_arena) {
      productimage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, productimage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.productimage_ = productimage;
  // @@protoc_insertion_point(field_set_allocated:proto.ProductSnapshot.productImage)
}

// optional string productId = 2;
inline bool ProductSnapshot::_internal_has_productid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProductSnapshot::has_productid() const {
  return _internal_has_productid();
}
inline void ProductSnapshot::clear_productid() {
  _impl_.productid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProductSnapshot::productid() const {
  // @@protoc_insertion_point(field_get:proto.ProductSnapshot.productId)
  return _internal_productid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProductSnapshot::set_productid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.productid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ProductSnapshot.productId)
}
inline std::string* ProductSnapshot::mutable_productid() {
  std::string* _s = _internal_mutable_productid();
  // @@protoc_insertion_point(field_mutable:proto.ProductSnapshot.productId)
  return _s;
}
inline const std::string& ProductSnapshot::_internal_productid() const {
  return _impl_.productid_.Get();
}
inline void ProductSnapshot::_internal_set_productid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.productid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductSnapshot::_internal_mutable_productid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.productid_.Mutable(GetArenaForAllocation());
}
inline std::string* ProductSnapshot::release_productid() {
  // @@protoc_insertion_point(field_release:proto.ProductSnapshot.productId)
  if (!_internal_has_productid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.productid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.productid_.IsDefault()) {
    _impl_.productid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProductSnapshot::set_allocated_productid(std::string* productid) {
  if (productid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.productid_.SetAllocated(productid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.productid_.IsDefault()) {
    _impl_.productid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ProductSnapshot.productId)
}

// optional string title = 3;
inline bool ProductSnapshot::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ProductSnapshot::has_title() const {
  return _internal_has_title();
}
inline void ProductSnapshot::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ProductSnapshot::title() const {
  // @@protoc_insertion_point(field_get:proto.ProductSnapshot.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProductSnapshot::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ProductSnapshot.title)
}
inline std::string* ProductSnapshot::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:proto.ProductSnapshot.title)
  return _s;
}
inline const std::string& ProductSnapshot::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ProductSnapshot::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductSnapshot::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* ProductSnapshot::release_title() {
  // @@protoc_insertion_point(field_release:proto.ProductSnapshot.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProductSnapshot::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ProductSnapshot.title)
}

// optional string description = 4;
inline bool ProductSnapshot::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ProductSnapshot::has_description() const {
  return _internal_has_description();
}
inline void ProductSnapshot::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ProductSnapshot::description() const {
  // @@protoc_insertion_point(field_get:proto.ProductSnapshot.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProductSnapshot::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ProductSnapshot.description)
}
inline std::string* ProductSnapshot::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:proto.ProductSnapshot.description)
  return _s;
}
inline const std::string& ProductSnapshot::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ProductSnapshot::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductSnapshot::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ProductSnapshot::release_description() {
  // @@protoc_insertion_point(field_release:proto.ProductSnapshot.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProductSnapshot::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ProductSnapshot.description)
}

// optional string currencyCode = 5;
inline bool ProductSnapshot::_internal_has_currencycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ProductSnapshot::has_currencycode() const {
  return _internal_has_currencycode();
}
inline void ProductSnapshot::clear_currencycode() {
  _impl_.currencycode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ProductSnapshot::currencycode() const {
  // @@protoc_insertion_point(field_get:proto.ProductSnapshot.currencyCode)
  return _internal_currencycode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProductSnapshot::set_currencycode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.currencycode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ProductSnapshot.currencyCode)
}
inline std::string* ProductSnapshot::mutable_currencycode() {
  std::string* _s = _internal_mutable_currencycode();
  // @@protoc_insertion_point(field_mutable:proto.ProductSnapshot.currencyCode)
  return _s;
}
inline const std::string& ProductSnapshot::_internal_currencycode() const {
  return _impl_.currencycode_.Get();
}
inline void ProductSnapshot::_internal_set_currencycode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.currencycode_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductSnapshot::_internal_mutable_currencycode() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.currencycode_.Mutable(GetArenaForAllocation());
}
inline std::string* ProductSnapshot::release_currencycode() {
  // @@protoc_insertion_point(field_release:proto.ProductSnapshot.currencyCode)
  if (!_internal_has_currencycode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.currencycode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currencycode_.IsDefault()) {
    _impl_.currencycode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProductSnapshot::set_allocated_currencycode(std::string* currencycode) {
  if (currencycode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.currencycode_.SetAllocated(currencycode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currencycode_.IsDefault()) {
    _impl_.currencycode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ProductSnapshot.currencyCode)
}

// optional int64 priceAmount1000 = 6;
inline bool ProductSnapshot::_internal_has_priceamount1000() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ProductSnapshot::has_priceamount1000() const {
  return _internal_has_priceamount1000();
}
inline void ProductSnapshot::clear_priceamount1000() {
  _impl_.priceamount1000_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t ProductSnapshot::_internal_priceamount1000() const {
  return _impl_.priceamount1000_;
}
inline int64_t ProductSnapshot::priceamount1000() const {
  // @@protoc_insertion_point(field_get:proto.ProductSnapshot.priceAmount1000)
  return _internal_priceamount1000();
}
inline void ProductSnapshot::_internal_set_priceamount1000(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.priceamount1000_ = value;
}
inline void ProductSnapshot::set_priceamount1000(int64_t value) {
  _internal_set_priceamount1000(value);
  // @@protoc_insertion_point(field_set:proto.ProductSnapshot.priceAmount1000)
}

// optional string retailerId = 7;
inline bool ProductSnapshot::_internal_has_retailerid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ProductSnapshot::has_retailerid() const {
  return _internal_has_retailerid();
}
inline void ProductSnapshot::clear_retailerid() {
  _impl_.retailerid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ProductSnapshot::retailerid() const {
  // @@protoc_insertion_point(field_get:proto.ProductSnapshot.retailerId)
  return _internal_retailerid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProductSnapshot::set_retailerid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.retailerid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ProductSnapshot.retailerId)
}
inline std::string* ProductSnapshot::mutable_retailerid() {
  std::string* _s = _internal_mutable_retailerid();
  // @@protoc_insertion_point(field_mutable:proto.ProductSnapshot.retailerId)
  return _s;
}
inline const std::string& ProductSnapshot::_internal_retailerid() const {
  return _impl_.retailerid_.Get();
}
inline void ProductSnapshot::_internal_set_retailerid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.retailerid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductSnapshot::_internal_mutable_retailerid() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.retailerid_.Mutable(GetArenaForAllocation());
}
inline std::string* ProductSnapshot::release_retailerid() {
  // @@protoc_insertion_point(field_release:proto.ProductSnapshot.retailerId)
  if (!_internal_has_retailerid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.retailerid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.retailerid_.IsDefault()) {
    _impl_.retailerid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProductSnapshot::set_allocated_retailerid(std::string* retailerid) {
  if (retailerid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.retailerid_.SetAllocated(retailerid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.retailerid_.IsDefault()) {
    _impl_.retailerid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ProductSnapshot.retailerId)
}

// optional string url = 8;
inline bool ProductSnapshot::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ProductSnapshot::has_url() const {
  return _internal_has_url();
}
inline void ProductSnapshot::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ProductSnapshot::url() const {
  // @@protoc_insertion_point(field_get:proto.ProductSnapshot.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProductSnapshot::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ProductSnapshot.url)
}
inline std::string* ProductSnapshot::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:proto.ProductSnapshot.url)
  return _s;
}
inline const std::string& ProductSnapshot::_internal_url() const {
  return _impl_.url_.Get();
}
inline void ProductSnapshot::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductSnapshot::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* ProductSnapshot::release_url() {
  // @@protoc_insertion_point(field_release:proto.ProductSnapshot.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProductSnapshot::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ProductSnapshot.url)
}

// optional uint32 productImageCount = 9;
inline bool ProductSnapshot::_internal_has_productimagecount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ProductSnapshot::has_productimagecount() const {
  return _internal_has_productimagecount();
}
inline void ProductSnapshot::clear_productimagecount() {
  _impl_.productimagecount_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t ProductSnapshot::_internal_productimagecount() const {
  return _impl_.productimagecount_;
}
inline uint32_t ProductSnapshot::productimagecount() const {
  // @@protoc_insertion_point(field_get:proto.ProductSnapshot.productImageCount)
  return _internal_productimagecount();
}
inline void ProductSnapshot::_internal_set_productimagecount(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.productimagecount_ = value;
}
inline void ProductSnapshot::set_productimagecount(uint32_t value) {
  _internal_set_productimagecount(value);
  // @@protoc_insertion_point(field_set:proto.ProductSnapshot.productImageCount)
}

// optional string firstImageId = 11;
inline bool ProductSnapshot::_internal_has_firstimageid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ProductSnapshot::has_firstimageid() const {
  return _internal_has_firstimageid();
}
inline void ProductSnapshot::clear_firstimageid() {
  _impl_.firstimageid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ProductSnapshot::firstimageid() const {
  // @@protoc_insertion_point(field_get:proto.ProductSnapshot.firstImageId)
  return _internal_firstimageid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProductSnapshot::set_firstimageid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.firstimageid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ProductSnapshot.firstImageId)
}
inline std::string* ProductSnapshot::mutable_firstimageid() {
  std::string* _s = _internal_mutable_firstimageid();
  // @@protoc_insertion_point(field_mutable:proto.ProductSnapshot.firstImageId)
  return _s;
}
inline const std::string& ProductSnapshot::_internal_firstimageid() const {
  return _impl_.firstimageid_.Get();
}
inline void ProductSnapshot::_internal_set_firstimageid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.firstimageid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductSnapshot::_internal_mutable_firstimageid() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.firstimageid_.Mutable(GetArenaForAllocation());
}
inline std::string* ProductSnapshot::release_firstimageid() {
  // @@protoc_insertion_point(field_release:proto.ProductSnapshot.firstImageId)
  if (!_internal_has_firstimageid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.firstimageid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.firstimageid_.IsDefault()) {
    _impl_.firstimageid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProductSnapshot::set_allocated_firstimageid(std::string* firstimageid) {
  if (firstimageid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.firstimageid_.SetAllocated(firstimageid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.firstimageid_.IsDefault()) {
    _impl_.firstimageid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ProductSnapshot.firstImageId)
}

// -------------------------------------------------------------------

// ProductMessage

// optional .proto.ProductSnapshot product = 1;
inline bool ProductMessage::_internal_has_product() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.product_ != nullptr);
  return value;
}
inline bool ProductMessage::has_product() const {
  return _internal_has_product();
}
inline void ProductMessage::clear_product() {
  if (_impl_.product_ != nullptr) _impl_.product_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::ProductSnapshot& ProductMessage::_internal_product() const {
  const ::proto::ProductSnapshot* p = _impl_.product_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ProductSnapshot&>(
      ::proto::_ProductSnapshot_default_instance_);
}
inline const ::proto::ProductSnapshot& ProductMessage::product() const {
  // @@protoc_insertion_point(field_get:proto.ProductMessage.product)
  return _internal_product();
}
inline void ProductMessage::unsafe_arena_set_allocated_product(
    ::proto::ProductSnapshot* product) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.product_);
  }
  _impl_.product_ = product;
  if (product) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ProductMessage.product)
}
inline ::proto::ProductSnapshot* ProductMessage::release_product() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::ProductSnapshot* temp = _impl_.product_;
  _impl_.product_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ProductSnapshot* ProductMessage::unsafe_arena_release_product() {
  // @@protoc_insertion_point(field_release:proto.ProductMessage.product)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::ProductSnapshot* temp = _impl_.product_;
  _impl_.product_ = nullptr;
  return temp;
}
inline ::proto::ProductSnapshot* ProductMessage::_internal_mutable_product() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.product_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ProductSnapshot>(GetArenaForAllocation());
    _impl_.product_ = p;
  }
  return _impl_.product_;
}
inline ::proto::ProductSnapshot* ProductMessage::mutable_product() {
  ::proto::ProductSnapshot* _msg = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:proto.ProductMessage.product)
  return _msg;
}
inline void ProductMessage::set_allocated_product(::proto::ProductSnapshot* product) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.product_;
  }
  if (product) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(product);
    if (message_arena != submessage_arena) {
      product = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, product, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.product_ = product;
  // @@protoc_insertion_point(field_set_allocated:proto.ProductMessage.product)
}

// optional string businessOwnerJid = 2;
inline bool ProductMessage::_internal_has_businessownerjid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProductMessage::has_businessownerjid() const {
  return _internal_has_businessownerjid();
}
inline void ProductMessage::clear_businessownerjid() {
  _impl_.businessownerjid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProductMessage::businessownerjid() const {
  // @@protoc_insertion_point(field_get:proto.ProductMessage.businessOwnerJid)
  return _internal_businessownerjid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProductMessage::set_businessownerjid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.businessownerjid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ProductMessage.businessOwnerJid)
}
inline std::string* ProductMessage::mutable_businessownerjid() {
  std::string* _s = _internal_mutable_businessownerjid();
  // @@protoc_insertion_point(field_mutable:proto.ProductMessage.businessOwnerJid)
  return _s;
}
inline const std::string& ProductMessage::_internal_businessownerjid() const {
  return _impl_.businessownerjid_.Get();
}
inline void ProductMessage::_internal_set_businessownerjid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.businessownerjid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductMessage::_internal_mutable_businessownerjid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.businessownerjid_.Mutable(GetArenaForAllocation());
}
inline std::string* ProductMessage::release_businessownerjid() {
  // @@protoc_insertion_point(field_release:proto.ProductMessage.businessOwnerJid)
  if (!_internal_has_businessownerjid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.businessownerjid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.businessownerjid_.IsDefault()) {
    _impl_.businessownerjid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProductMessage::set_allocated_businessownerjid(std::string* businessownerjid) {
  if (businessownerjid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.businessownerjid_.SetAllocated(businessownerjid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.businessownerjid_.IsDefault()) {
    _impl_.businessownerjid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ProductMessage.businessOwnerJid)
}

// optional .proto.CatalogSnapshot catalog = 4;
inline bool ProductMessage::_internal_has_catalog() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.catalog_ != nullptr);
  return value;
}
inline bool ProductMessage::has_catalog() const {
  return _internal_has_catalog();
}
inline void ProductMessage::clear_catalog() {
  if (_impl_.catalog_ != nullptr) _impl_.catalog_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::proto::CatalogSnapshot& ProductMessage::_internal_catalog() const {
  const ::proto::CatalogSnapshot* p = _impl_.catalog_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::CatalogSnapshot&>(
      ::proto::_CatalogSnapshot_default_instance_);
}
inline const ::proto::CatalogSnapshot& ProductMessage::catalog() const {
  // @@protoc_insertion_point(field_get:proto.ProductMessage.catalog)
  return _internal_catalog();
}
inline void ProductMessage::unsafe_arena_set_allocated_catalog(
    ::proto::CatalogSnapshot* catalog) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.catalog_);
  }
  _impl_.catalog_ = catalog;
  if (catalog) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ProductMessage.catalog)
}
inline ::proto::CatalogSnapshot* ProductMessage::release_catalog() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::CatalogSnapshot* temp = _impl_.catalog_;
  _impl_.catalog_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::CatalogSnapshot* ProductMessage::unsafe_arena_release_catalog() {
  // @@protoc_insertion_point(field_release:proto.ProductMessage.catalog)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::CatalogSnapshot* temp = _impl_.catalog_;
  _impl_.catalog_ = nullptr;
  return temp;
}
inline ::proto::CatalogSnapshot* ProductMessage::_internal_mutable_catalog() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.catalog_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::CatalogSnapshot>(GetArenaForAllocation());
    _impl_.catalog_ = p;
  }
  return _impl_.catalog_;
}
inline ::proto::CatalogSnapshot* ProductMessage::mutable_catalog() {
  ::proto::CatalogSnapshot* _msg = _internal_mutable_catalog();
  // @@protoc_insertion_point(field_mutable:proto.ProductMessage.catalog)
  return _msg;
}
inline void ProductMessage::set_allocated_catalog(::proto::CatalogSnapshot* catalog) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.catalog_;
  }
  if (catalog) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(catalog);
    if (message_arena != submessage_arena) {
      catalog = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, catalog, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.catalog_ = catalog;
  // @@protoc_insertion_point(field_set_allocated:proto.ProductMessage.catalog)
}

// optional .proto.ContextInfo contextInfo = 17;
inline bool ProductMessage::_internal_has_contextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contextinfo_ != nullptr);
  return value;
}
inline bool ProductMessage::has_contextinfo() const {
  return _internal_has_contextinfo();
}
inline void ProductMessage::clear_contextinfo() {
  if (_impl_.contextinfo_ != nullptr) _impl_.contextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::proto::ContextInfo& ProductMessage::_internal_contextinfo() const {
  const ::proto::ContextInfo* p = _impl_.contextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContextInfo&>(
      ::proto::_ContextInfo_default_instance_);
}
inline const ::proto::ContextInfo& ProductMessage::contextinfo() const {
  // @@protoc_insertion_point(field_get:proto.ProductMessage.contextInfo)
  return _internal_contextinfo();
}
inline void ProductMessage::unsafe_arena_set_allocated_contextinfo(
    ::proto::ContextInfo* contextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextinfo_);
  }
  _impl_.contextinfo_ = contextinfo;
  if (contextinfo) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ProductMessage.contextInfo)
}
inline ::proto::ContextInfo* ProductMessage::release_contextinfo() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContextInfo* ProductMessage::unsafe_arena_release_contextinfo() {
  // @@protoc_insertion_point(field_release:proto.ProductMessage.contextInfo)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
  return temp;
}
inline ::proto::ContextInfo* ProductMessage::_internal_mutable_contextinfo() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.contextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContextInfo>(GetArenaForAllocation());
    _impl_.contextinfo_ = p;
  }
  return _impl_.contextinfo_;
}
inline ::proto::ContextInfo* ProductMessage::mutable_contextinfo() {
  ::proto::ContextInfo* _msg = _internal_mutable_contextinfo();
  // @@protoc_insertion_point(field_mutable:proto.ProductMessage.contextInfo)
  return _msg;
}
inline void ProductMessage::set_allocated_contextinfo(::proto::ContextInfo* contextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contextinfo_;
  }
  if (contextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contextinfo);
    if (message_arena != submessage_arena) {
      contextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.contextinfo_ = contextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.ProductMessage.contextInfo)
}

// -------------------------------------------------------------------

// OrderMessage

// optional string orderId = 1;
inline bool OrderMessage::_internal_has_orderid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OrderMessage::has_orderid() const {
  return _internal_has_orderid();
}
inline void OrderMessage::clear_orderid() {
  _impl_.orderid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OrderMessage::orderid() const {
  // @@protoc_insertion_point(field_get:proto.OrderMessage.orderId)
  return _internal_orderid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderMessage::set_orderid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.orderid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.OrderMessage.orderId)
}
inline std::string* OrderMessage::mutable_orderid() {
  std::string* _s = _internal_mutable_orderid();
  // @@protoc_insertion_point(field_mutable:proto.OrderMessage.orderId)
  return _s;
}
inline const std::string& OrderMessage::_internal_orderid() const {
  return _impl_.orderid_.Get();
}
inline void OrderMessage::_internal_set_orderid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.orderid_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderMessage::_internal_mutable_orderid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.orderid_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderMessage::release_orderid() {
  // @@protoc_insertion_point(field_release:proto.OrderMessage.orderId)
  if (!_internal_has_orderid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.orderid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.orderid_.IsDefault()) {
    _impl_.orderid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OrderMessage::set_allocated_orderid(std::string* orderid) {
  if (orderid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.orderid_.SetAllocated(orderid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.orderid_.IsDefault()) {
    _impl_.orderid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.OrderMessage.orderId)
}

// optional bytes thumbnail = 2;
inline bool OrderMessage::_internal_has_thumbnail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OrderMessage::has_thumbnail() const {
  return _internal_has_thumbnail();
}
inline void OrderMessage::clear_thumbnail() {
  _impl_.thumbnail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OrderMessage::thumbnail() const {
  // @@protoc_insertion_point(field_get:proto.OrderMessage.thumbnail)
  return _internal_thumbnail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderMessage::set_thumbnail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.thumbnail_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.OrderMessage.thumbnail)
}
inline std::string* OrderMessage::mutable_thumbnail() {
  std::string* _s = _internal_mutable_thumbnail();
  // @@protoc_insertion_point(field_mutable:proto.OrderMessage.thumbnail)
  return _s;
}
inline const std::string& OrderMessage::_internal_thumbnail() const {
  return _impl_.thumbnail_.Get();
}
inline void OrderMessage::_internal_set_thumbnail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.thumbnail_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderMessage::_internal_mutable_thumbnail() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.thumbnail_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderMessage::release_thumbnail() {
  // @@protoc_insertion_point(field_release:proto.OrderMessage.thumbnail)
  if (!_internal_has_thumbnail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.thumbnail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnail_.IsDefault()) {
    _impl_.thumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OrderMessage::set_allocated_thumbnail(std::string* thumbnail) {
  if (thumbnail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.thumbnail_.SetAllocated(thumbnail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnail_.IsDefault()) {
    _impl_.thumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.OrderMessage.thumbnail)
}

// optional int32 itemCount = 3;
inline bool OrderMessage::_internal_has_itemcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool OrderMessage::has_itemcount() const {
  return _internal_has_itemcount();
}
inline void OrderMessage::clear_itemcount() {
  _impl_.itemcount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t OrderMessage::_internal_itemcount() const {
  return _impl_.itemcount_;
}
inline int32_t OrderMessage::itemcount() const {
  // @@protoc_insertion_point(field_get:proto.OrderMessage.itemCount)
  return _internal_itemcount();
}
inline void OrderMessage::_internal_set_itemcount(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.itemcount_ = value;
}
inline void OrderMessage::set_itemcount(int32_t value) {
  _internal_set_itemcount(value);
  // @@protoc_insertion_point(field_set:proto.OrderMessage.itemCount)
}

// optional .proto.OrderMessage.OrderMessageOrderStatus status = 4;
inline bool OrderMessage::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool OrderMessage::has_status() const {
  return _internal_has_status();
}
inline void OrderMessage::clear_status() {
  _impl_.status_ = 1;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::proto::OrderMessage_OrderMessageOrderStatus OrderMessage::_internal_status() const {
  return static_cast< ::proto::OrderMessage_OrderMessageOrderStatus >(_impl_.status_);
}
inline ::proto::OrderMessage_OrderMessageOrderStatus OrderMessage::status() const {
  // @@protoc_insertion_point(field_get:proto.OrderMessage.status)
  return _internal_status();
}
inline void OrderMessage::_internal_set_status(::proto::OrderMessage_OrderMessageOrderStatus value) {
  assert(::proto::OrderMessage_OrderMessageOrderStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.status_ = value;
}
inline void OrderMessage::set_status(::proto::OrderMessage_OrderMessageOrderStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:proto.OrderMessage.status)
}

// optional .proto.OrderMessage.OrderMessageOrderSurface surface = 5;
inline bool OrderMessage::_internal_has_surface() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool OrderMessage::has_surface() const {
  return _internal_has_surface();
}
inline void OrderMessage::clear_surface() {
  _impl_.surface_ = 1;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::proto::OrderMessage_OrderMessageOrderSurface OrderMessage::_internal_surface() const {
  return static_cast< ::proto::OrderMessage_OrderMessageOrderSurface >(_impl_.surface_);
}
inline ::proto::OrderMessage_OrderMessageOrderSurface OrderMessage::surface() const {
  // @@protoc_insertion_point(field_get:proto.OrderMessage.surface)
  return _internal_surface();
}
inline void OrderMessage::_internal_set_surface(::proto::OrderMessage_OrderMessageOrderSurface value) {
  assert(::proto::OrderMessage_OrderMessageOrderSurface_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.surface_ = value;
}
inline void OrderMessage::set_surface(::proto::OrderMessage_OrderMessageOrderSurface value) {
  _internal_set_surface(value);
  // @@protoc_insertion_point(field_set:proto.OrderMessage.surface)
}

// optional string message = 6;
inline bool OrderMessage::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OrderMessage::has_message() const {
  return _internal_has_message();
}
inline void OrderMessage::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& OrderMessage::message() const {
  // @@protoc_insertion_point(field_get:proto.OrderMessage.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderMessage::set_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.OrderMessage.message)
}
inline std::string* OrderMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:proto.OrderMessage.message)
  return _s;
}
inline const std::string& OrderMessage::_internal_message() const {
  return _impl_.message_.Get();
}
inline void OrderMessage::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderMessage::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderMessage::release_message() {
  // @@protoc_insertion_point(field_release:proto.OrderMessage.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OrderMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.OrderMessage.message)
}

// optional string orderTitle = 7;
inline bool OrderMessage::_internal_has_ordertitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool OrderMessage::has_ordertitle() const {
  return _internal_has_ordertitle();
}
inline void OrderMessage::clear_ordertitle() {
  _impl_.ordertitle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& OrderMessage::ordertitle() const {
  // @@protoc_insertion_point(field_get:proto.OrderMessage.orderTitle)
  return _internal_ordertitle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderMessage::set_ordertitle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.ordertitle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.OrderMessage.orderTitle)
}
inline std::string* OrderMessage::mutable_ordertitle() {
  std::string* _s = _internal_mutable_ordertitle();
  // @@protoc_insertion_point(field_mutable:proto.OrderMessage.orderTitle)
  return _s;
}
inline const std::string& OrderMessage::_internal_ordertitle() const {
  return _impl_.ordertitle_.Get();
}
inline void OrderMessage::_internal_set_ordertitle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ordertitle_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderMessage::_internal_mutable_ordertitle() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.ordertitle_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderMessage::release_ordertitle() {
  // @@protoc_insertion_point(field_release:proto.OrderMessage.orderTitle)
  if (!_internal_has_ordertitle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.ordertitle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ordertitle_.IsDefault()) {
    _impl_.ordertitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OrderMessage::set_allocated_ordertitle(std::string* ordertitle) {
  if (ordertitle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.ordertitle_.SetAllocated(ordertitle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ordertitle_.IsDefault()) {
    _impl_.ordertitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.OrderMessage.orderTitle)
}

// optional string sellerJid = 8;
inline bool OrderMessage::_internal_has_sellerjid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool OrderMessage::has_sellerjid() const {
  return _internal_has_sellerjid();
}
inline void OrderMessage::clear_sellerjid() {
  _impl_.sellerjid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& OrderMessage::sellerjid() const {
  // @@protoc_insertion_point(field_get:proto.OrderMessage.sellerJid)
  return _internal_sellerjid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderMessage::set_sellerjid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.sellerjid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.OrderMessage.sellerJid)
}
inline std::string* OrderMessage::mutable_sellerjid() {
  std::string* _s = _internal_mutable_sellerjid();
  // @@protoc_insertion_point(field_mutable:proto.OrderMessage.sellerJid)
  return _s;
}
inline const std::string& OrderMessage::_internal_sellerjid() const {
  return _impl_.sellerjid_.Get();
}
inline void OrderMessage::_internal_set_sellerjid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sellerjid_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderMessage::_internal_mutable_sellerjid() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.sellerjid_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderMessage::release_sellerjid() {
  // @@protoc_insertion_point(field_release:proto.OrderMessage.sellerJid)
  if (!_internal_has_sellerjid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.sellerjid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sellerjid_.IsDefault()) {
    _impl_.sellerjid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OrderMessage::set_allocated_sellerjid(std::string* sellerjid) {
  if (sellerjid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.sellerjid_.SetAllocated(sellerjid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sellerjid_.IsDefault()) {
    _impl_.sellerjid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.OrderMessage.sellerJid)
}

// optional string token = 9;
inline bool OrderMessage::_internal_has_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool OrderMessage::has_token() const {
  return _internal_has_token();
}
inline void OrderMessage::clear_token() {
  _impl_.token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& OrderMessage::token() const {
  // @@protoc_insertion_point(field_get:proto.OrderMessage.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderMessage::set_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.OrderMessage.token)
}
inline std::string* OrderMessage::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:proto.OrderMessage.token)
  return _s;
}
inline const std::string& OrderMessage::_internal_token() const {
  return _impl_.token_.Get();
}
inline void OrderMessage::_internal_set_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderMessage::_internal_mutable_token() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderMessage::release_token() {
  // @@protoc_insertion_point(field_release:proto.OrderMessage.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OrderMessage::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.OrderMessage.token)
}

// optional int64 totalAmount1000 = 10;
inline bool OrderMessage::_internal_has_totalamount1000() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool OrderMessage::has_totalamount1000() const {
  return _internal_has_totalamount1000();
}
inline void OrderMessage::clear_totalamount1000() {
  _impl_.totalamount1000_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t OrderMessage::_internal_totalamount1000() const {
  return _impl_.totalamount1000_;
}
inline int64_t OrderMessage::totalamount1000() const {
  // @@protoc_insertion_point(field_get:proto.OrderMessage.totalAmount1000)
  return _internal_totalamount1000();
}
inline void OrderMessage::_internal_set_totalamount1000(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.totalamount1000_ = value;
}
inline void OrderMessage::set_totalamount1000(int64_t value) {
  _internal_set_totalamount1000(value);
  // @@protoc_insertion_point(field_set:proto.OrderMessage.totalAmount1000)
}

// optional string totalCurrencyCode = 11;
inline bool OrderMessage::_internal_has_totalcurrencycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool OrderMessage::has_totalcurrencycode() const {
  return _internal_has_totalcurrencycode();
}
inline void OrderMessage::clear_totalcurrencycode() {
  _impl_.totalcurrencycode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& OrderMessage::totalcurrencycode() const {
  // @@protoc_insertion_point(field_get:proto.OrderMessage.totalCurrencyCode)
  return _internal_totalcurrencycode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderMessage::set_totalcurrencycode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.totalcurrencycode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.OrderMessage.totalCurrencyCode)
}
inline std::string* OrderMessage::mutable_totalcurrencycode() {
  std::string* _s = _internal_mutable_totalcurrencycode();
  // @@protoc_insertion_point(field_mutable:proto.OrderMessage.totalCurrencyCode)
  return _s;
}
inline const std::string& OrderMessage::_internal_totalcurrencycode() const {
  return _impl_.totalcurrencycode_.Get();
}
inline void OrderMessage::_internal_set_totalcurrencycode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.totalcurrencycode_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderMessage::_internal_mutable_totalcurrencycode() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.totalcurrencycode_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderMessage::release_totalcurrencycode() {
  // @@protoc_insertion_point(field_release:proto.OrderMessage.totalCurrencyCode)
  if (!_internal_has_totalcurrencycode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.totalcurrencycode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.totalcurrencycode_.IsDefault()) {
    _impl_.totalcurrencycode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OrderMessage::set_allocated_totalcurrencycode(std::string* totalcurrencycode) {
  if (totalcurrencycode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.totalcurrencycode_.SetAllocated(totalcurrencycode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.totalcurrencycode_.IsDefault()) {
    _impl_.totalcurrencycode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.OrderMessage.totalCurrencyCode)
}

// optional .proto.ContextInfo contextInfo = 17;
inline bool OrderMessage::_internal_has_contextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contextinfo_ != nullptr);
  return value;
}
inline bool OrderMessage::has_contextinfo() const {
  return _internal_has_contextinfo();
}
inline void OrderMessage::clear_contextinfo() {
  if (_impl_.contextinfo_ != nullptr) _impl_.contextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::proto::ContextInfo& OrderMessage::_internal_contextinfo() const {
  const ::proto::ContextInfo* p = _impl_.contextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContextInfo&>(
      ::proto::_ContextInfo_default_instance_);
}
inline const ::proto::ContextInfo& OrderMessage::contextinfo() const {
  // @@protoc_insertion_point(field_get:proto.OrderMessage.contextInfo)
  return _internal_contextinfo();
}
inline void OrderMessage::unsafe_arena_set_allocated_contextinfo(
    ::proto::ContextInfo* contextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextinfo_);
  }
  _impl_.contextinfo_ = contextinfo;
  if (contextinfo) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.OrderMessage.contextInfo)
}
inline ::proto::ContextInfo* OrderMessage::release_contextinfo() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContextInfo* OrderMessage::unsafe_arena_release_contextinfo() {
  // @@protoc_insertion_point(field_release:proto.OrderMessage.contextInfo)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
  return temp;
}
inline ::proto::ContextInfo* OrderMessage::_internal_mutable_contextinfo() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.contextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContextInfo>(GetArenaForAllocation());
    _impl_.contextinfo_ = p;
  }
  return _impl_.contextinfo_;
}
inline ::proto::ContextInfo* OrderMessage::mutable_contextinfo() {
  ::proto::ContextInfo* _msg = _internal_mutable_contextinfo();
  // @@protoc_insertion_point(field_mutable:proto.OrderMessage.contextInfo)
  return _msg;
}
inline void OrderMessage::set_allocated_contextinfo(::proto::ContextInfo* contextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contextinfo_;
  }
  if (contextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contextinfo);
    if (message_arena != submessage_arena) {
      contextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.contextinfo_ = contextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.OrderMessage.contextInfo)
}

// -------------------------------------------------------------------

// Row

// optional string title = 1;
inline bool Row::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Row::has_title() const {
  return _internal_has_title();
}
inline void Row::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Row::title() const {
  // @@protoc_insertion_point(field_get:proto.Row.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Row::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Row.title)
}
inline std::string* Row::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:proto.Row.title)
  return _s;
}
inline const std::string& Row::_internal_title() const {
  return _impl_.title_.Get();
}
inline void Row::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* Row::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* Row::release_title() {
  // @@protoc_insertion_point(field_release:proto.Row.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Row::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Row.title)
}

// optional string description = 2;
inline bool Row::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Row::has_description() const {
  return _internal_has_description();
}
inline void Row::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Row::description() const {
  // @@protoc_insertion_point(field_get:proto.Row.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Row::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Row.description)
}
inline std::string* Row::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:proto.Row.description)
  return _s;
}
inline const std::string& Row::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Row::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Row::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Row::release_description() {
  // @@protoc_insertion_point(field_release:proto.Row.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Row::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Row.description)
}

// optional string rowId = 3;
inline bool Row::_internal_has_rowid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Row::has_rowid() const {
  return _internal_has_rowid();
}
inline void Row::clear_rowid() {
  _impl_.rowid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Row::rowid() const {
  // @@protoc_insertion_point(field_get:proto.Row.rowId)
  return _internal_rowid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Row::set_rowid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.rowid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Row.rowId)
}
inline std::string* Row::mutable_rowid() {
  std::string* _s = _internal_mutable_rowid();
  // @@protoc_insertion_point(field_mutable:proto.Row.rowId)
  return _s;
}
inline const std::string& Row::_internal_rowid() const {
  return _impl_.rowid_.Get();
}
inline void Row::_internal_set_rowid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.rowid_.Set(value, GetArenaForAllocation());
}
inline std::string* Row::_internal_mutable_rowid() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.rowid_.Mutable(GetArenaForAllocation());
}
inline std::string* Row::release_rowid() {
  // @@protoc_insertion_point(field_release:proto.Row.rowId)
  if (!_internal_has_rowid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.rowid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rowid_.IsDefault()) {
    _impl_.rowid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Row::set_allocated_rowid(std::string* rowid) {
  if (rowid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.rowid_.SetAllocated(rowid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rowid_.IsDefault()) {
    _impl_.rowid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Row.rowId)
}

// -------------------------------------------------------------------

// Section

// optional string title = 1;
inline bool Section::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Section::has_title() const {
  return _internal_has_title();
}
inline void Section::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Section::title() const {
  // @@protoc_insertion_point(field_get:proto.Section.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Section::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Section.title)
}
inline std::string* Section::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:proto.Section.title)
  return _s;
}
inline const std::string& Section::_internal_title() const {
  return _impl_.title_.Get();
}
inline void Section::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* Section::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* Section::release_title() {
  // @@protoc_insertion_point(field_release:proto.Section.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Section::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Section.title)
}

// repeated .proto.Row rows = 2;
inline int Section::_internal_rows_size() const {
  return _impl_.rows_.size();
}
inline int Section::rows_size() const {
  return _internal_rows_size();
}
inline void Section::clear_rows() {
  _impl_.rows_.Clear();
}
inline ::proto::Row* Section::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Section.rows)
  return _impl_.rows_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Row >*
Section::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:proto.Section.rows)
  return &_impl_.rows_;
}
inline const ::proto::Row& Section::_internal_rows(int index) const {
  return _impl_.rows_.Get(index);
}
inline const ::proto::Row& Section::rows(int index) const {
  // @@protoc_insertion_point(field_get:proto.Section.rows)
  return _internal_rows(index);
}
inline ::proto::Row* Section::_internal_add_rows() {
  return _impl_.rows_.Add();
}
inline ::proto::Row* Section::add_rows() {
  ::proto::Row* _add = _internal_add_rows();
  // @@protoc_insertion_point(field_add:proto.Section.rows)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Row >&
Section::rows() const {
  // @@protoc_insertion_point(field_list:proto.Section.rows)
  return _impl_.rows_;
}

// -------------------------------------------------------------------

// ListMessage

// optional string title = 1;
inline bool ListMessage::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ListMessage::has_title() const {
  return _internal_has_title();
}
inline void ListMessage::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListMessage::title() const {
  // @@protoc_insertion_point(field_get:proto.ListMessage.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListMessage::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ListMessage.title)
}
inline std::string* ListMessage::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:proto.ListMessage.title)
  return _s;
}
inline const std::string& ListMessage::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ListMessage::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ListMessage::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* ListMessage::release_title() {
  // @@protoc_insertion_point(field_release:proto.ListMessage.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListMessage::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ListMessage.title)
}

// optional string description = 2;
inline bool ListMessage::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ListMessage::has_description() const {
  return _internal_has_description();
}
inline void ListMessage::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ListMessage::description() const {
  // @@protoc_insertion_point(field_get:proto.ListMessage.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListMessage::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ListMessage.description)
}
inline std::string* ListMessage::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:proto.ListMessage.description)
  return _s;
}
inline const std::string& ListMessage::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ListMessage::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ListMessage::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ListMessage::release_description() {
  // @@protoc_insertion_point(field_release:proto.ListMessage.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListMessage::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ListMessage.description)
}

// optional string buttonText = 3;
inline bool ListMessage::_internal_has_buttontext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ListMessage::has_buttontext() const {
  return _internal_has_buttontext();
}
inline void ListMessage::clear_buttontext() {
  _impl_.buttontext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ListMessage::buttontext() const {
  // @@protoc_insertion_point(field_get:proto.ListMessage.buttonText)
  return _internal_buttontext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListMessage::set_buttontext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.buttontext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ListMessage.buttonText)
}
inline std::string* ListMessage::mutable_buttontext() {
  std::string* _s = _internal_mutable_buttontext();
  // @@protoc_insertion_point(field_mutable:proto.ListMessage.buttonText)
  return _s;
}
inline const std::string& ListMessage::_internal_buttontext() const {
  return _impl_.buttontext_.Get();
}
inline void ListMessage::_internal_set_buttontext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.buttontext_.Set(value, GetArenaForAllocation());
}
inline std::string* ListMessage::_internal_mutable_buttontext() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.buttontext_.Mutable(GetArenaForAllocation());
}
inline std::string* ListMessage::release_buttontext() {
  // @@protoc_insertion_point(field_release:proto.ListMessage.buttonText)
  if (!_internal_has_buttontext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.buttontext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buttontext_.IsDefault()) {
    _impl_.buttontext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListMessage::set_allocated_buttontext(std::string* buttontext) {
  if (buttontext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.buttontext_.SetAllocated(buttontext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buttontext_.IsDefault()) {
    _impl_.buttontext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ListMessage.buttonText)
}

// optional .proto.ListMessage.ListMessageListType listType = 4;
inline bool ListMessage::_internal_has_listtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ListMessage::has_listtype() const {
  return _internal_has_listtype();
}
inline void ListMessage::clear_listtype() {
  _impl_.listtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::proto::ListMessage_ListMessageListType ListMessage::_internal_listtype() const {
  return static_cast< ::proto::ListMessage_ListMessageListType >(_impl_.listtype_);
}
inline ::proto::ListMessage_ListMessageListType ListMessage::listtype() const {
  // @@protoc_insertion_point(field_get:proto.ListMessage.listType)
  return _internal_listtype();
}
inline void ListMessage::_internal_set_listtype(::proto::ListMessage_ListMessageListType value) {
  assert(::proto::ListMessage_ListMessageListType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.listtype_ = value;
}
inline void ListMessage::set_listtype(::proto::ListMessage_ListMessageListType value) {
  _internal_set_listtype(value);
  // @@protoc_insertion_point(field_set:proto.ListMessage.listType)
}

// repeated .proto.Section sections = 5;
inline int ListMessage::_internal_sections_size() const {
  return _impl_.sections_.size();
}
inline int ListMessage::sections_size() const {
  return _internal_sections_size();
}
inline void ListMessage::clear_sections() {
  _impl_.sections_.Clear();
}
inline ::proto::Section* ListMessage::mutable_sections(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ListMessage.sections)
  return _impl_.sections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Section >*
ListMessage::mutable_sections() {
  // @@protoc_insertion_point(field_mutable_list:proto.ListMessage.sections)
  return &_impl_.sections_;
}
inline const ::proto::Section& ListMessage::_internal_sections(int index) const {
  return _impl_.sections_.Get(index);
}
inline const ::proto::Section& ListMessage::sections(int index) const {
  // @@protoc_insertion_point(field_get:proto.ListMessage.sections)
  return _internal_sections(index);
}
inline ::proto::Section* ListMessage::_internal_add_sections() {
  return _impl_.sections_.Add();
}
inline ::proto::Section* ListMessage::add_sections() {
  ::proto::Section* _add = _internal_add_sections();
  // @@protoc_insertion_point(field_add:proto.ListMessage.sections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Section >&
ListMessage::sections() const {
  // @@protoc_insertion_point(field_list:proto.ListMessage.sections)
  return _impl_.sections_;
}

// -------------------------------------------------------------------

// SingleSelectReply

// optional string selectedRowId = 1;
inline bool SingleSelectReply::_internal_has_selectedrowid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SingleSelectReply::has_selectedrowid() const {
  return _internal_has_selectedrowid();
}
inline void SingleSelectReply::clear_selectedrowid() {
  _impl_.selectedrowid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SingleSelectReply::selectedrowid() const {
  // @@protoc_insertion_point(field_get:proto.SingleSelectReply.selectedRowId)
  return _internal_selectedrowid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SingleSelectReply::set_selectedrowid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.selectedrowid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SingleSelectReply.selectedRowId)
}
inline std::string* SingleSelectReply::mutable_selectedrowid() {
  std::string* _s = _internal_mutable_selectedrowid();
  // @@protoc_insertion_point(field_mutable:proto.SingleSelectReply.selectedRowId)
  return _s;
}
inline const std::string& SingleSelectReply::_internal_selectedrowid() const {
  return _impl_.selectedrowid_.Get();
}
inline void SingleSelectReply::_internal_set_selectedrowid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.selectedrowid_.Set(value, GetArenaForAllocation());
}
inline std::string* SingleSelectReply::_internal_mutable_selectedrowid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.selectedrowid_.Mutable(GetArenaForAllocation());
}
inline std::string* SingleSelectReply::release_selectedrowid() {
  // @@protoc_insertion_point(field_release:proto.SingleSelectReply.selectedRowId)
  if (!_internal_has_selectedrowid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.selectedrowid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.selectedrowid_.IsDefault()) {
    _impl_.selectedrowid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SingleSelectReply::set_allocated_selectedrowid(std::string* selectedrowid) {
  if (selectedrowid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.selectedrowid_.SetAllocated(selectedrowid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.selectedrowid_.IsDefault()) {
    _impl_.selectedrowid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SingleSelectReply.selectedRowId)
}

// -------------------------------------------------------------------

// ListResponseMessage

// optional string title = 1;
inline bool ListResponseMessage::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ListResponseMessage::has_title() const {
  return _internal_has_title();
}
inline void ListResponseMessage::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListResponseMessage::title() const {
  // @@protoc_insertion_point(field_get:proto.ListResponseMessage.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListResponseMessage::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ListResponseMessage.title)
}
inline std::string* ListResponseMessage::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:proto.ListResponseMessage.title)
  return _s;
}
inline const std::string& ListResponseMessage::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ListResponseMessage::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ListResponseMessage::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* ListResponseMessage::release_title() {
  // @@protoc_insertion_point(field_release:proto.ListResponseMessage.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListResponseMessage::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ListResponseMessage.title)
}

// optional .proto.ListResponseMessage.ListResponseMessageListType listType = 2;
inline bool ListResponseMessage::_internal_has_listtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ListResponseMessage::has_listtype() const {
  return _internal_has_listtype();
}
inline void ListResponseMessage::clear_listtype() {
  _impl_.listtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::proto::ListResponseMessage_ListResponseMessageListType ListResponseMessage::_internal_listtype() const {
  return static_cast< ::proto::ListResponseMessage_ListResponseMessageListType >(_impl_.listtype_);
}
inline ::proto::ListResponseMessage_ListResponseMessageListType ListResponseMessage::listtype() const {
  // @@protoc_insertion_point(field_get:proto.ListResponseMessage.listType)
  return _internal_listtype();
}
inline void ListResponseMessage::_internal_set_listtype(::proto::ListResponseMessage_ListResponseMessageListType value) {
  assert(::proto::ListResponseMessage_ListResponseMessageListType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.listtype_ = value;
}
inline void ListResponseMessage::set_listtype(::proto::ListResponseMessage_ListResponseMessageListType value) {
  _internal_set_listtype(value);
  // @@protoc_insertion_point(field_set:proto.ListResponseMessage.listType)
}

// optional .proto.SingleSelectReply singleSelectReply = 3;
inline bool ListResponseMessage::_internal_has_singleselectreply() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.singleselectreply_ != nullptr);
  return value;
}
inline bool ListResponseMessage::has_singleselectreply() const {
  return _internal_has_singleselectreply();
}
inline void ListResponseMessage::clear_singleselectreply() {
  if (_impl_.singleselectreply_ != nullptr) _impl_.singleselectreply_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::proto::SingleSelectReply& ListResponseMessage::_internal_singleselectreply() const {
  const ::proto::SingleSelectReply* p = _impl_.singleselectreply_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::SingleSelectReply&>(
      ::proto::_SingleSelectReply_default_instance_);
}
inline const ::proto::SingleSelectReply& ListResponseMessage::singleselectreply() const {
  // @@protoc_insertion_point(field_get:proto.ListResponseMessage.singleSelectReply)
  return _internal_singleselectreply();
}
inline void ListResponseMessage::unsafe_arena_set_allocated_singleselectreply(
    ::proto::SingleSelectReply* singleselectreply) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.singleselectreply_);
  }
  _impl_.singleselectreply_ = singleselectreply;
  if (singleselectreply) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ListResponseMessage.singleSelectReply)
}
inline ::proto::SingleSelectReply* ListResponseMessage::release_singleselectreply() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::SingleSelectReply* temp = _impl_.singleselectreply_;
  _impl_.singleselectreply_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::SingleSelectReply* ListResponseMessage::unsafe_arena_release_singleselectreply() {
  // @@protoc_insertion_point(field_release:proto.ListResponseMessage.singleSelectReply)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::SingleSelectReply* temp = _impl_.singleselectreply_;
  _impl_.singleselectreply_ = nullptr;
  return temp;
}
inline ::proto::SingleSelectReply* ListResponseMessage::_internal_mutable_singleselectreply() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.singleselectreply_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::SingleSelectReply>(GetArenaForAllocation());
    _impl_.singleselectreply_ = p;
  }
  return _impl_.singleselectreply_;
}
inline ::proto::SingleSelectReply* ListResponseMessage::mutable_singleselectreply() {
  ::proto::SingleSelectReply* _msg = _internal_mutable_singleselectreply();
  // @@protoc_insertion_point(field_mutable:proto.ListResponseMessage.singleSelectReply)
  return _msg;
}
inline void ListResponseMessage::set_allocated_singleselectreply(::proto::SingleSelectReply* singleselectreply) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.singleselectreply_;
  }
  if (singleselectreply) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(singleselectreply);
    if (message_arena != submessage_arena) {
      singleselectreply = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, singleselectreply, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.singleselectreply_ = singleselectreply;
  // @@protoc_insertion_point(field_set_allocated:proto.ListResponseMessage.singleSelectReply)
}

// optional .proto.ContextInfo contextInfo = 4;
inline bool ListResponseMessage::_internal_has_contextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contextinfo_ != nullptr);
  return value;
}
inline bool ListResponseMessage::has_contextinfo() const {
  return _internal_has_contextinfo();
}
inline void ListResponseMessage::clear_contextinfo() {
  if (_impl_.contextinfo_ != nullptr) _impl_.contextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::proto::ContextInfo& ListResponseMessage::_internal_contextinfo() const {
  const ::proto::ContextInfo* p = _impl_.contextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContextInfo&>(
      ::proto::_ContextInfo_default_instance_);
}
inline const ::proto::ContextInfo& ListResponseMessage::contextinfo() const {
  // @@protoc_insertion_point(field_get:proto.ListResponseMessage.contextInfo)
  return _internal_contextinfo();
}
inline void ListResponseMessage::unsafe_arena_set_allocated_contextinfo(
    ::proto::ContextInfo* contextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextinfo_);
  }
  _impl_.contextinfo_ = contextinfo;
  if (contextinfo) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ListResponseMessage.contextInfo)
}
inline ::proto::ContextInfo* ListResponseMessage::release_contextinfo() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContextInfo* ListResponseMessage::unsafe_arena_release_contextinfo() {
  // @@protoc_insertion_point(field_release:proto.ListResponseMessage.contextInfo)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
  return temp;
}
inline ::proto::ContextInfo* ListResponseMessage::_internal_mutable_contextinfo() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.contextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContextInfo>(GetArenaForAllocation());
    _impl_.contextinfo_ = p;
  }
  return _impl_.contextinfo_;
}
inline ::proto::ContextInfo* ListResponseMessage::mutable_contextinfo() {
  ::proto::ContextInfo* _msg = _internal_mutable_contextinfo();
  // @@protoc_insertion_point(field_mutable:proto.ListResponseMessage.contextInfo)
  return _msg;
}
inline void ListResponseMessage::set_allocated_contextinfo(::proto::ContextInfo* contextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contextinfo_;
  }
  if (contextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contextinfo);
    if (message_arena != submessage_arena) {
      contextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.contextinfo_ = contextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.ListResponseMessage.contextInfo)
}

// optional string description = 5;
inline bool ListResponseMessage::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ListResponseMessage::has_description() const {
  return _internal_has_description();
}
inline void ListResponseMessage::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ListResponseMessage::description() const {
  // @@protoc_insertion_point(field_get:proto.ListResponseMessage.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListResponseMessage::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ListResponseMessage.description)
}
inline std::string* ListResponseMessage::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:proto.ListResponseMessage.description)
  return _s;
}
inline const std::string& ListResponseMessage::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ListResponseMessage::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ListResponseMessage::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ListResponseMessage::release_description() {
  // @@protoc_insertion_point(field_release:proto.ListResponseMessage.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListResponseMessage::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ListResponseMessage.description)
}

// -------------------------------------------------------------------

// GroupInviteMessage

// optional string groupJid = 1;
inline bool GroupInviteMessage::_internal_has_groupjid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GroupInviteMessage::has_groupjid() const {
  return _internal_has_groupjid();
}
inline void GroupInviteMessage::clear_groupjid() {
  _impl_.groupjid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GroupInviteMessage::groupjid() const {
  // @@protoc_insertion_point(field_get:proto.GroupInviteMessage.groupJid)
  return _internal_groupjid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupInviteMessage::set_groupjid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.groupjid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.GroupInviteMessage.groupJid)
}
inline std::string* GroupInviteMessage::mutable_groupjid() {
  std::string* _s = _internal_mutable_groupjid();
  // @@protoc_insertion_point(field_mutable:proto.GroupInviteMessage.groupJid)
  return _s;
}
inline const std::string& GroupInviteMessage::_internal_groupjid() const {
  return _impl_.groupjid_.Get();
}
inline void GroupInviteMessage::_internal_set_groupjid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.groupjid_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupInviteMessage::_internal_mutable_groupjid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.groupjid_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupInviteMessage::release_groupjid() {
  // @@protoc_insertion_point(field_release:proto.GroupInviteMessage.groupJid)
  if (!_internal_has_groupjid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.groupjid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupjid_.IsDefault()) {
    _impl_.groupjid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupInviteMessage::set_allocated_groupjid(std::string* groupjid) {
  if (groupjid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.groupjid_.SetAllocated(groupjid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupjid_.IsDefault()) {
    _impl_.groupjid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.GroupInviteMessage.groupJid)
}

// optional string inviteCode = 2;
inline bool GroupInviteMessage::_internal_has_invitecode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GroupInviteMessage::has_invitecode() const {
  return _internal_has_invitecode();
}
inline void GroupInviteMessage::clear_invitecode() {
  _impl_.invitecode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GroupInviteMessage::invitecode() const {
  // @@protoc_insertion_point(field_get:proto.GroupInviteMessage.inviteCode)
  return _internal_invitecode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupInviteMessage::set_invitecode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.invitecode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.GroupInviteMessage.inviteCode)
}
inline std::string* GroupInviteMessage::mutable_invitecode() {
  std::string* _s = _internal_mutable_invitecode();
  // @@protoc_insertion_point(field_mutable:proto.GroupInviteMessage.inviteCode)
  return _s;
}
inline const std::string& GroupInviteMessage::_internal_invitecode() const {
  return _impl_.invitecode_.Get();
}
inline void GroupInviteMessage::_internal_set_invitecode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.invitecode_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupInviteMessage::_internal_mutable_invitecode() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.invitecode_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupInviteMessage::release_invitecode() {
  // @@protoc_insertion_point(field_release:proto.GroupInviteMessage.inviteCode)
  if (!_internal_has_invitecode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.invitecode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invitecode_.IsDefault()) {
    _impl_.invitecode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupInviteMessage::set_allocated_invitecode(std::string* invitecode) {
  if (invitecode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.invitecode_.SetAllocated(invitecode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invitecode_.IsDefault()) {
    _impl_.invitecode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.GroupInviteMessage.inviteCode)
}

// optional int64 inviteExpiration = 3;
inline bool GroupInviteMessage::_internal_has_inviteexpiration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GroupInviteMessage::has_inviteexpiration() const {
  return _internal_has_inviteexpiration();
}
inline void GroupInviteMessage::clear_inviteexpiration() {
  _impl_.inviteexpiration_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t GroupInviteMessage::_internal_inviteexpiration() const {
  return _impl_.inviteexpiration_;
}
inline int64_t GroupInviteMessage::inviteexpiration() const {
  // @@protoc_insertion_point(field_get:proto.GroupInviteMessage.inviteExpiration)
  return _internal_inviteexpiration();
}
inline void GroupInviteMessage::_internal_set_inviteexpiration(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.inviteexpiration_ = value;
}
inline void GroupInviteMessage::set_inviteexpiration(int64_t value) {
  _internal_set_inviteexpiration(value);
  // @@protoc_insertion_point(field_set:proto.GroupInviteMessage.inviteExpiration)
}

// optional string groupName = 4;
inline bool GroupInviteMessage::_internal_has_groupname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GroupInviteMessage::has_groupname() const {
  return _internal_has_groupname();
}
inline void GroupInviteMessage::clear_groupname() {
  _impl_.groupname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GroupInviteMessage::groupname() const {
  // @@protoc_insertion_point(field_get:proto.GroupInviteMessage.groupName)
  return _internal_groupname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupInviteMessage::set_groupname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.groupname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.GroupInviteMessage.groupName)
}
inline std::string* GroupInviteMessage::mutable_groupname() {
  std::string* _s = _internal_mutable_groupname();
  // @@protoc_insertion_point(field_mutable:proto.GroupInviteMessage.groupName)
  return _s;
}
inline const std::string& GroupInviteMessage::_internal_groupname() const {
  return _impl_.groupname_.Get();
}
inline void GroupInviteMessage::_internal_set_groupname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.groupname_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupInviteMessage::_internal_mutable_groupname() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.groupname_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupInviteMessage::release_groupname() {
  // @@protoc_insertion_point(field_release:proto.GroupInviteMessage.groupName)
  if (!_internal_has_groupname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.groupname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupname_.IsDefault()) {
    _impl_.groupname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupInviteMessage::set_allocated_groupname(std::string* groupname) {
  if (groupname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.groupname_.SetAllocated(groupname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupname_.IsDefault()) {
    _impl_.groupname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.GroupInviteMessage.groupName)
}

// optional bytes jpegThumbnail = 5;
inline bool GroupInviteMessage::_internal_has_jpegthumbnail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GroupInviteMessage::has_jpegthumbnail() const {
  return _internal_has_jpegthumbnail();
}
inline void GroupInviteMessage::clear_jpegthumbnail() {
  _impl_.jpegthumbnail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& GroupInviteMessage::jpegthumbnail() const {
  // @@protoc_insertion_point(field_get:proto.GroupInviteMessage.jpegThumbnail)
  return _internal_jpegthumbnail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupInviteMessage::set_jpegthumbnail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.jpegthumbnail_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.GroupInviteMessage.jpegThumbnail)
}
inline std::string* GroupInviteMessage::mutable_jpegthumbnail() {
  std::string* _s = _internal_mutable_jpegthumbnail();
  // @@protoc_insertion_point(field_mutable:proto.GroupInviteMessage.jpegThumbnail)
  return _s;
}
inline const std::string& GroupInviteMessage::_internal_jpegthumbnail() const {
  return _impl_.jpegthumbnail_.Get();
}
inline void GroupInviteMessage::_internal_set_jpegthumbnail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.jpegthumbnail_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupInviteMessage::_internal_mutable_jpegthumbnail() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.jpegthumbnail_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupInviteMessage::release_jpegthumbnail() {
  // @@protoc_insertion_point(field_release:proto.GroupInviteMessage.jpegThumbnail)
  if (!_internal_has_jpegthumbnail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.jpegthumbnail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jpegthumbnail_.IsDefault()) {
    _impl_.jpegthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupInviteMessage::set_allocated_jpegthumbnail(std::string* jpegthumbnail) {
  if (jpegthumbnail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.jpegthumbnail_.SetAllocated(jpegthumbnail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jpegthumbnail_.IsDefault()) {
    _impl_.jpegthumbnail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.GroupInviteMessage.jpegThumbnail)
}

// optional string caption = 6;
inline bool GroupInviteMessage::_internal_has_caption() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GroupInviteMessage::has_caption() const {
  return _internal_has_caption();
}
inline void GroupInviteMessage::clear_caption() {
  _impl_.caption_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& GroupInviteMessage::caption() const {
  // @@protoc_insertion_point(field_get:proto.GroupInviteMessage.caption)
  return _internal_caption();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupInviteMessage::set_caption(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.caption_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.GroupInviteMessage.caption)
}
inline std::string* GroupInviteMessage::mutable_caption() {
  std::string* _s = _internal_mutable_caption();
  // @@protoc_insertion_point(field_mutable:proto.GroupInviteMessage.caption)
  return _s;
}
inline const std::string& GroupInviteMessage::_internal_caption() const {
  return _impl_.caption_.Get();
}
inline void GroupInviteMessage::_internal_set_caption(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.caption_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupInviteMessage::_internal_mutable_caption() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.caption_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupInviteMessage::release_caption() {
  // @@protoc_insertion_point(field_release:proto.GroupInviteMessage.caption)
  if (!_internal_has_caption()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.caption_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caption_.IsDefault()) {
    _impl_.caption_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupInviteMessage::set_allocated_caption(std::string* caption) {
  if (caption != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.caption_.SetAllocated(caption, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caption_.IsDefault()) {
    _impl_.caption_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.GroupInviteMessage.caption)
}

// optional .proto.ContextInfo contextInfo = 7;
inline bool GroupInviteMessage::_internal_has_contextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contextinfo_ != nullptr);
  return value;
}
inline bool GroupInviteMessage::has_contextinfo() const {
  return _internal_has_contextinfo();
}
inline void GroupInviteMessage::clear_contextinfo() {
  if (_impl_.contextinfo_ != nullptr) _impl_.contextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::proto::ContextInfo& GroupInviteMessage::_internal_contextinfo() const {
  const ::proto::ContextInfo* p = _impl_.contextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContextInfo&>(
      ::proto::_ContextInfo_default_instance_);
}
inline const ::proto::ContextInfo& GroupInviteMessage::contextinfo() const {
  // @@protoc_insertion_point(field_get:proto.GroupInviteMessage.contextInfo)
  return _internal_contextinfo();
}
inline void GroupInviteMessage::unsafe_arena_set_allocated_contextinfo(
    ::proto::ContextInfo* contextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextinfo_);
  }
  _impl_.contextinfo_ = contextinfo;
  if (contextinfo) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.GroupInviteMessage.contextInfo)
}
inline ::proto::ContextInfo* GroupInviteMessage::release_contextinfo() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContextInfo* GroupInviteMessage::unsafe_arena_release_contextinfo() {
  // @@protoc_insertion_point(field_release:proto.GroupInviteMessage.contextInfo)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
  return temp;
}
inline ::proto::ContextInfo* GroupInviteMessage::_internal_mutable_contextinfo() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.contextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContextInfo>(GetArenaForAllocation());
    _impl_.contextinfo_ = p;
  }
  return _impl_.contextinfo_;
}
inline ::proto::ContextInfo* GroupInviteMessage::mutable_contextinfo() {
  ::proto::ContextInfo* _msg = _internal_mutable_contextinfo();
  // @@protoc_insertion_point(field_mutable:proto.GroupInviteMessage.contextInfo)
  return _msg;
}
inline void GroupInviteMessage::set_allocated_contextinfo(::proto::ContextInfo* contextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contextinfo_;
  }
  if (contextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contextinfo);
    if (message_arena != submessage_arena) {
      contextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.contextinfo_ = contextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.GroupInviteMessage.contextInfo)
}

// -------------------------------------------------------------------

// EphemeralSetting

// optional string chatJid = 1;
inline bool EphemeralSetting::_internal_has_chatjid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EphemeralSetting::has_chatjid() const {
  return _internal_has_chatjid();
}
inline void EphemeralSetting::clear_chatjid() {
  _impl_.chatjid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EphemeralSetting::chatjid() const {
  // @@protoc_insertion_point(field_get:proto.EphemeralSetting.chatJid)
  return _internal_chatjid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EphemeralSetting::set_chatjid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.chatjid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.EphemeralSetting.chatJid)
}
inline std::string* EphemeralSetting::mutable_chatjid() {
  std::string* _s = _internal_mutable_chatjid();
  // @@protoc_insertion_point(field_mutable:proto.EphemeralSetting.chatJid)
  return _s;
}
inline const std::string& EphemeralSetting::_internal_chatjid() const {
  return _impl_.chatjid_.Get();
}
inline void EphemeralSetting::_internal_set_chatjid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.chatjid_.Set(value, GetArenaForAllocation());
}
inline std::string* EphemeralSetting::_internal_mutable_chatjid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.chatjid_.Mutable(GetArenaForAllocation());
}
inline std::string* EphemeralSetting::release_chatjid() {
  // @@protoc_insertion_point(field_release:proto.EphemeralSetting.chatJid)
  if (!_internal_has_chatjid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.chatjid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chatjid_.IsDefault()) {
    _impl_.chatjid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EphemeralSetting::set_allocated_chatjid(std::string* chatjid) {
  if (chatjid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.chatjid_.SetAllocated(chatjid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chatjid_.IsDefault()) {
    _impl_.chatjid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.EphemeralSetting.chatJid)
}

// optional uint32 ephemeralExpiration = 2;
inline bool EphemeralSetting::_internal_has_ephemeralexpiration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EphemeralSetting::has_ephemeralexpiration() const {
  return _internal_has_ephemeralexpiration();
}
inline void EphemeralSetting::clear_ephemeralexpiration() {
  _impl_.ephemeralexpiration_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t EphemeralSetting::_internal_ephemeralexpiration() const {
  return _impl_.ephemeralexpiration_;
}
inline uint32_t EphemeralSetting::ephemeralexpiration() const {
  // @@protoc_insertion_point(field_get:proto.EphemeralSetting.ephemeralExpiration)
  return _internal_ephemeralexpiration();
}
inline void EphemeralSetting::_internal_set_ephemeralexpiration(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ephemeralexpiration_ = value;
}
inline void EphemeralSetting::set_ephemeralexpiration(uint32_t value) {
  _internal_set_ephemeralexpiration(value);
  // @@protoc_insertion_point(field_set:proto.EphemeralSetting.ephemeralExpiration)
}

// optional int64 ephemeralSettingTimestamp = 3;
inline bool EphemeralSetting::_internal_has_ephemeralsettingtimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EphemeralSetting::has_ephemeralsettingtimestamp() const {
  return _internal_has_ephemeralsettingtimestamp();
}
inline void EphemeralSetting::clear_ephemeralsettingtimestamp() {
  _impl_.ephemeralsettingtimestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t EphemeralSetting::_internal_ephemeralsettingtimestamp() const {
  return _impl_.ephemeralsettingtimestamp_;
}
inline int64_t EphemeralSetting::ephemeralsettingtimestamp() const {
  // @@protoc_insertion_point(field_get:proto.EphemeralSetting.ephemeralSettingTimestamp)
  return _internal_ephemeralsettingtimestamp();
}
inline void EphemeralSetting::_internal_set_ephemeralsettingtimestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ephemeralsettingtimestamp_ = value;
}
inline void EphemeralSetting::set_ephemeralsettingtimestamp(int64_t value) {
  _internal_set_ephemeralsettingtimestamp(value);
  // @@protoc_insertion_point(field_set:proto.EphemeralSetting.ephemeralSettingTimestamp)
}

// -------------------------------------------------------------------

// DeviceSentMessage

// optional string destinationJid = 1;
inline bool DeviceSentMessage::_internal_has_destinationjid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceSentMessage::has_destinationjid() const {
  return _internal_has_destinationjid();
}
inline void DeviceSentMessage::clear_destinationjid() {
  _impl_.destinationjid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceSentMessage::destinationjid() const {
  // @@protoc_insertion_point(field_get:proto.DeviceSentMessage.destinationJid)
  return _internal_destinationjid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceSentMessage::set_destinationjid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.destinationjid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DeviceSentMessage.destinationJid)
}
inline std::string* DeviceSentMessage::mutable_destinationjid() {
  std::string* _s = _internal_mutable_destinationjid();
  // @@protoc_insertion_point(field_mutable:proto.DeviceSentMessage.destinationJid)
  return _s;
}
inline const std::string& DeviceSentMessage::_internal_destinationjid() const {
  return _impl_.destinationjid_.Get();
}
inline void DeviceSentMessage::_internal_set_destinationjid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.destinationjid_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceSentMessage::_internal_mutable_destinationjid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.destinationjid_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceSentMessage::release_destinationjid() {
  // @@protoc_insertion_point(field_release:proto.DeviceSentMessage.destinationJid)
  if (!_internal_has_destinationjid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.destinationjid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destinationjid_.IsDefault()) {
    _impl_.destinationjid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceSentMessage::set_allocated_destinationjid(std::string* destinationjid) {
  if (destinationjid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.destinationjid_.SetAllocated(destinationjid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destinationjid_.IsDefault()) {
    _impl_.destinationjid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DeviceSentMessage.destinationJid)
}

// optional .proto.Message message = 2;
inline bool DeviceSentMessage::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.message_ != nullptr);
  return value;
}
inline bool DeviceSentMessage::has_message() const {
  return _internal_has_message();
}
inline void DeviceSentMessage::clear_message() {
  if (_impl_.message_ != nullptr) _impl_.message_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::proto::Message& DeviceSentMessage::_internal_message() const {
  const ::proto::Message* p = _impl_.message_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Message&>(
      ::proto::_Message_default_instance_);
}
inline const ::proto::Message& DeviceSentMessage::message() const {
  // @@protoc_insertion_point(field_get:proto.DeviceSentMessage.message)
  return _internal_message();
}
inline void DeviceSentMessage::unsafe_arena_set_allocated_message(
    ::proto::Message* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.message_);
  }
  _impl_.message_ = message;
  if (message) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.DeviceSentMessage.message)
}
inline ::proto::Message* DeviceSentMessage::release_message() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Message* DeviceSentMessage::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:proto.DeviceSentMessage.message)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
  return temp;
}
inline ::proto::Message* DeviceSentMessage::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.message_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Message>(GetArenaForAllocation());
    _impl_.message_ = p;
  }
  return _impl_.message_;
}
inline ::proto::Message* DeviceSentMessage::mutable_message() {
  ::proto::Message* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:proto.DeviceSentMessage.message)
  return _msg;
}
inline void DeviceSentMessage::set_allocated_message(::proto::Message* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.message_ = message;
  // @@protoc_insertion_point(field_set_allocated:proto.DeviceSentMessage.message)
}

// optional string phash = 3;
inline bool DeviceSentMessage::_internal_has_phash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceSentMessage::has_phash() const {
  return _internal_has_phash();
}
inline void DeviceSentMessage::clear_phash() {
  _impl_.phash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceSentMessage::phash() const {
  // @@protoc_insertion_point(field_get:proto.DeviceSentMessage.phash)
  return _internal_phash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceSentMessage::set_phash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.phash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.DeviceSentMessage.phash)
}
inline std::string* DeviceSentMessage::mutable_phash() {
  std::string* _s = _internal_mutable_phash();
  // @@protoc_insertion_point(field_mutable:proto.DeviceSentMessage.phash)
  return _s;
}
inline const std::string& DeviceSentMessage::_internal_phash() const {
  return _impl_.phash_.Get();
}
inline void DeviceSentMessage::_internal_set_phash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.phash_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceSentMessage::_internal_mutable_phash() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.phash_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceSentMessage::release_phash() {
  // @@protoc_insertion_point(field_release:proto.DeviceSentMessage.phash)
  if (!_internal_has_phash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.phash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phash_.IsDefault()) {
    _impl_.phash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceSentMessage::set_allocated_phash(std::string* phash) {
  if (phash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.phash_.SetAllocated(phash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phash_.IsDefault()) {
    _impl_.phash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.DeviceSentMessage.phash)
}

// repeated .proto.EphemeralSetting broadcastEphemeralSettings = 4;
inline int DeviceSentMessage::_internal_broadcastephemeralsettings_size() const {
  return _impl_.broadcastephemeralsettings_.size();
}
inline int DeviceSentMessage::broadcastephemeralsettings_size() const {
  return _internal_broadcastephemeralsettings_size();
}
inline void DeviceSentMessage::clear_broadcastephemeralsettings() {
  _impl_.broadcastephemeralsettings_.Clear();
}
inline ::proto::EphemeralSetting* DeviceSentMessage::mutable_broadcastephemeralsettings(int index) {
  // @@protoc_insertion_point(field_mutable:proto.DeviceSentMessage.broadcastEphemeralSettings)
  return _impl_.broadcastephemeralsettings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::EphemeralSetting >*
DeviceSentMessage::mutable_broadcastephemeralsettings() {
  // @@protoc_insertion_point(field_mutable_list:proto.DeviceSentMessage.broadcastEphemeralSettings)
  return &_impl_.broadcastephemeralsettings_;
}
inline const ::proto::EphemeralSetting& DeviceSentMessage::_internal_broadcastephemeralsettings(int index) const {
  return _impl_.broadcastephemeralsettings_.Get(index);
}
inline const ::proto::EphemeralSetting& DeviceSentMessage::broadcastephemeralsettings(int index) const {
  // @@protoc_insertion_point(field_get:proto.DeviceSentMessage.broadcastEphemeralSettings)
  return _internal_broadcastephemeralsettings(index);
}
inline ::proto::EphemeralSetting* DeviceSentMessage::_internal_add_broadcastephemeralsettings() {
  return _impl_.broadcastephemeralsettings_.Add();
}
inline ::proto::EphemeralSetting* DeviceSentMessage::add_broadcastephemeralsettings() {
  ::proto::EphemeralSetting* _add = _internal_add_broadcastephemeralsettings();
  // @@protoc_insertion_point(field_add:proto.DeviceSentMessage.broadcastEphemeralSettings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::EphemeralSetting >&
DeviceSentMessage::broadcastephemeralsettings() const {
  // @@protoc_insertion_point(field_list:proto.DeviceSentMessage.broadcastEphemeralSettings)
  return _impl_.broadcastephemeralsettings_;
}

// -------------------------------------------------------------------

// FutureProofMessage

// optional .proto.Message message = 1;
inline bool FutureProofMessage::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.message_ != nullptr);
  return value;
}
inline bool FutureProofMessage::has_message() const {
  return _internal_has_message();
}
inline void FutureProofMessage::clear_message() {
  if (_impl_.message_ != nullptr) _impl_.message_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::Message& FutureProofMessage::_internal_message() const {
  const ::proto::Message* p = _impl_.message_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Message&>(
      ::proto::_Message_default_instance_);
}
inline const ::proto::Message& FutureProofMessage::message() const {
  // @@protoc_insertion_point(field_get:proto.FutureProofMessage.message)
  return _internal_message();
}
inline void FutureProofMessage::unsafe_arena_set_allocated_message(
    ::proto::Message* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.message_);
  }
  _impl_.message_ = message;
  if (message) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FutureProofMessage.message)
}
inline ::proto::Message* FutureProofMessage::release_message() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Message* FutureProofMessage::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:proto.FutureProofMessage.message)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::proto::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
  return temp;
}
inline ::proto::Message* FutureProofMessage::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.message_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Message>(GetArenaForAllocation());
    _impl_.message_ = p;
  }
  return _impl_.message_;
}
inline ::proto::Message* FutureProofMessage::mutable_message() {
  ::proto::Message* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:proto.FutureProofMessage.message)
  return _msg;
}
inline void FutureProofMessage::set_allocated_message(::proto::Message* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_ = message;
  // @@protoc_insertion_point(field_set_allocated:proto.FutureProofMessage.message)
}

// -------------------------------------------------------------------

// ButtonText

// optional string displayText = 1;
inline bool ButtonText::_internal_has_displaytext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ButtonText::has_displaytext() const {
  return _internal_has_displaytext();
}
inline void ButtonText::clear_displaytext() {
  _impl_.displaytext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ButtonText::displaytext() const {
  // @@protoc_insertion_point(field_get:proto.ButtonText.displayText)
  return _internal_displaytext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ButtonText::set_displaytext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.displaytext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ButtonText.displayText)
}
inline std::string* ButtonText::mutable_displaytext() {
  std::string* _s = _internal_mutable_displaytext();
  // @@protoc_insertion_point(field_mutable:proto.ButtonText.displayText)
  return _s;
}
inline const std::string& ButtonText::_internal_displaytext() const {
  return _impl_.displaytext_.Get();
}
inline void ButtonText::_internal_set_displaytext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.displaytext_.Set(value, GetArenaForAllocation());
}
inline std::string* ButtonText::_internal_mutable_displaytext() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.displaytext_.Mutable(GetArenaForAllocation());
}
inline std::string* ButtonText::release_displaytext() {
  // @@protoc_insertion_point(field_release:proto.ButtonText.displayText)
  if (!_internal_has_displaytext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.displaytext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displaytext_.IsDefault()) {
    _impl_.displaytext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ButtonText::set_allocated_displaytext(std::string* displaytext) {
  if (displaytext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.displaytext_.SetAllocated(displaytext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displaytext_.IsDefault()) {
    _impl_.displaytext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ButtonText.displayText)
}

// -------------------------------------------------------------------

// Button

// optional string buttonId = 1;
inline bool Button::_internal_has_buttonid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Button::has_buttonid() const {
  return _internal_has_buttonid();
}
inline void Button::clear_buttonid() {
  _impl_.buttonid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Button::buttonid() const {
  // @@protoc_insertion_point(field_get:proto.Button.buttonId)
  return _internal_buttonid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Button::set_buttonid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.buttonid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Button.buttonId)
}
inline std::string* Button::mutable_buttonid() {
  std::string* _s = _internal_mutable_buttonid();
  // @@protoc_insertion_point(field_mutable:proto.Button.buttonId)
  return _s;
}
inline const std::string& Button::_internal_buttonid() const {
  return _impl_.buttonid_.Get();
}
inline void Button::_internal_set_buttonid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.buttonid_.Set(value, GetArenaForAllocation());
}
inline std::string* Button::_internal_mutable_buttonid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.buttonid_.Mutable(GetArenaForAllocation());
}
inline std::string* Button::release_buttonid() {
  // @@protoc_insertion_point(field_release:proto.Button.buttonId)
  if (!_internal_has_buttonid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.buttonid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buttonid_.IsDefault()) {
    _impl_.buttonid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Button::set_allocated_buttonid(std::string* buttonid) {
  if (buttonid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.buttonid_.SetAllocated(buttonid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buttonid_.IsDefault()) {
    _impl_.buttonid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Button.buttonId)
}

// optional .proto.ButtonText buttonText = 2;
inline bool Button::_internal_has_buttontext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.buttontext_ != nullptr);
  return value;
}
inline bool Button::has_buttontext() const {
  return _internal_has_buttontext();
}
inline void Button::clear_buttontext() {
  if (_impl_.buttontext_ != nullptr) _impl_.buttontext_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::ButtonText& Button::_internal_buttontext() const {
  const ::proto::ButtonText* p = _impl_.buttontext_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ButtonText&>(
      ::proto::_ButtonText_default_instance_);
}
inline const ::proto::ButtonText& Button::buttontext() const {
  // @@protoc_insertion_point(field_get:proto.Button.buttonText)
  return _internal_buttontext();
}
inline void Button::unsafe_arena_set_allocated_buttontext(
    ::proto::ButtonText* buttontext) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.buttontext_);
  }
  _impl_.buttontext_ = buttontext;
  if (buttontext) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Button.buttonText)
}
inline ::proto::ButtonText* Button::release_buttontext() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::ButtonText* temp = _impl_.buttontext_;
  _impl_.buttontext_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ButtonText* Button::unsafe_arena_release_buttontext() {
  // @@protoc_insertion_point(field_release:proto.Button.buttonText)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::ButtonText* temp = _impl_.buttontext_;
  _impl_.buttontext_ = nullptr;
  return temp;
}
inline ::proto::ButtonText* Button::_internal_mutable_buttontext() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.buttontext_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ButtonText>(GetArenaForAllocation());
    _impl_.buttontext_ = p;
  }
  return _impl_.buttontext_;
}
inline ::proto::ButtonText* Button::mutable_buttontext() {
  ::proto::ButtonText* _msg = _internal_mutable_buttontext();
  // @@protoc_insertion_point(field_mutable:proto.Button.buttonText)
  return _msg;
}
inline void Button::set_allocated_buttontext(::proto::ButtonText* buttontext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.buttontext_;
  }
  if (buttontext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(buttontext);
    if (message_arena != submessage_arena) {
      buttontext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buttontext, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.buttontext_ = buttontext;
  // @@protoc_insertion_point(field_set_allocated:proto.Button.buttonText)
}

// optional .proto.Button.ButtonType type = 3;
inline bool Button::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Button::has_type() const {
  return _internal_has_type();
}
inline void Button::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::proto::Button_ButtonType Button::_internal_type() const {
  return static_cast< ::proto::Button_ButtonType >(_impl_.type_);
}
inline ::proto::Button_ButtonType Button::type() const {
  // @@protoc_insertion_point(field_get:proto.Button.type)
  return _internal_type();
}
inline void Button::_internal_set_type(::proto::Button_ButtonType value) {
  assert(::proto::Button_ButtonType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}
inline void Button::set_type(::proto::Button_ButtonType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.Button.type)
}

// -------------------------------------------------------------------

// ButtonsMessage

// optional string contentText = 6;
inline bool ButtonsMessage::_internal_has_contenttext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ButtonsMessage::has_contenttext() const {
  return _internal_has_contenttext();
}
inline void ButtonsMessage::clear_contenttext() {
  _impl_.contenttext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ButtonsMessage::contenttext() const {
  // @@protoc_insertion_point(field_get:proto.ButtonsMessage.contentText)
  return _internal_contenttext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ButtonsMessage::set_contenttext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.contenttext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ButtonsMessage.contentText)
}
inline std::string* ButtonsMessage::mutable_contenttext() {
  std::string* _s = _internal_mutable_contenttext();
  // @@protoc_insertion_point(field_mutable:proto.ButtonsMessage.contentText)
  return _s;
}
inline const std::string& ButtonsMessage::_internal_contenttext() const {
  return _impl_.contenttext_.Get();
}
inline void ButtonsMessage::_internal_set_contenttext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.contenttext_.Set(value, GetArenaForAllocation());
}
inline std::string* ButtonsMessage::_internal_mutable_contenttext() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.contenttext_.Mutable(GetArenaForAllocation());
}
inline std::string* ButtonsMessage::release_contenttext() {
  // @@protoc_insertion_point(field_release:proto.ButtonsMessage.contentText)
  if (!_internal_has_contenttext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.contenttext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contenttext_.IsDefault()) {
    _impl_.contenttext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ButtonsMessage::set_allocated_contenttext(std::string* contenttext) {
  if (contenttext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.contenttext_.SetAllocated(contenttext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contenttext_.IsDefault()) {
    _impl_.contenttext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ButtonsMessage.contentText)
}

// optional string footerText = 7;
inline bool ButtonsMessage::_internal_has_footertext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ButtonsMessage::has_footertext() const {
  return _internal_has_footertext();
}
inline void ButtonsMessage::clear_footertext() {
  _impl_.footertext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ButtonsMessage::footertext() const {
  // @@protoc_insertion_point(field_get:proto.ButtonsMessage.footerText)
  return _internal_footertext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ButtonsMessage::set_footertext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.footertext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ButtonsMessage.footerText)
}
inline std::string* ButtonsMessage::mutable_footertext() {
  std::string* _s = _internal_mutable_footertext();
  // @@protoc_insertion_point(field_mutable:proto.ButtonsMessage.footerText)
  return _s;
}
inline const std::string& ButtonsMessage::_internal_footertext() const {
  return _impl_.footertext_.Get();
}
inline void ButtonsMessage::_internal_set_footertext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.footertext_.Set(value, GetArenaForAllocation());
}
inline std::string* ButtonsMessage::_internal_mutable_footertext() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.footertext_.Mutable(GetArenaForAllocation());
}
inline std::string* ButtonsMessage::release_footertext() {
  // @@protoc_insertion_point(field_release:proto.ButtonsMessage.footerText)
  if (!_internal_has_footertext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.footertext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.footertext_.IsDefault()) {
    _impl_.footertext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ButtonsMessage::set_allocated_footertext(std::string* footertext) {
  if (footertext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.footertext_.SetAllocated(footertext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.footertext_.IsDefault()) {
    _impl_.footertext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ButtonsMessage.footerText)
}

// optional .proto.ContextInfo contextInfo = 8;
inline bool ButtonsMessage::_internal_has_contextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contextinfo_ != nullptr);
  return value;
}
inline bool ButtonsMessage::has_contextinfo() const {
  return _internal_has_contextinfo();
}
inline void ButtonsMessage::clear_contextinfo() {
  if (_impl_.contextinfo_ != nullptr) _impl_.contextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::proto::ContextInfo& ButtonsMessage::_internal_contextinfo() const {
  const ::proto::ContextInfo* p = _impl_.contextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContextInfo&>(
      ::proto::_ContextInfo_default_instance_);
}
inline const ::proto::ContextInfo& ButtonsMessage::contextinfo() const {
  // @@protoc_insertion_point(field_get:proto.ButtonsMessage.contextInfo)
  return _internal_contextinfo();
}
inline void ButtonsMessage::unsafe_arena_set_allocated_contextinfo(
    ::proto::ContextInfo* contextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextinfo_);
  }
  _impl_.contextinfo_ = contextinfo;
  if (contextinfo) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ButtonsMessage.contextInfo)
}
inline ::proto::ContextInfo* ButtonsMessage::release_contextinfo() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContextInfo* ButtonsMessage::unsafe_arena_release_contextinfo() {
  // @@protoc_insertion_point(field_release:proto.ButtonsMessage.contextInfo)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
  return temp;
}
inline ::proto::ContextInfo* ButtonsMessage::_internal_mutable_contextinfo() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.contextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContextInfo>(GetArenaForAllocation());
    _impl_.contextinfo_ = p;
  }
  return _impl_.contextinfo_;
}
inline ::proto::ContextInfo* ButtonsMessage::mutable_contextinfo() {
  ::proto::ContextInfo* _msg = _internal_mutable_contextinfo();
  // @@protoc_insertion_point(field_mutable:proto.ButtonsMessage.contextInfo)
  return _msg;
}
inline void ButtonsMessage::set_allocated_contextinfo(::proto::ContextInfo* contextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contextinfo_;
  }
  if (contextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contextinfo);
    if (message_arena != submessage_arena) {
      contextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.contextinfo_ = contextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.ButtonsMessage.contextInfo)
}

// repeated .proto.Button buttons = 9;
inline int ButtonsMessage::_internal_buttons_size() const {
  return _impl_.buttons_.size();
}
inline int ButtonsMessage::buttons_size() const {
  return _internal_buttons_size();
}
inline void ButtonsMessage::clear_buttons() {
  _impl_.buttons_.Clear();
}
inline ::proto::Button* ButtonsMessage::mutable_buttons(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ButtonsMessage.buttons)
  return _impl_.buttons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Button >*
ButtonsMessage::mutable_buttons() {
  // @@protoc_insertion_point(field_mutable_list:proto.ButtonsMessage.buttons)
  return &_impl_.buttons_;
}
inline const ::proto::Button& ButtonsMessage::_internal_buttons(int index) const {
  return _impl_.buttons_.Get(index);
}
inline const ::proto::Button& ButtonsMessage::buttons(int index) const {
  // @@protoc_insertion_point(field_get:proto.ButtonsMessage.buttons)
  return _internal_buttons(index);
}
inline ::proto::Button* ButtonsMessage::_internal_add_buttons() {
  return _impl_.buttons_.Add();
}
inline ::proto::Button* ButtonsMessage::add_buttons() {
  ::proto::Button* _add = _internal_add_buttons();
  // @@protoc_insertion_point(field_add:proto.ButtonsMessage.buttons)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Button >&
ButtonsMessage::buttons() const {
  // @@protoc_insertion_point(field_list:proto.ButtonsMessage.buttons)
  return _impl_.buttons_;
}

// optional .proto.ButtonsMessage.ButtonsMessageHeaderType headerType = 10;
inline bool ButtonsMessage::_internal_has_headertype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ButtonsMessage::has_headertype() const {
  return _internal_has_headertype();
}
inline void ButtonsMessage::clear_headertype() {
  _impl_.headertype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::proto::ButtonsMessage_ButtonsMessageHeaderType ButtonsMessage::_internal_headertype() const {
  return static_cast< ::proto::ButtonsMessage_ButtonsMessageHeaderType >(_impl_.headertype_);
}
inline ::proto::ButtonsMessage_ButtonsMessageHeaderType ButtonsMessage::headertype() const {
  // @@protoc_insertion_point(field_get:proto.ButtonsMessage.headerType)
  return _internal_headertype();
}
inline void ButtonsMessage::_internal_set_headertype(::proto::ButtonsMessage_ButtonsMessageHeaderType value) {
  assert(::proto::ButtonsMessage_ButtonsMessageHeaderType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.headertype_ = value;
}
inline void ButtonsMessage::set_headertype(::proto::ButtonsMessage_ButtonsMessageHeaderType value) {
  _internal_set_headertype(value);
  // @@protoc_insertion_point(field_set:proto.ButtonsMessage.headerType)
}

// string text = 1;
inline bool ButtonsMessage::_internal_has_text() const {
  return header_case() == kText;
}
inline bool ButtonsMessage::has_text() const {
  return _internal_has_text();
}
inline void ButtonsMessage::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void ButtonsMessage::clear_text() {
  if (_internal_has_text()) {
    _impl_.header_.text_.Destroy();
    clear_has_header();
  }
}
inline const std::string& ButtonsMessage::text() const {
  // @@protoc_insertion_point(field_get:proto.ButtonsMessage.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline void ButtonsMessage::set_text(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text()) {
    clear_header();
    set_has_text();
    _impl_.header_.text_.InitDefault();
  }
  _impl_.header_.text_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ButtonsMessage.text)
}
inline std::string* ButtonsMessage::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:proto.ButtonsMessage.text)
  return _s;
}
inline const std::string& ButtonsMessage::_internal_text() const {
  if (_internal_has_text()) {
    return _impl_.header_.text_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ButtonsMessage::_internal_set_text(const std::string& value) {
  if (!_internal_has_text()) {
    clear_header();
    set_has_text();
    _impl_.header_.text_.InitDefault();
  }
  _impl_.header_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* ButtonsMessage::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_header();
    set_has_text();
    _impl_.header_.text_.InitDefault();
  }
  return _impl_.header_.text_.Mutable(      GetArenaForAllocation());
}
inline std::string* ButtonsMessage::release_text() {
  // @@protoc_insertion_point(field_release:proto.ButtonsMessage.text)
  if (_internal_has_text()) {
    clear_has_header();
    return _impl_.header_.text_.Release();
  } else {
    return nullptr;
  }
}
inline void ButtonsMessage::set_allocated_text(std::string* text) {
  if (has_header()) {
    clear_header();
  }
  if (text != nullptr) {
    set_has_text();
    _impl_.header_.text_.InitAllocated(text, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ButtonsMessage.text)
}

// .proto.DocumentMessage documentMessage = 2;
inline bool ButtonsMessage::_internal_has_documentmessage() const {
  return header_case() == kDocumentMessage;
}
inline bool ButtonsMessage::has_documentmessage() const {
  return _internal_has_documentmessage();
}
inline void ButtonsMessage::set_has_documentmessage() {
  _impl_._oneof_case_[0] = kDocumentMessage;
}
inline void ButtonsMessage::clear_documentmessage() {
  if (_internal_has_documentmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.header_.documentmessage_;
    }
    clear_has_header();
  }
}
inline ::proto::DocumentMessage* ButtonsMessage::release_documentmessage() {
  // @@protoc_insertion_point(field_release:proto.ButtonsMessage.documentMessage)
  if (_internal_has_documentmessage()) {
    clear_has_header();
    ::proto::DocumentMessage* temp = _impl_.header_.documentmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.header_.documentmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::DocumentMessage& ButtonsMessage::_internal_documentmessage() const {
  return _internal_has_documentmessage()
      ? *_impl_.header_.documentmessage_
      : reinterpret_cast< ::proto::DocumentMessage&>(::proto::_DocumentMessage_default_instance_);
}
inline const ::proto::DocumentMessage& ButtonsMessage::documentmessage() const {
  // @@protoc_insertion_point(field_get:proto.ButtonsMessage.documentMessage)
  return _internal_documentmessage();
}
inline ::proto::DocumentMessage* ButtonsMessage::unsafe_arena_release_documentmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.ButtonsMessage.documentMessage)
  if (_internal_has_documentmessage()) {
    clear_has_header();
    ::proto::DocumentMessage* temp = _impl_.header_.documentmessage_;
    _impl_.header_.documentmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ButtonsMessage::unsafe_arena_set_allocated_documentmessage(::proto::DocumentMessage* documentmessage) {
  clear_header();
  if (documentmessage) {
    set_has_documentmessage();
    _impl_.header_.documentmessage_ = documentmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ButtonsMessage.documentMessage)
}
inline ::proto::DocumentMessage* ButtonsMessage::_internal_mutable_documentmessage() {
  if (!_internal_has_documentmessage()) {
    clear_header();
    set_has_documentmessage();
    _impl_.header_.documentmessage_ = CreateMaybeMessage< ::proto::DocumentMessage >(GetArenaForAllocation());
  }
  return _impl_.header_.documentmessage_;
}
inline ::proto::DocumentMessage* ButtonsMessage::mutable_documentmessage() {
  ::proto::DocumentMessage* _msg = _internal_mutable_documentmessage();
  // @@protoc_insertion_point(field_mutable:proto.ButtonsMessage.documentMessage)
  return _msg;
}

// .proto.ImageMessage imageMessage = 3;
inline bool ButtonsMessage::_internal_has_imagemessage() const {
  return header_case() == kImageMessage;
}
inline bool ButtonsMessage::has_imagemessage() const {
  return _internal_has_imagemessage();
}
inline void ButtonsMessage::set_has_imagemessage() {
  _impl_._oneof_case_[0] = kImageMessage;
}
inline void ButtonsMessage::clear_imagemessage() {
  if (_internal_has_imagemessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.header_.imagemessage_;
    }
    clear_has_header();
  }
}
inline ::proto::ImageMessage* ButtonsMessage::release_imagemessage() {
  // @@protoc_insertion_point(field_release:proto.ButtonsMessage.imageMessage)
  if (_internal_has_imagemessage()) {
    clear_has_header();
    ::proto::ImageMessage* temp = _impl_.header_.imagemessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.header_.imagemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ImageMessage& ButtonsMessage::_internal_imagemessage() const {
  return _internal_has_imagemessage()
      ? *_impl_.header_.imagemessage_
      : reinterpret_cast< ::proto::ImageMessage&>(::proto::_ImageMessage_default_instance_);
}
inline const ::proto::ImageMessage& ButtonsMessage::imagemessage() const {
  // @@protoc_insertion_point(field_get:proto.ButtonsMessage.imageMessage)
  return _internal_imagemessage();
}
inline ::proto::ImageMessage* ButtonsMessage::unsafe_arena_release_imagemessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.ButtonsMessage.imageMessage)
  if (_internal_has_imagemessage()) {
    clear_has_header();
    ::proto::ImageMessage* temp = _impl_.header_.imagemessage_;
    _impl_.header_.imagemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ButtonsMessage::unsafe_arena_set_allocated_imagemessage(::proto::ImageMessage* imagemessage) {
  clear_header();
  if (imagemessage) {
    set_has_imagemessage();
    _impl_.header_.imagemessage_ = imagemessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ButtonsMessage.imageMessage)
}
inline ::proto::ImageMessage* ButtonsMessage::_internal_mutable_imagemessage() {
  if (!_internal_has_imagemessage()) {
    clear_header();
    set_has_imagemessage();
    _impl_.header_.imagemessage_ = CreateMaybeMessage< ::proto::ImageMessage >(GetArenaForAllocation());
  }
  return _impl_.header_.imagemessage_;
}
inline ::proto::ImageMessage* ButtonsMessage::mutable_imagemessage() {
  ::proto::ImageMessage* _msg = _internal_mutable_imagemessage();
  // @@protoc_insertion_point(field_mutable:proto.ButtonsMessage.imageMessage)
  return _msg;
}

// .proto.VideoMessage videoMessage = 4;
inline bool ButtonsMessage::_internal_has_videomessage() const {
  return header_case() == kVideoMessage;
}
inline bool ButtonsMessage::has_videomessage() const {
  return _internal_has_videomessage();
}
inline void ButtonsMessage::set_has_videomessage() {
  _impl_._oneof_case_[0] = kVideoMessage;
}
inline void ButtonsMessage::clear_videomessage() {
  if (_internal_has_videomessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.header_.videomessage_;
    }
    clear_has_header();
  }
}
inline ::proto::VideoMessage* ButtonsMessage::release_videomessage() {
  // @@protoc_insertion_point(field_release:proto.ButtonsMessage.videoMessage)
  if (_internal_has_videomessage()) {
    clear_has_header();
    ::proto::VideoMessage* temp = _impl_.header_.videomessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.header_.videomessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::VideoMessage& ButtonsMessage::_internal_videomessage() const {
  return _internal_has_videomessage()
      ? *_impl_.header_.videomessage_
      : reinterpret_cast< ::proto::VideoMessage&>(::proto::_VideoMessage_default_instance_);
}
inline const ::proto::VideoMessage& ButtonsMessage::videomessage() const {
  // @@protoc_insertion_point(field_get:proto.ButtonsMessage.videoMessage)
  return _internal_videomessage();
}
inline ::proto::VideoMessage* ButtonsMessage::unsafe_arena_release_videomessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.ButtonsMessage.videoMessage)
  if (_internal_has_videomessage()) {
    clear_has_header();
    ::proto::VideoMessage* temp = _impl_.header_.videomessage_;
    _impl_.header_.videomessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ButtonsMessage::unsafe_arena_set_allocated_videomessage(::proto::VideoMessage* videomessage) {
  clear_header();
  if (videomessage) {
    set_has_videomessage();
    _impl_.header_.videomessage_ = videomessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ButtonsMessage.videoMessage)
}
inline ::proto::VideoMessage* ButtonsMessage::_internal_mutable_videomessage() {
  if (!_internal_has_videomessage()) {
    clear_header();
    set_has_videomessage();
    _impl_.header_.videomessage_ = CreateMaybeMessage< ::proto::VideoMessage >(GetArenaForAllocation());
  }
  return _impl_.header_.videomessage_;
}
inline ::proto::VideoMessage* ButtonsMessage::mutable_videomessage() {
  ::proto::VideoMessage* _msg = _internal_mutable_videomessage();
  // @@protoc_insertion_point(field_mutable:proto.ButtonsMessage.videoMessage)
  return _msg;
}

// .proto.LocationMessage locationMessage = 5;
inline bool ButtonsMessage::_internal_has_locationmessage() const {
  return header_case() == kLocationMessage;
}
inline bool ButtonsMessage::has_locationmessage() const {
  return _internal_has_locationmessage();
}
inline void ButtonsMessage::set_has_locationmessage() {
  _impl_._oneof_case_[0] = kLocationMessage;
}
inline void ButtonsMessage::clear_locationmessage() {
  if (_internal_has_locationmessage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.header_.locationmessage_;
    }
    clear_has_header();
  }
}
inline ::proto::LocationMessage* ButtonsMessage::release_locationmessage() {
  // @@protoc_insertion_point(field_release:proto.ButtonsMessage.locationMessage)
  if (_internal_has_locationmessage()) {
    clear_has_header();
    ::proto::LocationMessage* temp = _impl_.header_.locationmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.header_.locationmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::LocationMessage& ButtonsMessage::_internal_locationmessage() const {
  return _internal_has_locationmessage()
      ? *_impl_.header_.locationmessage_
      : reinterpret_cast< ::proto::LocationMessage&>(::proto::_LocationMessage_default_instance_);
}
inline const ::proto::LocationMessage& ButtonsMessage::locationmessage() const {
  // @@protoc_insertion_point(field_get:proto.ButtonsMessage.locationMessage)
  return _internal_locationmessage();
}
inline ::proto::LocationMessage* ButtonsMessage::unsafe_arena_release_locationmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.ButtonsMessage.locationMessage)
  if (_internal_has_locationmessage()) {
    clear_has_header();
    ::proto::LocationMessage* temp = _impl_.header_.locationmessage_;
    _impl_.header_.locationmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ButtonsMessage::unsafe_arena_set_allocated_locationmessage(::proto::LocationMessage* locationmessage) {
  clear_header();
  if (locationmessage) {
    set_has_locationmessage();
    _impl_.header_.locationmessage_ = locationmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ButtonsMessage.locationMessage)
}
inline ::proto::LocationMessage* ButtonsMessage::_internal_mutable_locationmessage() {
  if (!_internal_has_locationmessage()) {
    clear_header();
    set_has_locationmessage();
    _impl_.header_.locationmessage_ = CreateMaybeMessage< ::proto::LocationMessage >(GetArenaForAllocation());
  }
  return _impl_.header_.locationmessage_;
}
inline ::proto::LocationMessage* ButtonsMessage::mutable_locationmessage() {
  ::proto::LocationMessage* _msg = _internal_mutable_locationmessage();
  // @@protoc_insertion_point(field_mutable:proto.ButtonsMessage.locationMessage)
  return _msg;
}

inline bool ButtonsMessage::has_header() const {
  return header_case() != HEADER_NOT_SET;
}
inline void ButtonsMessage::clear_has_header() {
  _impl_._oneof_case_[0] = HEADER_NOT_SET;
}
inline ButtonsMessage::HeaderCase ButtonsMessage::header_case() const {
  return ButtonsMessage::HeaderCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ButtonsResponseMessage

// optional string selectedButtonId = 1;
inline bool ButtonsResponseMessage::_internal_has_selectedbuttonid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ButtonsResponseMessage::has_selectedbuttonid() const {
  return _internal_has_selectedbuttonid();
}
inline void ButtonsResponseMessage::clear_selectedbuttonid() {
  _impl_.selectedbuttonid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ButtonsResponseMessage::selectedbuttonid() const {
  // @@protoc_insertion_point(field_get:proto.ButtonsResponseMessage.selectedButtonId)
  return _internal_selectedbuttonid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ButtonsResponseMessage::set_selectedbuttonid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.selectedbuttonid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ButtonsResponseMessage.selectedButtonId)
}
inline std::string* ButtonsResponseMessage::mutable_selectedbuttonid() {
  std::string* _s = _internal_mutable_selectedbuttonid();
  // @@protoc_insertion_point(field_mutable:proto.ButtonsResponseMessage.selectedButtonId)
  return _s;
}
inline const std::string& ButtonsResponseMessage::_internal_selectedbuttonid() const {
  return _impl_.selectedbuttonid_.Get();
}
inline void ButtonsResponseMessage::_internal_set_selectedbuttonid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.selectedbuttonid_.Set(value, GetArenaForAllocation());
}
inline std::string* ButtonsResponseMessage::_internal_mutable_selectedbuttonid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.selectedbuttonid_.Mutable(GetArenaForAllocation());
}
inline std::string* ButtonsResponseMessage::release_selectedbuttonid() {
  // @@protoc_insertion_point(field_release:proto.ButtonsResponseMessage.selectedButtonId)
  if (!_internal_has_selectedbuttonid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.selectedbuttonid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.selectedbuttonid_.IsDefault()) {
    _impl_.selectedbuttonid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ButtonsResponseMessage::set_allocated_selectedbuttonid(std::string* selectedbuttonid) {
  if (selectedbuttonid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.selectedbuttonid_.SetAllocated(selectedbuttonid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.selectedbuttonid_.IsDefault()) {
    _impl_.selectedbuttonid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ButtonsResponseMessage.selectedButtonId)
}

// optional .proto.ContextInfo contextInfo = 3;
inline bool ButtonsResponseMessage::_internal_has_contextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contextinfo_ != nullptr);
  return value;
}
inline bool ButtonsResponseMessage::has_contextinfo() const {
  return _internal_has_contextinfo();
}
inline void ButtonsResponseMessage::clear_contextinfo() {
  if (_impl_.contextinfo_ != nullptr) _impl_.contextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::ContextInfo& ButtonsResponseMessage::_internal_contextinfo() const {
  const ::proto::ContextInfo* p = _impl_.contextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContextInfo&>(
      ::proto::_ContextInfo_default_instance_);
}
inline const ::proto::ContextInfo& ButtonsResponseMessage::contextinfo() const {
  // @@protoc_insertion_point(field_get:proto.ButtonsResponseMessage.contextInfo)
  return _internal_contextinfo();
}
inline void ButtonsResponseMessage::unsafe_arena_set_allocated_contextinfo(
    ::proto::ContextInfo* contextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextinfo_);
  }
  _impl_.contextinfo_ = contextinfo;
  if (contextinfo) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ButtonsResponseMessage.contextInfo)
}
inline ::proto::ContextInfo* ButtonsResponseMessage::release_contextinfo() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContextInfo* ButtonsResponseMessage::unsafe_arena_release_contextinfo() {
  // @@protoc_insertion_point(field_release:proto.ButtonsResponseMessage.contextInfo)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::ContextInfo* temp = _impl_.contextinfo_;
  _impl_.contextinfo_ = nullptr;
  return temp;
}
inline ::proto::ContextInfo* ButtonsResponseMessage::_internal_mutable_contextinfo() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.contextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContextInfo>(GetArenaForAllocation());
    _impl_.contextinfo_ = p;
  }
  return _impl_.contextinfo_;
}
inline ::proto::ContextInfo* ButtonsResponseMessage::mutable_contextinfo() {
  ::proto::ContextInfo* _msg = _internal_mutable_contextinfo();
  // @@protoc_insertion_point(field_mutable:proto.ButtonsResponseMessage.contextInfo)
  return _msg;
}
inline void ButtonsResponseMessage::set_allocated_contextinfo(::proto::ContextInfo* contextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contextinfo_;
  }
  if (contextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contextinfo);
    if (message_arena != submessage_arena) {
      contextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.contextinfo_ = contextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.ButtonsResponseMessage.contextInfo)
}

// optional .proto.ButtonsResponseMessage.ButtonsResponseMessageType type = 4;
inline bool ButtonsResponseMessage::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ButtonsResponseMessage::has_type() const {
  return _internal_has_type();
}
inline void ButtonsResponseMessage::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::proto::ButtonsResponseMessage_ButtonsResponseMessageType ButtonsResponseMessage::_internal_type() const {
  return static_cast< ::proto::ButtonsResponseMessage_ButtonsResponseMessageType >(_impl_.type_);
}
inline ::proto::ButtonsResponseMessage_ButtonsResponseMessageType ButtonsResponseMessage::type() const {
  // @@protoc_insertion_point(field_get:proto.ButtonsResponseMessage.type)
  return _internal_type();
}
inline void ButtonsResponseMessage::_internal_set_type(::proto::ButtonsResponseMessage_ButtonsResponseMessageType value) {
  assert(::proto::ButtonsResponseMessage_ButtonsResponseMessageType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}
inline void ButtonsResponseMessage::set_type(::proto::ButtonsResponseMessage_ButtonsResponseMessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:proto.ButtonsResponseMessage.type)
}

// string selectedDisplayText = 2;
inline bool ButtonsResponseMessage::_internal_has_selecteddisplaytext() const {
  return response_case() == kSelectedDisplayText;
}
inline bool ButtonsResponseMessage::has_selecteddisplaytext() const {
  return _internal_has_selecteddisplaytext();
}
inline void ButtonsResponseMessage::set_has_selecteddisplaytext() {
  _impl_._oneof_case_[0] = kSelectedDisplayText;
}
inline void ButtonsResponseMessage::clear_selecteddisplaytext() {
  if (_internal_has_selecteddisplaytext()) {
    _impl_.response_.selecteddisplaytext_.Destroy();
    clear_has_response();
  }
}
inline const std::string& ButtonsResponseMessage::selecteddisplaytext() const {
  // @@protoc_insertion_point(field_get:proto.ButtonsResponseMessage.selectedDisplayText)
  return _internal_selecteddisplaytext();
}
template <typename ArgT0, typename... ArgT>
inline void ButtonsResponseMessage::set_selecteddisplaytext(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_selecteddisplaytext()) {
    clear_response();
    set_has_selecteddisplaytext();
    _impl_.response_.selecteddisplaytext_.InitDefault();
  }
  _impl_.response_.selecteddisplaytext_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ButtonsResponseMessage.selectedDisplayText)
}
inline std::string* ButtonsResponseMessage::mutable_selecteddisplaytext() {
  std::string* _s = _internal_mutable_selecteddisplaytext();
  // @@protoc_insertion_point(field_mutable:proto.ButtonsResponseMessage.selectedDisplayText)
  return _s;
}
inline const std::string& ButtonsResponseMessage::_internal_selecteddisplaytext() const {
  if (_internal_has_selecteddisplaytext()) {
    return _impl_.response_.selecteddisplaytext_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ButtonsResponseMessage::_internal_set_selecteddisplaytext(const std::string& value) {
  if (!_internal_has_selecteddisplaytext()) {
    clear_response();
    set_has_selecteddisplaytext();
    _impl_.response_.selecteddisplaytext_.InitDefault();
  }
  _impl_.response_.selecteddisplaytext_.Set(value, GetArenaForAllocation());
}
inline std::string* ButtonsResponseMessage::_internal_mutable_selecteddisplaytext() {
  if (!_internal_has_selecteddisplaytext()) {
    clear_response();
    set_has_selecteddisplaytext();
    _impl_.response_.selecteddisplaytext_.InitDefault();
  }
  return _impl_.response_.selecteddisplaytext_.Mutable(      GetArenaForAllocation());
}
inline std::string* ButtonsResponseMessage::release_selecteddisplaytext() {
  // @@protoc_insertion_point(field_release:proto.ButtonsResponseMessage.selectedDisplayText)
  if (_internal_has_selecteddisplaytext()) {
    clear_has_response();
    return _impl_.response_.selecteddisplaytext_.Release();
  } else {
    return nullptr;
  }
}
inline void ButtonsResponseMessage::set_allocated_selecteddisplaytext(std::string* selecteddisplaytext) {
  if (has_response()) {
    clear_response();
  }
  if (selecteddisplaytext != nullptr) {
    set_has_selecteddisplaytext();
    _impl_.response_.selecteddisplaytext_.InitAllocated(selecteddisplaytext, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ButtonsResponseMessage.selectedDisplayText)
}

inline bool ButtonsResponseMessage::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void ButtonsResponseMessage::clear_has_response() {
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}
inline ButtonsResponseMessage::ResponseCase ButtonsResponseMessage::response_case() const {
  return ButtonsResponseMessage::ResponseCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Message

// optional string conversation = 1;
inline bool Message::_internal_has_conversation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Message::has_conversation() const {
  return _internal_has_conversation();
}
inline void Message::clear_conversation() {
  _impl_.conversation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Message::conversation() const {
  // @@protoc_insertion_point(field_get:proto.Message.conversation)
  return _internal_conversation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_conversation(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.conversation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Message.conversation)
}
inline std::string* Message::mutable_conversation() {
  std::string* _s = _internal_mutable_conversation();
  // @@protoc_insertion_point(field_mutable:proto.Message.conversation)
  return _s;
}
inline const std::string& Message::_internal_conversation() const {
  return _impl_.conversation_.Get();
}
inline void Message::_internal_set_conversation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.conversation_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_conversation() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.conversation_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_conversation() {
  // @@protoc_insertion_point(field_release:proto.Message.conversation)
  if (!_internal_has_conversation()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.conversation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversation_.IsDefault()) {
    _impl_.conversation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Message::set_allocated_conversation(std::string* conversation) {
  if (conversation != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.conversation_.SetAllocated(conversation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversation_.IsDefault()) {
    _impl_.conversation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Message.conversation)
}

// optional .proto.SenderKeyDistributionMessage senderKeyDistributionMessage = 2;
inline bool Message::_internal_has_senderkeydistributionmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.senderkeydistributionmessage_ != nullptr);
  return value;
}
inline bool Message::has_senderkeydistributionmessage() const {
  return _internal_has_senderkeydistributionmessage();
}
inline void Message::clear_senderkeydistributionmessage() {
  if (_impl_.senderkeydistributionmessage_ != nullptr) _impl_.senderkeydistributionmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::SenderKeyDistributionMessage& Message::_internal_senderkeydistributionmessage() const {
  const ::proto::SenderKeyDistributionMessage* p = _impl_.senderkeydistributionmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::SenderKeyDistributionMessage&>(
      ::proto::_SenderKeyDistributionMessage_default_instance_);
}
inline const ::proto::SenderKeyDistributionMessage& Message::senderkeydistributionmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.senderKeyDistributionMessage)
  return _internal_senderkeydistributionmessage();
}
inline void Message::unsafe_arena_set_allocated_senderkeydistributionmessage(
    ::proto::SenderKeyDistributionMessage* senderkeydistributionmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.senderkeydistributionmessage_);
  }
  _impl_.senderkeydistributionmessage_ = senderkeydistributionmessage;
  if (senderkeydistributionmessage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.senderKeyDistributionMessage)
}
inline ::proto::SenderKeyDistributionMessage* Message::release_senderkeydistributionmessage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::SenderKeyDistributionMessage* temp = _impl_.senderkeydistributionmessage_;
  _impl_.senderkeydistributionmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::SenderKeyDistributionMessage* Message::unsafe_arena_release_senderkeydistributionmessage() {
  // @@protoc_insertion_point(field_release:proto.Message.senderKeyDistributionMessage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::SenderKeyDistributionMessage* temp = _impl_.senderkeydistributionmessage_;
  _impl_.senderkeydistributionmessage_ = nullptr;
  return temp;
}
inline ::proto::SenderKeyDistributionMessage* Message::_internal_mutable_senderkeydistributionmessage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.senderkeydistributionmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::SenderKeyDistributionMessage>(GetArenaForAllocation());
    _impl_.senderkeydistributionmessage_ = p;
  }
  return _impl_.senderkeydistributionmessage_;
}
inline ::proto::SenderKeyDistributionMessage* Message::mutable_senderkeydistributionmessage() {
  ::proto::SenderKeyDistributionMessage* _msg = _internal_mutable_senderkeydistributionmessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.senderKeyDistributionMessage)
  return _msg;
}
inline void Message::set_allocated_senderkeydistributionmessage(::proto::SenderKeyDistributionMessage* senderkeydistributionmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.senderkeydistributionmessage_;
  }
  if (senderkeydistributionmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(senderkeydistributionmessage);
    if (message_arena != submessage_arena) {
      senderkeydistributionmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, senderkeydistributionmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.senderkeydistributionmessage_ = senderkeydistributionmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.senderKeyDistributionMessage)
}

// optional .proto.ImageMessage imageMessage = 3;
inline bool Message::_internal_has_imagemessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.imagemessage_ != nullptr);
  return value;
}
inline bool Message::has_imagemessage() const {
  return _internal_has_imagemessage();
}
inline void Message::clear_imagemessage() {
  if (_impl_.imagemessage_ != nullptr) _impl_.imagemessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::proto::ImageMessage& Message::_internal_imagemessage() const {
  const ::proto::ImageMessage* p = _impl_.imagemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ImageMessage&>(
      ::proto::_ImageMessage_default_instance_);
}
inline const ::proto::ImageMessage& Message::imagemessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.imageMessage)
  return _internal_imagemessage();
}
inline void Message::unsafe_arena_set_allocated_imagemessage(
    ::proto::ImageMessage* imagemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.imagemessage_);
  }
  _impl_.imagemessage_ = imagemessage;
  if (imagemessage) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.imageMessage)
}
inline ::proto::ImageMessage* Message::release_imagemessage() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::ImageMessage* temp = _impl_.imagemessage_;
  _impl_.imagemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ImageMessage* Message::unsafe_arena_release_imagemessage() {
  // @@protoc_insertion_point(field_release:proto.Message.imageMessage)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::ImageMessage* temp = _impl_.imagemessage_;
  _impl_.imagemessage_ = nullptr;
  return temp;
}
inline ::proto::ImageMessage* Message::_internal_mutable_imagemessage() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.imagemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ImageMessage>(GetArenaForAllocation());
    _impl_.imagemessage_ = p;
  }
  return _impl_.imagemessage_;
}
inline ::proto::ImageMessage* Message::mutable_imagemessage() {
  ::proto::ImageMessage* _msg = _internal_mutable_imagemessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.imageMessage)
  return _msg;
}
inline void Message::set_allocated_imagemessage(::proto::ImageMessage* imagemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.imagemessage_;
  }
  if (imagemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(imagemessage);
    if (message_arena != submessage_arena) {
      imagemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imagemessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.imagemessage_ = imagemessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.imageMessage)
}

// optional .proto.ContactMessage contactMessage = 4;
inline bool Message::_internal_has_contactmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contactmessage_ != nullptr);
  return value;
}
inline bool Message::has_contactmessage() const {
  return _internal_has_contactmessage();
}
inline void Message::clear_contactmessage() {
  if (_impl_.contactmessage_ != nullptr) _impl_.contactmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::proto::ContactMessage& Message::_internal_contactmessage() const {
  const ::proto::ContactMessage* p = _impl_.contactmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContactMessage&>(
      ::proto::_ContactMessage_default_instance_);
}
inline const ::proto::ContactMessage& Message::contactmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.contactMessage)
  return _internal_contactmessage();
}
inline void Message::unsafe_arena_set_allocated_contactmessage(
    ::proto::ContactMessage* contactmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contactmessage_);
  }
  _impl_.contactmessage_ = contactmessage;
  if (contactmessage) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.contactMessage)
}
inline ::proto::ContactMessage* Message::release_contactmessage() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::proto::ContactMessage* temp = _impl_.contactmessage_;
  _impl_.contactmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContactMessage* Message::unsafe_arena_release_contactmessage() {
  // @@protoc_insertion_point(field_release:proto.Message.contactMessage)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::proto::ContactMessage* temp = _impl_.contactmessage_;
  _impl_.contactmessage_ = nullptr;
  return temp;
}
inline ::proto::ContactMessage* Message::_internal_mutable_contactmessage() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.contactmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContactMessage>(GetArenaForAllocation());
    _impl_.contactmessage_ = p;
  }
  return _impl_.contactmessage_;
}
inline ::proto::ContactMessage* Message::mutable_contactmessage() {
  ::proto::ContactMessage* _msg = _internal_mutable_contactmessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.contactMessage)
  return _msg;
}
inline void Message::set_allocated_contactmessage(::proto::ContactMessage* contactmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contactmessage_;
  }
  if (contactmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contactmessage);
    if (message_arena != submessage_arena) {
      contactmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contactmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.contactmessage_ = contactmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.contactMessage)
}

// optional .proto.LocationMessage locationMessage = 5;
inline bool Message::_internal_has_locationmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.locationmessage_ != nullptr);
  return value;
}
inline bool Message::has_locationmessage() const {
  return _internal_has_locationmessage();
}
inline void Message::clear_locationmessage() {
  if (_impl_.locationmessage_ != nullptr) _impl_.locationmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::proto::LocationMessage& Message::_internal_locationmessage() const {
  const ::proto::LocationMessage* p = _impl_.locationmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::LocationMessage&>(
      ::proto::_LocationMessage_default_instance_);
}
inline const ::proto::LocationMessage& Message::locationmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.locationMessage)
  return _internal_locationmessage();
}
inline void Message::unsafe_arena_set_allocated_locationmessage(
    ::proto::LocationMessage* locationmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.locationmessage_);
  }
  _impl_.locationmessage_ = locationmessage;
  if (locationmessage) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.locationMessage)
}
inline ::proto::LocationMessage* Message::release_locationmessage() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::proto::LocationMessage* temp = _impl_.locationmessage_;
  _impl_.locationmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::LocationMessage* Message::unsafe_arena_release_locationmessage() {
  // @@protoc_insertion_point(field_release:proto.Message.locationMessage)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::proto::LocationMessage* temp = _impl_.locationmessage_;
  _impl_.locationmessage_ = nullptr;
  return temp;
}
inline ::proto::LocationMessage* Message::_internal_mutable_locationmessage() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.locationmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::LocationMessage>(GetArenaForAllocation());
    _impl_.locationmessage_ = p;
  }
  return _impl_.locationmessage_;
}
inline ::proto::LocationMessage* Message::mutable_locationmessage() {
  ::proto::LocationMessage* _msg = _internal_mutable_locationmessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.locationMessage)
  return _msg;
}
inline void Message::set_allocated_locationmessage(::proto::LocationMessage* locationmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.locationmessage_;
  }
  if (locationmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(locationmessage);
    if (message_arena != submessage_arena) {
      locationmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, locationmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.locationmessage_ = locationmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.locationMessage)
}

// optional .proto.ExtendedTextMessage extendedTextMessage = 6;
inline bool Message::_internal_has_extendedtextmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.extendedtextmessage_ != nullptr);
  return value;
}
inline bool Message::has_extendedtextmessage() const {
  return _internal_has_extendedtextmessage();
}
inline void Message::clear_extendedtextmessage() {
  if (_impl_.extendedtextmessage_ != nullptr) _impl_.extendedtextmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::proto::ExtendedTextMessage& Message::_internal_extendedtextmessage() const {
  const ::proto::ExtendedTextMessage* p = _impl_.extendedtextmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ExtendedTextMessage&>(
      ::proto::_ExtendedTextMessage_default_instance_);
}
inline const ::proto::ExtendedTextMessage& Message::extendedtextmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.extendedTextMessage)
  return _internal_extendedtextmessage();
}
inline void Message::unsafe_arena_set_allocated_extendedtextmessage(
    ::proto::ExtendedTextMessage* extendedtextmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extendedtextmessage_);
  }
  _impl_.extendedtextmessage_ = extendedtextmessage;
  if (extendedtextmessage) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.extendedTextMessage)
}
inline ::proto::ExtendedTextMessage* Message::release_extendedtextmessage() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::proto::ExtendedTextMessage* temp = _impl_.extendedtextmessage_;
  _impl_.extendedtextmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ExtendedTextMessage* Message::unsafe_arena_release_extendedtextmessage() {
  // @@protoc_insertion_point(field_release:proto.Message.extendedTextMessage)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::proto::ExtendedTextMessage* temp = _impl_.extendedtextmessage_;
  _impl_.extendedtextmessage_ = nullptr;
  return temp;
}
inline ::proto::ExtendedTextMessage* Message::_internal_mutable_extendedtextmessage() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.extendedtextmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ExtendedTextMessage>(GetArenaForAllocation());
    _impl_.extendedtextmessage_ = p;
  }
  return _impl_.extendedtextmessage_;
}
inline ::proto::ExtendedTextMessage* Message::mutable_extendedtextmessage() {
  ::proto::ExtendedTextMessage* _msg = _internal_mutable_extendedtextmessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.extendedTextMessage)
  return _msg;
}
inline void Message::set_allocated_extendedtextmessage(::proto::ExtendedTextMessage* extendedtextmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.extendedtextmessage_;
  }
  if (extendedtextmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(extendedtextmessage);
    if (message_arena != submessage_arena) {
      extendedtextmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extendedtextmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.extendedtextmessage_ = extendedtextmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.extendedTextMessage)
}

// optional .proto.DocumentMessage documentMessage = 7;
inline bool Message::_internal_has_documentmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.documentmessage_ != nullptr);
  return value;
}
inline bool Message::has_documentmessage() const {
  return _internal_has_documentmessage();
}
inline void Message::clear_documentmessage() {
  if (_impl_.documentmessage_ != nullptr) _impl_.documentmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::proto::DocumentMessage& Message::_internal_documentmessage() const {
  const ::proto::DocumentMessage* p = _impl_.documentmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::DocumentMessage&>(
      ::proto::_DocumentMessage_default_instance_);
}
inline const ::proto::DocumentMessage& Message::documentmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.documentMessage)
  return _internal_documentmessage();
}
inline void Message::unsafe_arena_set_allocated_documentmessage(
    ::proto::DocumentMessage* documentmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.documentmessage_);
  }
  _impl_.documentmessage_ = documentmessage;
  if (documentmessage) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.documentMessage)
}
inline ::proto::DocumentMessage* Message::release_documentmessage() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::proto::DocumentMessage* temp = _impl_.documentmessage_;
  _impl_.documentmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::DocumentMessage* Message::unsafe_arena_release_documentmessage() {
  // @@protoc_insertion_point(field_release:proto.Message.documentMessage)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::proto::DocumentMessage* temp = _impl_.documentmessage_;
  _impl_.documentmessage_ = nullptr;
  return temp;
}
inline ::proto::DocumentMessage* Message::_internal_mutable_documentmessage() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.documentmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::DocumentMessage>(GetArenaForAllocation());
    _impl_.documentmessage_ = p;
  }
  return _impl_.documentmessage_;
}
inline ::proto::DocumentMessage* Message::mutable_documentmessage() {
  ::proto::DocumentMessage* _msg = _internal_mutable_documentmessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.documentMessage)
  return _msg;
}
inline void Message::set_allocated_documentmessage(::proto::DocumentMessage* documentmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.documentmessage_;
  }
  if (documentmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(documentmessage);
    if (message_arena != submessage_arena) {
      documentmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, documentmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.documentmessage_ = documentmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.documentMessage)
}

// optional .proto.AudioMessage audioMessage = 8;
inline bool Message::_internal_has_audiomessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.audiomessage_ != nullptr);
  return value;
}
inline bool Message::has_audiomessage() const {
  return _internal_has_audiomessage();
}
inline void Message::clear_audiomessage() {
  if (_impl_.audiomessage_ != nullptr) _impl_.audiomessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::proto::AudioMessage& Message::_internal_audiomessage() const {
  const ::proto::AudioMessage* p = _impl_.audiomessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AudioMessage&>(
      ::proto::_AudioMessage_default_instance_);
}
inline const ::proto::AudioMessage& Message::audiomessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.audioMessage)
  return _internal_audiomessage();
}
inline void Message::unsafe_arena_set_allocated_audiomessage(
    ::proto::AudioMessage* audiomessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audiomessage_);
  }
  _impl_.audiomessage_ = audiomessage;
  if (audiomessage) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.audioMessage)
}
inline ::proto::AudioMessage* Message::release_audiomessage() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::proto::AudioMessage* temp = _impl_.audiomessage_;
  _impl_.audiomessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AudioMessage* Message::unsafe_arena_release_audiomessage() {
  // @@protoc_insertion_point(field_release:proto.Message.audioMessage)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::proto::AudioMessage* temp = _impl_.audiomessage_;
  _impl_.audiomessage_ = nullptr;
  return temp;
}
inline ::proto::AudioMessage* Message::_internal_mutable_audiomessage() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.audiomessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AudioMessage>(GetArenaForAllocation());
    _impl_.audiomessage_ = p;
  }
  return _impl_.audiomessage_;
}
inline ::proto::AudioMessage* Message::mutable_audiomessage() {
  ::proto::AudioMessage* _msg = _internal_mutable_audiomessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.audioMessage)
  return _msg;
}
inline void Message::set_allocated_audiomessage(::proto::AudioMessage* audiomessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audiomessage_;
  }
  if (audiomessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audiomessage);
    if (message_arena != submessage_arena) {
      audiomessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audiomessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.audiomessage_ = audiomessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.audioMessage)
}

// optional .proto.VideoMessage videoMessage = 9;
inline bool Message::_internal_has_videomessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.videomessage_ != nullptr);
  return value;
}
inline bool Message::has_videomessage() const {
  return _internal_has_videomessage();
}
inline void Message::clear_videomessage() {
  if (_impl_.videomessage_ != nullptr) _impl_.videomessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::proto::VideoMessage& Message::_internal_videomessage() const {
  const ::proto::VideoMessage* p = _impl_.videomessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::VideoMessage&>(
      ::proto::_VideoMessage_default_instance_);
}
inline const ::proto::VideoMessage& Message::videomessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.videoMessage)
  return _internal_videomessage();
}
inline void Message::unsafe_arena_set_allocated_videomessage(
    ::proto::VideoMessage* videomessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.videomessage_);
  }
  _impl_.videomessage_ = videomessage;
  if (videomessage) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.videoMessage)
}
inline ::proto::VideoMessage* Message::release_videomessage() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::proto::VideoMessage* temp = _impl_.videomessage_;
  _impl_.videomessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::VideoMessage* Message::unsafe_arena_release_videomessage() {
  // @@protoc_insertion_point(field_release:proto.Message.videoMessage)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::proto::VideoMessage* temp = _impl_.videomessage_;
  _impl_.videomessage_ = nullptr;
  return temp;
}
inline ::proto::VideoMessage* Message::_internal_mutable_videomessage() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.videomessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::VideoMessage>(GetArenaForAllocation());
    _impl_.videomessage_ = p;
  }
  return _impl_.videomessage_;
}
inline ::proto::VideoMessage* Message::mutable_videomessage() {
  ::proto::VideoMessage* _msg = _internal_mutable_videomessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.videoMessage)
  return _msg;
}
inline void Message::set_allocated_videomessage(::proto::VideoMessage* videomessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.videomessage_;
  }
  if (videomessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(videomessage);
    if (message_arena != submessage_arena) {
      videomessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, videomessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.videomessage_ = videomessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.videoMessage)
}

// optional .proto.Call call = 10;
inline bool Message::_internal_has_call() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.call_ != nullptr);
  return value;
}
inline bool Message::has_call() const {
  return _internal_has_call();
}
inline void Message::clear_call() {
  if (_impl_.call_ != nullptr) _impl_.call_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::proto::Call& Message::_internal_call() const {
  const ::proto::Call* p = _impl_.call_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Call&>(
      ::proto::_Call_default_instance_);
}
inline const ::proto::Call& Message::call() const {
  // @@protoc_insertion_point(field_get:proto.Message.call)
  return _internal_call();
}
inline void Message::unsafe_arena_set_allocated_call(
    ::proto::Call* call) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.call_);
  }
  _impl_.call_ = call;
  if (call) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.call)
}
inline ::proto::Call* Message::release_call() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::proto::Call* temp = _impl_.call_;
  _impl_.call_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Call* Message::unsafe_arena_release_call() {
  // @@protoc_insertion_point(field_release:proto.Message.call)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::proto::Call* temp = _impl_.call_;
  _impl_.call_ = nullptr;
  return temp;
}
inline ::proto::Call* Message::_internal_mutable_call() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.call_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Call>(GetArenaForAllocation());
    _impl_.call_ = p;
  }
  return _impl_.call_;
}
inline ::proto::Call* Message::mutable_call() {
  ::proto::Call* _msg = _internal_mutable_call();
  // @@protoc_insertion_point(field_mutable:proto.Message.call)
  return _msg;
}
inline void Message::set_allocated_call(::proto::Call* call) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.call_;
  }
  if (call) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(call);
    if (message_arena != submessage_arena) {
      call = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, call, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.call_ = call;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.call)
}

// optional .proto.Chat chat = 11;
inline bool Message::_internal_has_chat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chat_ != nullptr);
  return value;
}
inline bool Message::has_chat() const {
  return _internal_has_chat();
}
inline void Message::clear_chat() {
  if (_impl_.chat_ != nullptr) _impl_.chat_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::proto::Chat& Message::_internal_chat() const {
  const ::proto::Chat* p = _impl_.chat_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Chat&>(
      ::proto::_Chat_default_instance_);
}
inline const ::proto::Chat& Message::chat() const {
  // @@protoc_insertion_point(field_get:proto.Message.chat)
  return _internal_chat();
}
inline void Message::unsafe_arena_set_allocated_chat(
    ::proto::Chat* chat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chat_);
  }
  _impl_.chat_ = chat;
  if (chat) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.chat)
}
inline ::proto::Chat* Message::release_chat() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::proto::Chat* temp = _impl_.chat_;
  _impl_.chat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Chat* Message::unsafe_arena_release_chat() {
  // @@protoc_insertion_point(field_release:proto.Message.chat)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::proto::Chat* temp = _impl_.chat_;
  _impl_.chat_ = nullptr;
  return temp;
}
inline ::proto::Chat* Message::_internal_mutable_chat() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.chat_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Chat>(GetArenaForAllocation());
    _impl_.chat_ = p;
  }
  return _impl_.chat_;
}
inline ::proto::Chat* Message::mutable_chat() {
  ::proto::Chat* _msg = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:proto.Message.chat)
  return _msg;
}
inline void Message::set_allocated_chat(::proto::Chat* chat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chat_;
  }
  if (chat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chat);
    if (message_arena != submessage_arena) {
      chat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chat, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.chat_ = chat;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.chat)
}

// optional .proto.ProtocolMessage protocolMessage = 12;
inline bool Message::_internal_has_protocolmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.protocolmessage_ != nullptr);
  return value;
}
inline bool Message::has_protocolmessage() const {
  return _internal_has_protocolmessage();
}
inline void Message::clear_protocolmessage() {
  if (_impl_.protocolmessage_ != nullptr) _impl_.protocolmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::proto::ProtocolMessage& Message::_internal_protocolmessage() const {
  const ::proto::ProtocolMessage* p = _impl_.protocolmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ProtocolMessage&>(
      ::proto::_ProtocolMessage_default_instance_);
}
inline const ::proto::ProtocolMessage& Message::protocolmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.protocolMessage)
  return _internal_protocolmessage();
}
inline void Message::unsafe_arena_set_allocated_protocolmessage(
    ::proto::ProtocolMessage* protocolmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.protocolmessage_);
  }
  _impl_.protocolmessage_ = protocolmessage;
  if (protocolmessage) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.protocolMessage)
}
inline ::proto::ProtocolMessage* Message::release_protocolmessage() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::proto::ProtocolMessage* temp = _impl_.protocolmessage_;
  _impl_.protocolmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ProtocolMessage* Message::unsafe_arena_release_protocolmessage() {
  // @@protoc_insertion_point(field_release:proto.Message.protocolMessage)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::proto::ProtocolMessage* temp = _impl_.protocolmessage_;
  _impl_.protocolmessage_ = nullptr;
  return temp;
}
inline ::proto::ProtocolMessage* Message::_internal_mutable_protocolmessage() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.protocolmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ProtocolMessage>(GetArenaForAllocation());
    _impl_.protocolmessage_ = p;
  }
  return _impl_.protocolmessage_;
}
inline ::proto::ProtocolMessage* Message::mutable_protocolmessage() {
  ::proto::ProtocolMessage* _msg = _internal_mutable_protocolmessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.protocolMessage)
  return _msg;
}
inline void Message::set_allocated_protocolmessage(::proto::ProtocolMessage* protocolmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.protocolmessage_;
  }
  if (protocolmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(protocolmessage);
    if (message_arena != submessage_arena) {
      protocolmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, protocolmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.protocolmessage_ = protocolmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.protocolMessage)
}

// optional .proto.ContactsArrayMessage contactsArrayMessage = 13;
inline bool Message::_internal_has_contactsarraymessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contactsarraymessage_ != nullptr);
  return value;
}
inline bool Message::has_contactsarraymessage() const {
  return _internal_has_contactsarraymessage();
}
inline void Message::clear_contactsarraymessage() {
  if (_impl_.contactsarraymessage_ != nullptr) _impl_.contactsarraymessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::proto::ContactsArrayMessage& Message::_internal_contactsarraymessage() const {
  const ::proto::ContactsArrayMessage* p = _impl_.contactsarraymessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContactsArrayMessage&>(
      ::proto::_ContactsArrayMessage_default_instance_);
}
inline const ::proto::ContactsArrayMessage& Message::contactsarraymessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.contactsArrayMessage)
  return _internal_contactsarraymessage();
}
inline void Message::unsafe_arena_set_allocated_contactsarraymessage(
    ::proto::ContactsArrayMessage* contactsarraymessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contactsarraymessage_);
  }
  _impl_.contactsarraymessage_ = contactsarraymessage;
  if (contactsarraymessage) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.contactsArrayMessage)
}
inline ::proto::ContactsArrayMessage* Message::release_contactsarraymessage() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::proto::ContactsArrayMessage* temp = _impl_.contactsarraymessage_;
  _impl_.contactsarraymessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContactsArrayMessage* Message::unsafe_arena_release_contactsarraymessage() {
  // @@protoc_insertion_point(field_release:proto.Message.contactsArrayMessage)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::proto::ContactsArrayMessage* temp = _impl_.contactsarraymessage_;
  _impl_.contactsarraymessage_ = nullptr;
  return temp;
}
inline ::proto::ContactsArrayMessage* Message::_internal_mutable_contactsarraymessage() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.contactsarraymessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContactsArrayMessage>(GetArenaForAllocation());
    _impl_.contactsarraymessage_ = p;
  }
  return _impl_.contactsarraymessage_;
}
inline ::proto::ContactsArrayMessage* Message::mutable_contactsarraymessage() {
  ::proto::ContactsArrayMessage* _msg = _internal_mutable_contactsarraymessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.contactsArrayMessage)
  return _msg;
}
inline void Message::set_allocated_contactsarraymessage(::proto::ContactsArrayMessage* contactsarraymessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contactsarraymessage_;
  }
  if (contactsarraymessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contactsarraymessage);
    if (message_arena != submessage_arena) {
      contactsarraymessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contactsarraymessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.contactsarraymessage_ = contactsarraymessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.contactsArrayMessage)
}

// optional .proto.HighlyStructuredMessage highlyStructuredMessage = 14;
inline bool Message::_internal_has_highlystructuredmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.highlystructuredmessage_ != nullptr);
  return value;
}
inline bool Message::has_highlystructuredmessage() const {
  return _internal_has_highlystructuredmessage();
}
inline void Message::clear_highlystructuredmessage() {
  if (_impl_.highlystructuredmessage_ != nullptr) _impl_.highlystructuredmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const ::proto::HighlyStructuredMessage& Message::_internal_highlystructuredmessage() const {
  const ::proto::HighlyStructuredMessage* p = _impl_.highlystructuredmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::HighlyStructuredMessage&>(
      ::proto::_HighlyStructuredMessage_default_instance_);
}
inline const ::proto::HighlyStructuredMessage& Message::highlystructuredmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.highlyStructuredMessage)
  return _internal_highlystructuredmessage();
}
inline void Message::unsafe_arena_set_allocated_highlystructuredmessage(
    ::proto::HighlyStructuredMessage* highlystructuredmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.highlystructuredmessage_);
  }
  _impl_.highlystructuredmessage_ = highlystructuredmessage;
  if (highlystructuredmessage) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.highlyStructuredMessage)
}
inline ::proto::HighlyStructuredMessage* Message::release_highlystructuredmessage() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::proto::HighlyStructuredMessage* temp = _impl_.highlystructuredmessage_;
  _impl_.highlystructuredmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::HighlyStructuredMessage* Message::unsafe_arena_release_highlystructuredmessage() {
  // @@protoc_insertion_point(field_release:proto.Message.highlyStructuredMessage)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::proto::HighlyStructuredMessage* temp = _impl_.highlystructuredmessage_;
  _impl_.highlystructuredmessage_ = nullptr;
  return temp;
}
inline ::proto::HighlyStructuredMessage* Message::_internal_mutable_highlystructuredmessage() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.highlystructuredmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::HighlyStructuredMessage>(GetArenaForAllocation());
    _impl_.highlystructuredmessage_ = p;
  }
  return _impl_.highlystructuredmessage_;
}
inline ::proto::HighlyStructuredMessage* Message::mutable_highlystructuredmessage() {
  ::proto::HighlyStructuredMessage* _msg = _internal_mutable_highlystructuredmessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.highlyStructuredMessage)
  return _msg;
}
inline void Message::set_allocated_highlystructuredmessage(::proto::HighlyStructuredMessage* highlystructuredmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.highlystructuredmessage_;
  }
  if (highlystructuredmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(highlystructuredmessage);
    if (message_arena != submessage_arena) {
      highlystructuredmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, highlystructuredmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.highlystructuredmessage_ = highlystructuredmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.highlyStructuredMessage)
}

// optional .proto.SenderKeyDistributionMessage fastRatchetKeySenderKeyDistributionMessage = 15;
inline bool Message::_internal_has_fastratchetkeysenderkeydistributionmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fastratchetkeysenderkeydistributionmessage_ != nullptr);
  return value;
}
inline bool Message::has_fastratchetkeysenderkeydistributionmessage() const {
  return _internal_has_fastratchetkeysenderkeydistributionmessage();
}
inline void Message::clear_fastratchetkeysenderkeydistributionmessage() {
  if (_impl_.fastratchetkeysenderkeydistributionmessage_ != nullptr) _impl_.fastratchetkeysenderkeydistributionmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const ::proto::SenderKeyDistributionMessage& Message::_internal_fastratchetkeysenderkeydistributionmessage() const {
  const ::proto::SenderKeyDistributionMessage* p = _impl_.fastratchetkeysenderkeydistributionmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::SenderKeyDistributionMessage&>(
      ::proto::_SenderKeyDistributionMessage_default_instance_);
}
inline const ::proto::SenderKeyDistributionMessage& Message::fastratchetkeysenderkeydistributionmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.fastRatchetKeySenderKeyDistributionMessage)
  return _internal_fastratchetkeysenderkeydistributionmessage();
}
inline void Message::unsafe_arena_set_allocated_fastratchetkeysenderkeydistributionmessage(
    ::proto::SenderKeyDistributionMessage* fastratchetkeysenderkeydistributionmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fastratchetkeysenderkeydistributionmessage_);
  }
  _impl_.fastratchetkeysenderkeydistributionmessage_ = fastratchetkeysenderkeydistributionmessage;
  if (fastratchetkeysenderkeydistributionmessage) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.fastRatchetKeySenderKeyDistributionMessage)
}
inline ::proto::SenderKeyDistributionMessage* Message::release_fastratchetkeysenderkeydistributionmessage() {
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::proto::SenderKeyDistributionMessage* temp = _impl_.fastratchetkeysenderkeydistributionmessage_;
  _impl_.fastratchetkeysenderkeydistributionmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::SenderKeyDistributionMessage* Message::unsafe_arena_release_fastratchetkeysenderkeydistributionmessage() {
  // @@protoc_insertion_point(field_release:proto.Message.fastRatchetKeySenderKeyDistributionMessage)
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::proto::SenderKeyDistributionMessage* temp = _impl_.fastratchetkeysenderkeydistributionmessage_;
  _impl_.fastratchetkeysenderkeydistributionmessage_ = nullptr;
  return temp;
}
inline ::proto::SenderKeyDistributionMessage* Message::_internal_mutable_fastratchetkeysenderkeydistributionmessage() {
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.fastratchetkeysenderkeydistributionmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::SenderKeyDistributionMessage>(GetArenaForAllocation());
    _impl_.fastratchetkeysenderkeydistributionmessage_ = p;
  }
  return _impl_.fastratchetkeysenderkeydistributionmessage_;
}
inline ::proto::SenderKeyDistributionMessage* Message::mutable_fastratchetkeysenderkeydistributionmessage() {
  ::proto::SenderKeyDistributionMessage* _msg = _internal_mutable_fastratchetkeysenderkeydistributionmessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.fastRatchetKeySenderKeyDistributionMessage)
  return _msg;
}
inline void Message::set_allocated_fastratchetkeysenderkeydistributionmessage(::proto::SenderKeyDistributionMessage* fastratchetkeysenderkeydistributionmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fastratchetkeysenderkeydistributionmessage_;
  }
  if (fastratchetkeysenderkeydistributionmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fastratchetkeysenderkeydistributionmessage);
    if (message_arena != submessage_arena) {
      fastratchetkeysenderkeydistributionmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fastratchetkeysenderkeydistributionmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.fastratchetkeysenderkeydistributionmessage_ = fastratchetkeysenderkeydistributionmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.fastRatchetKeySenderKeyDistributionMessage)
}

// optional .proto.SendPaymentMessage sendPaymentMessage = 16;
inline bool Message::_internal_has_sendpaymentmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sendpaymentmessage_ != nullptr);
  return value;
}
inline bool Message::has_sendpaymentmessage() const {
  return _internal_has_sendpaymentmessage();
}
inline void Message::clear_sendpaymentmessage() {
  if (_impl_.sendpaymentmessage_ != nullptr) _impl_.sendpaymentmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const ::proto::SendPaymentMessage& Message::_internal_sendpaymentmessage() const {
  const ::proto::SendPaymentMessage* p = _impl_.sendpaymentmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::SendPaymentMessage&>(
      ::proto::_SendPaymentMessage_default_instance_);
}
inline const ::proto::SendPaymentMessage& Message::sendpaymentmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.sendPaymentMessage)
  return _internal_sendpaymentmessage();
}
inline void Message::unsafe_arena_set_allocated_sendpaymentmessage(
    ::proto::SendPaymentMessage* sendpaymentmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sendpaymentmessage_);
  }
  _impl_.sendpaymentmessage_ = sendpaymentmessage;
  if (sendpaymentmessage) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.sendPaymentMessage)
}
inline ::proto::SendPaymentMessage* Message::release_sendpaymentmessage() {
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::proto::SendPaymentMessage* temp = _impl_.sendpaymentmessage_;
  _impl_.sendpaymentmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::SendPaymentMessage* Message::unsafe_arena_release_sendpaymentmessage() {
  // @@protoc_insertion_point(field_release:proto.Message.sendPaymentMessage)
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::proto::SendPaymentMessage* temp = _impl_.sendpaymentmessage_;
  _impl_.sendpaymentmessage_ = nullptr;
  return temp;
}
inline ::proto::SendPaymentMessage* Message::_internal_mutable_sendpaymentmessage() {
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.sendpaymentmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::SendPaymentMessage>(GetArenaForAllocation());
    _impl_.sendpaymentmessage_ = p;
  }
  return _impl_.sendpaymentmessage_;
}
inline ::proto::SendPaymentMessage* Message::mutable_sendpaymentmessage() {
  ::proto::SendPaymentMessage* _msg = _internal_mutable_sendpaymentmessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.sendPaymentMessage)
  return _msg;
}
inline void Message::set_allocated_sendpaymentmessage(::proto::SendPaymentMessage* sendpaymentmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sendpaymentmessage_;
  }
  if (sendpaymentmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sendpaymentmessage);
    if (message_arena != submessage_arena) {
      sendpaymentmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sendpaymentmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.sendpaymentmessage_ = sendpaymentmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.sendPaymentMessage)
}

// optional .proto.LiveLocationMessage liveLocationMessage = 18;
inline bool Message::_internal_has_livelocationmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.livelocationmessage_ != nullptr);
  return value;
}
inline bool Message::has_livelocationmessage() const {
  return _internal_has_livelocationmessage();
}
inline void Message::clear_livelocationmessage() {
  if (_impl_.livelocationmessage_ != nullptr) _impl_.livelocationmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline const ::proto::LiveLocationMessage& Message::_internal_livelocationmessage() const {
  const ::proto::LiveLocationMessage* p = _impl_.livelocationmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::LiveLocationMessage&>(
      ::proto::_LiveLocationMessage_default_instance_);
}
inline const ::proto::LiveLocationMessage& Message::livelocationmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.liveLocationMessage)
  return _internal_livelocationmessage();
}
inline void Message::unsafe_arena_set_allocated_livelocationmessage(
    ::proto::LiveLocationMessage* livelocationmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.livelocationmessage_);
  }
  _impl_.livelocationmessage_ = livelocationmessage;
  if (livelocationmessage) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.liveLocationMessage)
}
inline ::proto::LiveLocationMessage* Message::release_livelocationmessage() {
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::proto::LiveLocationMessage* temp = _impl_.livelocationmessage_;
  _impl_.livelocationmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::LiveLocationMessage* Message::unsafe_arena_release_livelocationmessage() {
  // @@protoc_insertion_point(field_release:proto.Message.liveLocationMessage)
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::proto::LiveLocationMessage* temp = _impl_.livelocationmessage_;
  _impl_.livelocationmessage_ = nullptr;
  return temp;
}
inline ::proto::LiveLocationMessage* Message::_internal_mutable_livelocationmessage() {
  _impl_._has_bits_[0] |= 0x00010000u;
  if (_impl_.livelocationmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::LiveLocationMessage>(GetArenaForAllocation());
    _impl_.livelocationmessage_ = p;
  }
  return _impl_.livelocationmessage_;
}
inline ::proto::LiveLocationMessage* Message::mutable_livelocationmessage() {
  ::proto::LiveLocationMessage* _msg = _internal_mutable_livelocationmessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.liveLocationMessage)
  return _msg;
}
inline void Message::set_allocated_livelocationmessage(::proto::LiveLocationMessage* livelocationmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.livelocationmessage_;
  }
  if (livelocationmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(livelocationmessage);
    if (message_arena != submessage_arena) {
      livelocationmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, livelocationmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.livelocationmessage_ = livelocationmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.liveLocationMessage)
}

// optional .proto.RequestPaymentMessage requestPaymentMessage = 22;
inline bool Message::_internal_has_requestpaymentmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.requestpaymentmessage_ != nullptr);
  return value;
}
inline bool Message::has_requestpaymentmessage() const {
  return _internal_has_requestpaymentmessage();
}
inline void Message::clear_requestpaymentmessage() {
  if (_impl_.requestpaymentmessage_ != nullptr) _impl_.requestpaymentmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline const ::proto::RequestPaymentMessage& Message::_internal_requestpaymentmessage() const {
  const ::proto::RequestPaymentMessage* p = _impl_.requestpaymentmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::RequestPaymentMessage&>(
      ::proto::_RequestPaymentMessage_default_instance_);
}
inline const ::proto::RequestPaymentMessage& Message::requestpaymentmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.requestPaymentMessage)
  return _internal_requestpaymentmessage();
}
inline void Message::unsafe_arena_set_allocated_requestpaymentmessage(
    ::proto::RequestPaymentMessage* requestpaymentmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requestpaymentmessage_);
  }
  _impl_.requestpaymentmessage_ = requestpaymentmessage;
  if (requestpaymentmessage) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.requestPaymentMessage)
}
inline ::proto::RequestPaymentMessage* Message::release_requestpaymentmessage() {
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::proto::RequestPaymentMessage* temp = _impl_.requestpaymentmessage_;
  _impl_.requestpaymentmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::RequestPaymentMessage* Message::unsafe_arena_release_requestpaymentmessage() {
  // @@protoc_insertion_point(field_release:proto.Message.requestPaymentMessage)
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::proto::RequestPaymentMessage* temp = _impl_.requestpaymentmessage_;
  _impl_.requestpaymentmessage_ = nullptr;
  return temp;
}
inline ::proto::RequestPaymentMessage* Message::_internal_mutable_requestpaymentmessage() {
  _impl_._has_bits_[0] |= 0x00020000u;
  if (_impl_.requestpaymentmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::RequestPaymentMessage>(GetArenaForAllocation());
    _impl_.requestpaymentmessage_ = p;
  }
  return _impl_.requestpaymentmessage_;
}
inline ::proto::RequestPaymentMessage* Message::mutable_requestpaymentmessage() {
  ::proto::RequestPaymentMessage* _msg = _internal_mutable_requestpaymentmessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.requestPaymentMessage)
  return _msg;
}
inline void Message::set_allocated_requestpaymentmessage(::proto::RequestPaymentMessage* requestpaymentmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.requestpaymentmessage_;
  }
  if (requestpaymentmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(requestpaymentmessage);
    if (message_arena != submessage_arena) {
      requestpaymentmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, requestpaymentmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.requestpaymentmessage_ = requestpaymentmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.requestPaymentMessage)
}

// optional .proto.DeclinePaymentRequestMessage declinePaymentRequestMessage = 23;
inline bool Message::_internal_has_declinepaymentrequestmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.declinepaymentrequestmessage_ != nullptr);
  return value;
}
inline bool Message::has_declinepaymentrequestmessage() const {
  return _internal_has_declinepaymentrequestmessage();
}
inline void Message::clear_declinepaymentrequestmessage() {
  if (_impl_.declinepaymentrequestmessage_ != nullptr) _impl_.declinepaymentrequestmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline const ::proto::DeclinePaymentRequestMessage& Message::_internal_declinepaymentrequestmessage() const {
  const ::proto::DeclinePaymentRequestMessage* p = _impl_.declinepaymentrequestmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::DeclinePaymentRequestMessage&>(
      ::proto::_DeclinePaymentRequestMessage_default_instance_);
}
inline const ::proto::DeclinePaymentRequestMessage& Message::declinepaymentrequestmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.declinePaymentRequestMessage)
  return _internal_declinepaymentrequestmessage();
}
inline void Message::unsafe_arena_set_allocated_declinepaymentrequestmessage(
    ::proto::DeclinePaymentRequestMessage* declinepaymentrequestmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.declinepaymentrequestmessage_);
  }
  _impl_.declinepaymentrequestmessage_ = declinepaymentrequestmessage;
  if (declinepaymentrequestmessage) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.declinePaymentRequestMessage)
}
inline ::proto::DeclinePaymentRequestMessage* Message::release_declinepaymentrequestmessage() {
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::proto::DeclinePaymentRequestMessage* temp = _impl_.declinepaymentrequestmessage_;
  _impl_.declinepaymentrequestmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::DeclinePaymentRequestMessage* Message::unsafe_arena_release_declinepaymentrequestmessage() {
  // @@protoc_insertion_point(field_release:proto.Message.declinePaymentRequestMessage)
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::proto::DeclinePaymentRequestMessage* temp = _impl_.declinepaymentrequestmessage_;
  _impl_.declinepaymentrequestmessage_ = nullptr;
  return temp;
}
inline ::proto::DeclinePaymentRequestMessage* Message::_internal_mutable_declinepaymentrequestmessage() {
  _impl_._has_bits_[0] |= 0x00040000u;
  if (_impl_.declinepaymentrequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::DeclinePaymentRequestMessage>(GetArenaForAllocation());
    _impl_.declinepaymentrequestmessage_ = p;
  }
  return _impl_.declinepaymentrequestmessage_;
}
inline ::proto::DeclinePaymentRequestMessage* Message::mutable_declinepaymentrequestmessage() {
  ::proto::DeclinePaymentRequestMessage* _msg = _internal_mutable_declinepaymentrequestmessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.declinePaymentRequestMessage)
  return _msg;
}
inline void Message::set_allocated_declinepaymentrequestmessage(::proto::DeclinePaymentRequestMessage* declinepaymentrequestmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.declinepaymentrequestmessage_;
  }
  if (declinepaymentrequestmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(declinepaymentrequestmessage);
    if (message_arena != submessage_arena) {
      declinepaymentrequestmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, declinepaymentrequestmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  _impl_.declinepaymentrequestmessage_ = declinepaymentrequestmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.declinePaymentRequestMessage)
}

// optional .proto.CancelPaymentRequestMessage cancelPaymentRequestMessage = 24;
inline bool Message::_internal_has_cancelpaymentrequestmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cancelpaymentrequestmessage_ != nullptr);
  return value;
}
inline bool Message::has_cancelpaymentrequestmessage() const {
  return _internal_has_cancelpaymentrequestmessage();
}
inline void Message::clear_cancelpaymentrequestmessage() {
  if (_impl_.cancelpaymentrequestmessage_ != nullptr) _impl_.cancelpaymentrequestmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline const ::proto::CancelPaymentRequestMessage& Message::_internal_cancelpaymentrequestmessage() const {
  const ::proto::CancelPaymentRequestMessage* p = _impl_.cancelpaymentrequestmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::CancelPaymentRequestMessage&>(
      ::proto::_CancelPaymentRequestMessage_default_instance_);
}
inline const ::proto::CancelPaymentRequestMessage& Message::cancelpaymentrequestmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.cancelPaymentRequestMessage)
  return _internal_cancelpaymentrequestmessage();
}
inline void Message::unsafe_arena_set_allocated_cancelpaymentrequestmessage(
    ::proto::CancelPaymentRequestMessage* cancelpaymentrequestmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cancelpaymentrequestmessage_);
  }
  _impl_.cancelpaymentrequestmessage_ = cancelpaymentrequestmessage;
  if (cancelpaymentrequestmessage) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.cancelPaymentRequestMessage)
}
inline ::proto::CancelPaymentRequestMessage* Message::release_cancelpaymentrequestmessage() {
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::proto::CancelPaymentRequestMessage* temp = _impl_.cancelpaymentrequestmessage_;
  _impl_.cancelpaymentrequestmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::CancelPaymentRequestMessage* Message::unsafe_arena_release_cancelpaymentrequestmessage() {
  // @@protoc_insertion_point(field_release:proto.Message.cancelPaymentRequestMessage)
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::proto::CancelPaymentRequestMessage* temp = _impl_.cancelpaymentrequestmessage_;
  _impl_.cancelpaymentrequestmessage_ = nullptr;
  return temp;
}
inline ::proto::CancelPaymentRequestMessage* Message::_internal_mutable_cancelpaymentrequestmessage() {
  _impl_._has_bits_[0] |= 0x00080000u;
  if (_impl_.cancelpaymentrequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::CancelPaymentRequestMessage>(GetArenaForAllocation());
    _impl_.cancelpaymentrequestmessage_ = p;
  }
  return _impl_.cancelpaymentrequestmessage_;
}
inline ::proto::CancelPaymentRequestMessage* Message::mutable_cancelpaymentrequestmessage() {
  ::proto::CancelPaymentRequestMessage* _msg = _internal_mutable_cancelpaymentrequestmessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.cancelPaymentRequestMessage)
  return _msg;
}
inline void Message::set_allocated_cancelpaymentrequestmessage(::proto::CancelPaymentRequestMessage* cancelpaymentrequestmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cancelpaymentrequestmessage_;
  }
  if (cancelpaymentrequestmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cancelpaymentrequestmessage);
    if (message_arena != submessage_arena) {
      cancelpaymentrequestmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cancelpaymentrequestmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  _impl_.cancelpaymentrequestmessage_ = cancelpaymentrequestmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.cancelPaymentRequestMessage)
}

// optional .proto.TemplateMessage templateMessage = 25;
inline bool Message::_internal_has_templatemessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.templatemessage_ != nullptr);
  return value;
}
inline bool Message::has_templatemessage() const {
  return _internal_has_templatemessage();
}
inline void Message::clear_templatemessage() {
  if (_impl_.templatemessage_ != nullptr) _impl_.templatemessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline const ::proto::TemplateMessage& Message::_internal_templatemessage() const {
  const ::proto::TemplateMessage* p = _impl_.templatemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::TemplateMessage&>(
      ::proto::_TemplateMessage_default_instance_);
}
inline const ::proto::TemplateMessage& Message::templatemessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.templateMessage)
  return _internal_templatemessage();
}
inline void Message::unsafe_arena_set_allocated_templatemessage(
    ::proto::TemplateMessage* templatemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.templatemessage_);
  }
  _impl_.templatemessage_ = templatemessage;
  if (templatemessage) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.templateMessage)
}
inline ::proto::TemplateMessage* Message::release_templatemessage() {
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::proto::TemplateMessage* temp = _impl_.templatemessage_;
  _impl_.templatemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::TemplateMessage* Message::unsafe_arena_release_templatemessage() {
  // @@protoc_insertion_point(field_release:proto.Message.templateMessage)
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::proto::TemplateMessage* temp = _impl_.templatemessage_;
  _impl_.templatemessage_ = nullptr;
  return temp;
}
inline ::proto::TemplateMessage* Message::_internal_mutable_templatemessage() {
  _impl_._has_bits_[0] |= 0x00100000u;
  if (_impl_.templatemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::TemplateMessage>(GetArenaForAllocation());
    _impl_.templatemessage_ = p;
  }
  return _impl_.templatemessage_;
}
inline ::proto::TemplateMessage* Message::mutable_templatemessage() {
  ::proto::TemplateMessage* _msg = _internal_mutable_templatemessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.templateMessage)
  return _msg;
}
inline void Message::set_allocated_templatemessage(::proto::TemplateMessage* templatemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.templatemessage_;
  }
  if (templatemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(templatemessage);
    if (message_arena != submessage_arena) {
      templatemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, templatemessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  _impl_.templatemessage_ = templatemessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.templateMessage)
}

// optional .proto.StickerMessage stickerMessage = 26;
inline bool Message::_internal_has_stickermessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stickermessage_ != nullptr);
  return value;
}
inline bool Message::has_stickermessage() const {
  return _internal_has_stickermessage();
}
inline void Message::clear_stickermessage() {
  if (_impl_.stickermessage_ != nullptr) _impl_.stickermessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline const ::proto::StickerMessage& Message::_internal_stickermessage() const {
  const ::proto::StickerMessage* p = _impl_.stickermessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::StickerMessage&>(
      ::proto::_StickerMessage_default_instance_);
}
inline const ::proto::StickerMessage& Message::stickermessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.stickerMessage)
  return _internal_stickermessage();
}
inline void Message::unsafe_arena_set_allocated_stickermessage(
    ::proto::StickerMessage* stickermessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stickermessage_);
  }
  _impl_.stickermessage_ = stickermessage;
  if (stickermessage) {
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.stickerMessage)
}
inline ::proto::StickerMessage* Message::release_stickermessage() {
  _impl_._has_bits_[0] &= ~0x00200000u;
  ::proto::StickerMessage* temp = _impl_.stickermessage_;
  _impl_.stickermessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::StickerMessage* Message::unsafe_arena_release_stickermessage() {
  // @@protoc_insertion_point(field_release:proto.Message.stickerMessage)
  _impl_._has_bits_[0] &= ~0x00200000u;
  ::proto::StickerMessage* temp = _impl_.stickermessage_;
  _impl_.stickermessage_ = nullptr;
  return temp;
}
inline ::proto::StickerMessage* Message::_internal_mutable_stickermessage() {
  _impl_._has_bits_[0] |= 0x00200000u;
  if (_impl_.stickermessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::StickerMessage>(GetArenaForAllocation());
    _impl_.stickermessage_ = p;
  }
  return _impl_.stickermessage_;
}
inline ::proto::StickerMessage* Message::mutable_stickermessage() {
  ::proto::StickerMessage* _msg = _internal_mutable_stickermessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.stickerMessage)
  return _msg;
}
inline void Message::set_allocated_stickermessage(::proto::StickerMessage* stickermessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stickermessage_;
  }
  if (stickermessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stickermessage);
    if (message_arena != submessage_arena) {
      stickermessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stickermessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  _impl_.stickermessage_ = stickermessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.stickerMessage)
}

// optional .proto.GroupInviteMessage groupInviteMessage = 28;
inline bool Message::_internal_has_groupinvitemessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.groupinvitemessage_ != nullptr);
  return value;
}
inline bool Message::has_groupinvitemessage() const {
  return _internal_has_groupinvitemessage();
}
inline void Message::clear_groupinvitemessage() {
  if (_impl_.groupinvitemessage_ != nullptr) _impl_.groupinvitemessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline const ::proto::GroupInviteMessage& Message::_internal_groupinvitemessage() const {
  const ::proto::GroupInviteMessage* p = _impl_.groupinvitemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::GroupInviteMessage&>(
      ::proto::_GroupInviteMessage_default_instance_);
}
inline const ::proto::GroupInviteMessage& Message::groupinvitemessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.groupInviteMessage)
  return _internal_groupinvitemessage();
}
inline void Message::unsafe_arena_set_allocated_groupinvitemessage(
    ::proto::GroupInviteMessage* groupinvitemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.groupinvitemessage_);
  }
  _impl_.groupinvitemessage_ = groupinvitemessage;
  if (groupinvitemessage) {
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.groupInviteMessage)
}
inline ::proto::GroupInviteMessage* Message::release_groupinvitemessage() {
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::proto::GroupInviteMessage* temp = _impl_.groupinvitemessage_;
  _impl_.groupinvitemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::GroupInviteMessage* Message::unsafe_arena_release_groupinvitemessage() {
  // @@protoc_insertion_point(field_release:proto.Message.groupInviteMessage)
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::proto::GroupInviteMessage* temp = _impl_.groupinvitemessage_;
  _impl_.groupinvitemessage_ = nullptr;
  return temp;
}
inline ::proto::GroupInviteMessage* Message::_internal_mutable_groupinvitemessage() {
  _impl_._has_bits_[0] |= 0x00400000u;
  if (_impl_.groupinvitemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::GroupInviteMessage>(GetArenaForAllocation());
    _impl_.groupinvitemessage_ = p;
  }
  return _impl_.groupinvitemessage_;
}
inline ::proto::GroupInviteMessage* Message::mutable_groupinvitemessage() {
  ::proto::GroupInviteMessage* _msg = _internal_mutable_groupinvitemessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.groupInviteMessage)
  return _msg;
}
inline void Message::set_allocated_groupinvitemessage(::proto::GroupInviteMessage* groupinvitemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.groupinvitemessage_;
  }
  if (groupinvitemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(groupinvitemessage);
    if (message_arena != submessage_arena) {
      groupinvitemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, groupinvitemessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  _impl_.groupinvitemessage_ = groupinvitemessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.groupInviteMessage)
}

// optional .proto.TemplateButtonReplyMessage templateButtonReplyMessage = 29;
inline bool Message::_internal_has_templatebuttonreplymessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.templatebuttonreplymessage_ != nullptr);
  return value;
}
inline bool Message::has_templatebuttonreplymessage() const {
  return _internal_has_templatebuttonreplymessage();
}
inline void Message::clear_templatebuttonreplymessage() {
  if (_impl_.templatebuttonreplymessage_ != nullptr) _impl_.templatebuttonreplymessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline const ::proto::TemplateButtonReplyMessage& Message::_internal_templatebuttonreplymessage() const {
  const ::proto::TemplateButtonReplyMessage* p = _impl_.templatebuttonreplymessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::TemplateButtonReplyMessage&>(
      ::proto::_TemplateButtonReplyMessage_default_instance_);
}
inline const ::proto::TemplateButtonReplyMessage& Message::templatebuttonreplymessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.templateButtonReplyMessage)
  return _internal_templatebuttonreplymessage();
}
inline void Message::unsafe_arena_set_allocated_templatebuttonreplymessage(
    ::proto::TemplateButtonReplyMessage* templatebuttonreplymessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.templatebuttonreplymessage_);
  }
  _impl_.templatebuttonreplymessage_ = templatebuttonreplymessage;
  if (templatebuttonreplymessage) {
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.templateButtonReplyMessage)
}
inline ::proto::TemplateButtonReplyMessage* Message::release_templatebuttonreplymessage() {
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::proto::TemplateButtonReplyMessage* temp = _impl_.templatebuttonreplymessage_;
  _impl_.templatebuttonreplymessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::TemplateButtonReplyMessage* Message::unsafe_arena_release_templatebuttonreplymessage() {
  // @@protoc_insertion_point(field_release:proto.Message.templateButtonReplyMessage)
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::proto::TemplateButtonReplyMessage* temp = _impl_.templatebuttonreplymessage_;
  _impl_.templatebuttonreplymessage_ = nullptr;
  return temp;
}
inline ::proto::TemplateButtonReplyMessage* Message::_internal_mutable_templatebuttonreplymessage() {
  _impl_._has_bits_[0] |= 0x00800000u;
  if (_impl_.templatebuttonreplymessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::TemplateButtonReplyMessage>(GetArenaForAllocation());
    _impl_.templatebuttonreplymessage_ = p;
  }
  return _impl_.templatebuttonreplymessage_;
}
inline ::proto::TemplateButtonReplyMessage* Message::mutable_templatebuttonreplymessage() {
  ::proto::TemplateButtonReplyMessage* _msg = _internal_mutable_templatebuttonreplymessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.templateButtonReplyMessage)
  return _msg;
}
inline void Message::set_allocated_templatebuttonreplymessage(::proto::TemplateButtonReplyMessage* templatebuttonreplymessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.templatebuttonreplymessage_;
  }
  if (templatebuttonreplymessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(templatebuttonreplymessage);
    if (message_arena != submessage_arena) {
      templatebuttonreplymessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, templatebuttonreplymessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  _impl_.templatebuttonreplymessage_ = templatebuttonreplymessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.templateButtonReplyMessage)
}

// optional .proto.ProductMessage productMessage = 30;
inline bool Message::_internal_has_productmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.productmessage_ != nullptr);
  return value;
}
inline bool Message::has_productmessage() const {
  return _internal_has_productmessage();
}
inline void Message::clear_productmessage() {
  if (_impl_.productmessage_ != nullptr) _impl_.productmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline const ::proto::ProductMessage& Message::_internal_productmessage() const {
  const ::proto::ProductMessage* p = _impl_.productmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ProductMessage&>(
      ::proto::_ProductMessage_default_instance_);
}
inline const ::proto::ProductMessage& Message::productmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.productMessage)
  return _internal_productmessage();
}
inline void Message::unsafe_arena_set_allocated_productmessage(
    ::proto::ProductMessage* productmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.productmessage_);
  }
  _impl_.productmessage_ = productmessage;
  if (productmessage) {
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.productMessage)
}
inline ::proto::ProductMessage* Message::release_productmessage() {
  _impl_._has_bits_[0] &= ~0x01000000u;
  ::proto::ProductMessage* temp = _impl_.productmessage_;
  _impl_.productmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ProductMessage* Message::unsafe_arena_release_productmessage() {
  // @@protoc_insertion_point(field_release:proto.Message.productMessage)
  _impl_._has_bits_[0] &= ~0x01000000u;
  ::proto::ProductMessage* temp = _impl_.productmessage_;
  _impl_.productmessage_ = nullptr;
  return temp;
}
inline ::proto::ProductMessage* Message::_internal_mutable_productmessage() {
  _impl_._has_bits_[0] |= 0x01000000u;
  if (_impl_.productmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ProductMessage>(GetArenaForAllocation());
    _impl_.productmessage_ = p;
  }
  return _impl_.productmessage_;
}
inline ::proto::ProductMessage* Message::mutable_productmessage() {
  ::proto::ProductMessage* _msg = _internal_mutable_productmessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.productMessage)
  return _msg;
}
inline void Message::set_allocated_productmessage(::proto::ProductMessage* productmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.productmessage_;
  }
  if (productmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(productmessage);
    if (message_arena != submessage_arena) {
      productmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, productmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  _impl_.productmessage_ = productmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.productMessage)
}

// optional .proto.DeviceSentMessage deviceSentMessage = 31;
inline bool Message::_internal_has_devicesentmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.devicesentmessage_ != nullptr);
  return value;
}
inline bool Message::has_devicesentmessage() const {
  return _internal_has_devicesentmessage();
}
inline void Message::clear_devicesentmessage() {
  if (_impl_.devicesentmessage_ != nullptr) _impl_.devicesentmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline const ::proto::DeviceSentMessage& Message::_internal_devicesentmessage() const {
  const ::proto::DeviceSentMessage* p = _impl_.devicesentmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::DeviceSentMessage&>(
      ::proto::_DeviceSentMessage_default_instance_);
}
inline const ::proto::DeviceSentMessage& Message::devicesentmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.deviceSentMessage)
  return _internal_devicesentmessage();
}
inline void Message::unsafe_arena_set_allocated_devicesentmessage(
    ::proto::DeviceSentMessage* devicesentmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.devicesentmessage_);
  }
  _impl_.devicesentmessage_ = devicesentmessage;
  if (devicesentmessage) {
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.deviceSentMessage)
}
inline ::proto::DeviceSentMessage* Message::release_devicesentmessage() {
  _impl_._has_bits_[0] &= ~0x02000000u;
  ::proto::DeviceSentMessage* temp = _impl_.devicesentmessage_;
  _impl_.devicesentmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::DeviceSentMessage* Message::unsafe_arena_release_devicesentmessage() {
  // @@protoc_insertion_point(field_release:proto.Message.deviceSentMessage)
  _impl_._has_bits_[0] &= ~0x02000000u;
  ::proto::DeviceSentMessage* temp = _impl_.devicesentmessage_;
  _impl_.devicesentmessage_ = nullptr;
  return temp;
}
inline ::proto::DeviceSentMessage* Message::_internal_mutable_devicesentmessage() {
  _impl_._has_bits_[0] |= 0x02000000u;
  if (_impl_.devicesentmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::DeviceSentMessage>(GetArenaForAllocation());
    _impl_.devicesentmessage_ = p;
  }
  return _impl_.devicesentmessage_;
}
inline ::proto::DeviceSentMessage* Message::mutable_devicesentmessage() {
  ::proto::DeviceSentMessage* _msg = _internal_mutable_devicesentmessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.deviceSentMessage)
  return _msg;
}
inline void Message::set_allocated_devicesentmessage(::proto::DeviceSentMessage* devicesentmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.devicesentmessage_;
  }
  if (devicesentmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(devicesentmessage);
    if (message_arena != submessage_arena) {
      devicesentmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, devicesentmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  _impl_.devicesentmessage_ = devicesentmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.deviceSentMessage)
}

// optional .proto.MessageContextInfo messageContextInfo = 35;
inline bool Message::_internal_has_messagecontextinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.messagecontextinfo_ != nullptr);
  return value;
}
inline bool Message::has_messagecontextinfo() const {
  return _internal_has_messagecontextinfo();
}
inline void Message::clear_messagecontextinfo() {
  if (_impl_.messagecontextinfo_ != nullptr) _impl_.messagecontextinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline const ::proto::MessageContextInfo& Message::_internal_messagecontextinfo() const {
  const ::proto::MessageContextInfo* p = _impl_.messagecontextinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::MessageContextInfo&>(
      ::proto::_MessageContextInfo_default_instance_);
}
inline const ::proto::MessageContextInfo& Message::messagecontextinfo() const {
  // @@protoc_insertion_point(field_get:proto.Message.messageContextInfo)
  return _internal_messagecontextinfo();
}
inline void Message::unsafe_arena_set_allocated_messagecontextinfo(
    ::proto::MessageContextInfo* messagecontextinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.messagecontextinfo_);
  }
  _impl_.messagecontextinfo_ = messagecontextinfo;
  if (messagecontextinfo) {
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.messageContextInfo)
}
inline ::proto::MessageContextInfo* Message::release_messagecontextinfo() {
  _impl_._has_bits_[0] &= ~0x04000000u;
  ::proto::MessageContextInfo* temp = _impl_.messagecontextinfo_;
  _impl_.messagecontextinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::MessageContextInfo* Message::unsafe_arena_release_messagecontextinfo() {
  // @@protoc_insertion_point(field_release:proto.Message.messageContextInfo)
  _impl_._has_bits_[0] &= ~0x04000000u;
  ::proto::MessageContextInfo* temp = _impl_.messagecontextinfo_;
  _impl_.messagecontextinfo_ = nullptr;
  return temp;
}
inline ::proto::MessageContextInfo* Message::_internal_mutable_messagecontextinfo() {
  _impl_._has_bits_[0] |= 0x04000000u;
  if (_impl_.messagecontextinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::MessageContextInfo>(GetArenaForAllocation());
    _impl_.messagecontextinfo_ = p;
  }
  return _impl_.messagecontextinfo_;
}
inline ::proto::MessageContextInfo* Message::mutable_messagecontextinfo() {
  ::proto::MessageContextInfo* _msg = _internal_mutable_messagecontextinfo();
  // @@protoc_insertion_point(field_mutable:proto.Message.messageContextInfo)
  return _msg;
}
inline void Message::set_allocated_messagecontextinfo(::proto::MessageContextInfo* messagecontextinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.messagecontextinfo_;
  }
  if (messagecontextinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(messagecontextinfo);
    if (message_arena != submessage_arena) {
      messagecontextinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, messagecontextinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  _impl_.messagecontextinfo_ = messagecontextinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.messageContextInfo)
}

// optional .proto.ListMessage listMessage = 36;
inline bool Message::_internal_has_listmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.listmessage_ != nullptr);
  return value;
}
inline bool Message::has_listmessage() const {
  return _internal_has_listmessage();
}
inline void Message::clear_listmessage() {
  if (_impl_.listmessage_ != nullptr) _impl_.listmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline const ::proto::ListMessage& Message::_internal_listmessage() const {
  const ::proto::ListMessage* p = _impl_.listmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ListMessage&>(
      ::proto::_ListMessage_default_instance_);
}
inline const ::proto::ListMessage& Message::listmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.listMessage)
  return _internal_listmessage();
}
inline void Message::unsafe_arena_set_allocated_listmessage(
    ::proto::ListMessage* listmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.listmessage_);
  }
  _impl_.listmessage_ = listmessage;
  if (listmessage) {
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.listMessage)
}
inline ::proto::ListMessage* Message::release_listmessage() {
  _impl_._has_bits_[0] &= ~0x08000000u;
  ::proto::ListMessage* temp = _impl_.listmessage_;
  _impl_.listmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ListMessage* Message::unsafe_arena_release_listmessage() {
  // @@protoc_insertion_point(field_release:proto.Message.listMessage)
  _impl_._has_bits_[0] &= ~0x08000000u;
  ::proto::ListMessage* temp = _impl_.listmessage_;
  _impl_.listmessage_ = nullptr;
  return temp;
}
inline ::proto::ListMessage* Message::_internal_mutable_listmessage() {
  _impl_._has_bits_[0] |= 0x08000000u;
  if (_impl_.listmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ListMessage>(GetArenaForAllocation());
    _impl_.listmessage_ = p;
  }
  return _impl_.listmessage_;
}
inline ::proto::ListMessage* Message::mutable_listmessage() {
  ::proto::ListMessage* _msg = _internal_mutable_listmessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.listMessage)
  return _msg;
}
inline void Message::set_allocated_listmessage(::proto::ListMessage* listmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.listmessage_;
  }
  if (listmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(listmessage);
    if (message_arena != submessage_arena) {
      listmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, listmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  _impl_.listmessage_ = listmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.listMessage)
}

// optional .proto.FutureProofMessage viewOnceMessage = 37;
inline bool Message::_internal_has_viewoncemessage() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.viewoncemessage_ != nullptr);
  return value;
}
inline bool Message::has_viewoncemessage() const {
  return _internal_has_viewoncemessage();
}
inline void Message::clear_viewoncemessage() {
  if (_impl_.viewoncemessage_ != nullptr) _impl_.viewoncemessage_->Clear();
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline const ::proto::FutureProofMessage& Message::_internal_viewoncemessage() const {
  const ::proto::FutureProofMessage* p = _impl_.viewoncemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::FutureProofMessage&>(
      ::proto::_FutureProofMessage_default_instance_);
}
inline const ::proto::FutureProofMessage& Message::viewoncemessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.viewOnceMessage)
  return _internal_viewoncemessage();
}
inline void Message::unsafe_arena_set_allocated_viewoncemessage(
    ::proto::FutureProofMessage* viewoncemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.viewoncemessage_);
  }
  _impl_.viewoncemessage_ = viewoncemessage;
  if (viewoncemessage) {
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.viewOnceMessage)
}
inline ::proto::FutureProofMessage* Message::release_viewoncemessage() {
  _impl_._has_bits_[0] &= ~0x10000000u;
  ::proto::FutureProofMessage* temp = _impl_.viewoncemessage_;
  _impl_.viewoncemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::FutureProofMessage* Message::unsafe_arena_release_viewoncemessage() {
  // @@protoc_insertion_point(field_release:proto.Message.viewOnceMessage)
  _impl_._has_bits_[0] &= ~0x10000000u;
  ::proto::FutureProofMessage* temp = _impl_.viewoncemessage_;
  _impl_.viewoncemessage_ = nullptr;
  return temp;
}
inline ::proto::FutureProofMessage* Message::_internal_mutable_viewoncemessage() {
  _impl_._has_bits_[0] |= 0x10000000u;
  if (_impl_.viewoncemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::FutureProofMessage>(GetArenaForAllocation());
    _impl_.viewoncemessage_ = p;
  }
  return _impl_.viewoncemessage_;
}
inline ::proto::FutureProofMessage* Message::mutable_viewoncemessage() {
  ::proto::FutureProofMessage* _msg = _internal_mutable_viewoncemessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.viewOnceMessage)
  return _msg;
}
inline void Message::set_allocated_viewoncemessage(::proto::FutureProofMessage* viewoncemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.viewoncemessage_;
  }
  if (viewoncemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(viewoncemessage);
    if (message_arena != submessage_arena) {
      viewoncemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, viewoncemessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  _impl_.viewoncemessage_ = viewoncemessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.viewOnceMessage)
}

// optional .proto.OrderMessage orderMessage = 38;
inline bool Message::_internal_has_ordermessage() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ordermessage_ != nullptr);
  return value;
}
inline bool Message::has_ordermessage() const {
  return _internal_has_ordermessage();
}
inline void Message::clear_ordermessage() {
  if (_impl_.ordermessage_ != nullptr) _impl_.ordermessage_->Clear();
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline const ::proto::OrderMessage& Message::_internal_ordermessage() const {
  const ::proto::OrderMessage* p = _impl_.ordermessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::OrderMessage&>(
      ::proto::_OrderMessage_default_instance_);
}
inline const ::proto::OrderMessage& Message::ordermessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.orderMessage)
  return _internal_ordermessage();
}
inline void Message::unsafe_arena_set_allocated_ordermessage(
    ::proto::OrderMessage* ordermessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ordermessage_);
  }
  _impl_.ordermessage_ = ordermessage;
  if (ordermessage) {
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.orderMessage)
}
inline ::proto::OrderMessage* Message::release_ordermessage() {
  _impl_._has_bits_[0] &= ~0x20000000u;
  ::proto::OrderMessage* temp = _impl_.ordermessage_;
  _impl_.ordermessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::OrderMessage* Message::unsafe_arena_release_ordermessage() {
  // @@protoc_insertion_point(field_release:proto.Message.orderMessage)
  _impl_._has_bits_[0] &= ~0x20000000u;
  ::proto::OrderMessage* temp = _impl_.ordermessage_;
  _impl_.ordermessage_ = nullptr;
  return temp;
}
inline ::proto::OrderMessage* Message::_internal_mutable_ordermessage() {
  _impl_._has_bits_[0] |= 0x20000000u;
  if (_impl_.ordermessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::OrderMessage>(GetArenaForAllocation());
    _impl_.ordermessage_ = p;
  }
  return _impl_.ordermessage_;
}
inline ::proto::OrderMessage* Message::mutable_ordermessage() {
  ::proto::OrderMessage* _msg = _internal_mutable_ordermessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.orderMessage)
  return _msg;
}
inline void Message::set_allocated_ordermessage(::proto::OrderMessage* ordermessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ordermessage_;
  }
  if (ordermessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ordermessage);
    if (message_arena != submessage_arena) {
      ordermessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ordermessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  _impl_.ordermessage_ = ordermessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.orderMessage)
}

// optional .proto.ListResponseMessage listResponseMessage = 39;
inline bool Message::_internal_has_listresponsemessage() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.listresponsemessage_ != nullptr);
  return value;
}
inline bool Message::has_listresponsemessage() const {
  return _internal_has_listresponsemessage();
}
inline void Message::clear_listresponsemessage() {
  if (_impl_.listresponsemessage_ != nullptr) _impl_.listresponsemessage_->Clear();
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline const ::proto::ListResponseMessage& Message::_internal_listresponsemessage() const {
  const ::proto::ListResponseMessage* p = _impl_.listresponsemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ListResponseMessage&>(
      ::proto::_ListResponseMessage_default_instance_);
}
inline const ::proto::ListResponseMessage& Message::listresponsemessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.listResponseMessage)
  return _internal_listresponsemessage();
}
inline void Message::unsafe_arena_set_allocated_listresponsemessage(
    ::proto::ListResponseMessage* listresponsemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.listresponsemessage_);
  }
  _impl_.listresponsemessage_ = listresponsemessage;
  if (listresponsemessage) {
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.listResponseMessage)
}
inline ::proto::ListResponseMessage* Message::release_listresponsemessage() {
  _impl_._has_bits_[0] &= ~0x40000000u;
  ::proto::ListResponseMessage* temp = _impl_.listresponsemessage_;
  _impl_.listresponsemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ListResponseMessage* Message::unsafe_arena_release_listresponsemessage() {
  // @@protoc_insertion_point(field_release:proto.Message.listResponseMessage)
  _impl_._has_bits_[0] &= ~0x40000000u;
  ::proto::ListResponseMessage* temp = _impl_.listresponsemessage_;
  _impl_.listresponsemessage_ = nullptr;
  return temp;
}
inline ::proto::ListResponseMessage* Message::_internal_mutable_listresponsemessage() {
  _impl_._has_bits_[0] |= 0x40000000u;
  if (_impl_.listresponsemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ListResponseMessage>(GetArenaForAllocation());
    _impl_.listresponsemessage_ = p;
  }
  return _impl_.listresponsemessage_;
}
inline ::proto::ListResponseMessage* Message::mutable_listresponsemessage() {
  ::proto::ListResponseMessage* _msg = _internal_mutable_listresponsemessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.listResponseMessage)
  return _msg;
}
inline void Message::set_allocated_listresponsemessage(::proto::ListResponseMessage* listresponsemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.listresponsemessage_;
  }
  if (listresponsemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(listresponsemessage);
    if (message_arena != submessage_arena) {
      listresponsemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, listresponsemessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }
  _impl_.listresponsemessage_ = listresponsemessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.listResponseMessage)
}

// optional .proto.FutureProofMessage ephemeralMessage = 40;
inline bool Message::_internal_has_ephemeralmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ephemeralmessage_ != nullptr);
  return value;
}
inline bool Message::has_ephemeralmessage() const {
  return _internal_has_ephemeralmessage();
}
inline void Message::clear_ephemeralmessage() {
  if (_impl_.ephemeralmessage_ != nullptr) _impl_.ephemeralmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline const ::proto::FutureProofMessage& Message::_internal_ephemeralmessage() const {
  const ::proto::FutureProofMessage* p = _impl_.ephemeralmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::FutureProofMessage&>(
      ::proto::_FutureProofMessage_default_instance_);
}
inline const ::proto::FutureProofMessage& Message::ephemeralmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.ephemeralMessage)
  return _internal_ephemeralmessage();
}
inline void Message::unsafe_arena_set_allocated_ephemeralmessage(
    ::proto::FutureProofMessage* ephemeralmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ephemeralmessage_);
  }
  _impl_.ephemeralmessage_ = ephemeralmessage;
  if (ephemeralmessage) {
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.ephemeralMessage)
}
inline ::proto::FutureProofMessage* Message::release_ephemeralmessage() {
  _impl_._has_bits_[0] &= ~0x80000000u;
  ::proto::FutureProofMessage* temp = _impl_.ephemeralmessage_;
  _impl_.ephemeralmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::FutureProofMessage* Message::unsafe_arena_release_ephemeralmessage() {
  // @@protoc_insertion_point(field_release:proto.Message.ephemeralMessage)
  _impl_._has_bits_[0] &= ~0x80000000u;
  ::proto::FutureProofMessage* temp = _impl_.ephemeralmessage_;
  _impl_.ephemeralmessage_ = nullptr;
  return temp;
}
inline ::proto::FutureProofMessage* Message::_internal_mutable_ephemeralmessage() {
  _impl_._has_bits_[0] |= 0x80000000u;
  if (_impl_.ephemeralmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::FutureProofMessage>(GetArenaForAllocation());
    _impl_.ephemeralmessage_ = p;
  }
  return _impl_.ephemeralmessage_;
}
inline ::proto::FutureProofMessage* Message::mutable_ephemeralmessage() {
  ::proto::FutureProofMessage* _msg = _internal_mutable_ephemeralmessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.ephemeralMessage)
  return _msg;
}
inline void Message::set_allocated_ephemeralmessage(::proto::FutureProofMessage* ephemeralmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ephemeralmessage_;
  }
  if (ephemeralmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ephemeralmessage);
    if (message_arena != submessage_arena) {
      ephemeralmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ephemeralmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }
  _impl_.ephemeralmessage_ = ephemeralmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.ephemeralMessage)
}

// optional .proto.InvoiceMessage invoiceMessage = 41;
inline bool Message::_internal_has_invoicemessage() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.invoicemessage_ != nullptr);
  return value;
}
inline bool Message::has_invoicemessage() const {
  return _internal_has_invoicemessage();
}
inline void Message::clear_invoicemessage() {
  if (_impl_.invoicemessage_ != nullptr) _impl_.invoicemessage_->Clear();
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline const ::proto::InvoiceMessage& Message::_internal_invoicemessage() const {
  const ::proto::InvoiceMessage* p = _impl_.invoicemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::InvoiceMessage&>(
      ::proto::_InvoiceMessage_default_instance_);
}
inline const ::proto::InvoiceMessage& Message::invoicemessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.invoiceMessage)
  return _internal_invoicemessage();
}
inline void Message::unsafe_arena_set_allocated_invoicemessage(
    ::proto::InvoiceMessage* invoicemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.invoicemessage_);
  }
  _impl_.invoicemessage_ = invoicemessage;
  if (invoicemessage) {
    _impl_._has_bits_[1] |= 0x00000001u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.invoiceMessage)
}
inline ::proto::InvoiceMessage* Message::release_invoicemessage() {
  _impl_._has_bits_[1] &= ~0x00000001u;
  ::proto::InvoiceMessage* temp = _impl_.invoicemessage_;
  _impl_.invoicemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::InvoiceMessage* Message::unsafe_arena_release_invoicemessage() {
  // @@protoc_insertion_point(field_release:proto.Message.invoiceMessage)
  _impl_._has_bits_[1] &= ~0x00000001u;
  ::proto::InvoiceMessage* temp = _impl_.invoicemessage_;
  _impl_.invoicemessage_ = nullptr;
  return temp;
}
inline ::proto::InvoiceMessage* Message::_internal_mutable_invoicemessage() {
  _impl_._has_bits_[1] |= 0x00000001u;
  if (_impl_.invoicemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::InvoiceMessage>(GetArenaForAllocation());
    _impl_.invoicemessage_ = p;
  }
  return _impl_.invoicemessage_;
}
inline ::proto::InvoiceMessage* Message::mutable_invoicemessage() {
  ::proto::InvoiceMessage* _msg = _internal_mutable_invoicemessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.invoiceMessage)
  return _msg;
}
inline void Message::set_allocated_invoicemessage(::proto::InvoiceMessage* invoicemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.invoicemessage_;
  }
  if (invoicemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(invoicemessage);
    if (message_arena != submessage_arena) {
      invoicemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invoicemessage, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000001u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000001u;
  }
  _impl_.invoicemessage_ = invoicemessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.invoiceMessage)
}

// optional .proto.ButtonsMessage buttonsMessage = 42;
inline bool Message::_internal_has_buttonsmessage() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.buttonsmessage_ != nullptr);
  return value;
}
inline bool Message::has_buttonsmessage() const {
  return _internal_has_buttonsmessage();
}
inline void Message::clear_buttonsmessage() {
  if (_impl_.buttonsmessage_ != nullptr) _impl_.buttonsmessage_->Clear();
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline const ::proto::ButtonsMessage& Message::_internal_buttonsmessage() const {
  const ::proto::ButtonsMessage* p = _impl_.buttonsmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ButtonsMessage&>(
      ::proto::_ButtonsMessage_default_instance_);
}
inline const ::proto::ButtonsMessage& Message::buttonsmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.buttonsMessage)
  return _internal_buttonsmessage();
}
inline void Message::unsafe_arena_set_allocated_buttonsmessage(
    ::proto::ButtonsMessage* buttonsmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.buttonsmessage_);
  }
  _impl_.buttonsmessage_ = buttonsmessage;
  if (buttonsmessage) {
    _impl_._has_bits_[1] |= 0x00000002u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.buttonsMessage)
}
inline ::proto::ButtonsMessage* Message::release_buttonsmessage() {
  _impl_._has_bits_[1] &= ~0x00000002u;
  ::proto::ButtonsMessage* temp = _impl_.buttonsmessage_;
  _impl_.buttonsmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ButtonsMessage* Message::unsafe_arena_release_buttonsmessage() {
  // @@protoc_insertion_point(field_release:proto.Message.buttonsMessage)
  _impl_._has_bits_[1] &= ~0x00000002u;
  ::proto::ButtonsMessage* temp = _impl_.buttonsmessage_;
  _impl_.buttonsmessage_ = nullptr;
  return temp;
}
inline ::proto::ButtonsMessage* Message::_internal_mutable_buttonsmessage() {
  _impl_._has_bits_[1] |= 0x00000002u;
  if (_impl_.buttonsmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ButtonsMessage>(GetArenaForAllocation());
    _impl_.buttonsmessage_ = p;
  }
  return _impl_.buttonsmessage_;
}
inline ::proto::ButtonsMessage* Message::mutable_buttonsmessage() {
  ::proto::ButtonsMessage* _msg = _internal_mutable_buttonsmessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.buttonsMessage)
  return _msg;
}
inline void Message::set_allocated_buttonsmessage(::proto::ButtonsMessage* buttonsmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.buttonsmessage_;
  }
  if (buttonsmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(buttonsmessage);
    if (message_arena != submessage_arena) {
      buttonsmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buttonsmessage, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000002u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000002u;
  }
  _impl_.buttonsmessage_ = buttonsmessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.buttonsMessage)
}

// optional .proto.ButtonsResponseMessage buttonsResponseMessage = 43;
inline bool Message::_internal_has_buttonsresponsemessage() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.buttonsresponsemessage_ != nullptr);
  return value;
}
inline bool Message::has_buttonsresponsemessage() const {
  return _internal_has_buttonsresponsemessage();
}
inline void Message::clear_buttonsresponsemessage() {
  if (_impl_.buttonsresponsemessage_ != nullptr) _impl_.buttonsresponsemessage_->Clear();
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline const ::proto::ButtonsResponseMessage& Message::_internal_buttonsresponsemessage() const {
  const ::proto::ButtonsResponseMessage* p = _impl_.buttonsresponsemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ButtonsResponseMessage&>(
      ::proto::_ButtonsResponseMessage_default_instance_);
}
inline const ::proto::ButtonsResponseMessage& Message::buttonsresponsemessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.buttonsResponseMessage)
  return _internal_buttonsresponsemessage();
}
inline void Message::unsafe_arena_set_allocated_buttonsresponsemessage(
    ::proto::ButtonsResponseMessage* buttonsresponsemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.buttonsresponsemessage_);
  }
  _impl_.buttonsresponsemessage_ = buttonsresponsemessage;
  if (buttonsresponsemessage) {
    _impl_._has_bits_[1] |= 0x00000004u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Message.buttonsResponseMessage)
}
inline ::proto::ButtonsResponseMessage* Message::release_buttonsresponsemessage() {
  _impl_._has_bits_[1] &= ~0x00000004u;
  ::proto::ButtonsResponseMessage* temp = _impl_.buttonsresponsemessage_;
  _impl_.buttonsresponsemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ButtonsResponseMessage* Message::unsafe_arena_release_buttonsresponsemessage() {
  // @@protoc_insertion_point(field_release:proto.Message.buttonsResponseMessage)
  _impl_._has_bits_[1] &= ~0x00000004u;
  ::proto::ButtonsResponseMessage* temp = _impl_.buttonsresponsemessage_;
  _impl_.buttonsresponsemessage_ = nullptr;
  return temp;
}
inline ::proto::ButtonsResponseMessage* Message::_internal_mutable_buttonsresponsemessage() {
  _impl_._has_bits_[1] |= 0x00000004u;
  if (_impl_.buttonsresponsemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ButtonsResponseMessage>(GetArenaForAllocation());
    _impl_.buttonsresponsemessage_ = p;
  }
  return _impl_.buttonsresponsemessage_;
}
inline ::proto::ButtonsResponseMessage* Message::mutable_buttonsresponsemessage() {
  ::proto::ButtonsResponseMessage* _msg = _internal_mutable_buttonsresponsemessage();
  // @@protoc_insertion_point(field_mutable:proto.Message.buttonsResponseMessage)
  return _msg;
}
inline void Message::set_allocated_buttonsresponsemessage(::proto::ButtonsResponseMessage* buttonsresponsemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.buttonsresponsemessage_;
  }
  if (buttonsresponsemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(buttonsresponsemessage);
    if (message_arena != submessage_arena) {
      buttonsresponsemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buttonsresponsemessage, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000004u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000004u;
  }
  _impl_.buttonsresponsemessage_ = buttonsresponsemessage;
  // @@protoc_insertion_point(field_set_allocated:proto.Message.buttonsResponseMessage)
}

// -------------------------------------------------------------------

// MessageKey

// optional string remoteJid = 1;
inline bool MessageKey::_internal_has_remotejid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MessageKey::has_remotejid() const {
  return _internal_has_remotejid();
}
inline void MessageKey::clear_remotejid() {
  _impl_.remotejid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MessageKey::remotejid() const {
  // @@protoc_insertion_point(field_get:proto.MessageKey.remoteJid)
  return _internal_remotejid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageKey::set_remotejid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.remotejid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MessageKey.remoteJid)
}
inline std::string* MessageKey::mutable_remotejid() {
  std::string* _s = _internal_mutable_remotejid();
  // @@protoc_insertion_point(field_mutable:proto.MessageKey.remoteJid)
  return _s;
}
inline const std::string& MessageKey::_internal_remotejid() const {
  return _impl_.remotejid_.Get();
}
inline void MessageKey::_internal_set_remotejid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.remotejid_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageKey::_internal_mutable_remotejid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.remotejid_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageKey::release_remotejid() {
  // @@protoc_insertion_point(field_release:proto.MessageKey.remoteJid)
  if (!_internal_has_remotejid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.remotejid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remotejid_.IsDefault()) {
    _impl_.remotejid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MessageKey::set_allocated_remotejid(std::string* remotejid) {
  if (remotejid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.remotejid_.SetAllocated(remotejid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remotejid_.IsDefault()) {
    _impl_.remotejid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MessageKey.remoteJid)
}

// optional bool fromMe = 2;
inline bool MessageKey::_internal_has_fromme() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MessageKey::has_fromme() const {
  return _internal_has_fromme();
}
inline void MessageKey::clear_fromme() {
  _impl_.fromme_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool MessageKey::_internal_fromme() const {
  return _impl_.fromme_;
}
inline bool MessageKey::fromme() const {
  // @@protoc_insertion_point(field_get:proto.MessageKey.fromMe)
  return _internal_fromme();
}
inline void MessageKey::_internal_set_fromme(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.fromme_ = value;
}
inline void MessageKey::set_fromme(bool value) {
  _internal_set_fromme(value);
  // @@protoc_insertion_point(field_set:proto.MessageKey.fromMe)
}

// optional string id = 3;
inline bool MessageKey::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MessageKey::has_id() const {
  return _internal_has_id();
}
inline void MessageKey::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MessageKey::id() const {
  // @@protoc_insertion_point(field_get:proto.MessageKey.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageKey::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MessageKey.id)
}
inline std::string* MessageKey::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:proto.MessageKey.id)
  return _s;
}
inline const std::string& MessageKey::_internal_id() const {
  return _impl_.id_.Get();
}
inline void MessageKey::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageKey::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageKey::release_id() {
  // @@protoc_insertion_point(field_release:proto.MessageKey.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MessageKey::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MessageKey.id)
}

// optional string participant = 4;
inline bool MessageKey::_internal_has_participant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MessageKey::has_participant() const {
  return _internal_has_participant();
}
inline void MessageKey::clear_participant() {
  _impl_.participant_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MessageKey::participant() const {
  // @@protoc_insertion_point(field_get:proto.MessageKey.participant)
  return _internal_participant();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageKey::set_participant(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.participant_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MessageKey.participant)
}
inline std::string* MessageKey::mutable_participant() {
  std::string* _s = _internal_mutable_participant();
  // @@protoc_insertion_point(field_mutable:proto.MessageKey.participant)
  return _s;
}
inline const std::string& MessageKey::_internal_participant() const {
  return _impl_.participant_.Get();
}
inline void MessageKey::_internal_set_participant(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.participant_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageKey::_internal_mutable_participant() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.participant_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageKey::release_participant() {
  // @@protoc_insertion_point(field_release:proto.MessageKey.participant)
  if (!_internal_has_participant()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.participant_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_.IsDefault()) {
    _impl_.participant_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MessageKey::set_allocated_participant(std::string* participant) {
  if (participant != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.participant_.SetAllocated(participant, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_.IsDefault()) {
    _impl_.participant_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MessageKey.participant)
}

// -------------------------------------------------------------------

// WebFeatures

// optional .proto.WebFeatures.WebFeaturesFlag labelsDisplay = 1;
inline bool WebFeatures::_internal_has_labelsdisplay() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WebFeatures::has_labelsdisplay() const {
  return _internal_has_labelsdisplay();
}
inline void WebFeatures::clear_labelsdisplay() {
  _impl_.labelsdisplay_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_labelsdisplay() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.labelsdisplay_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::labelsdisplay() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.labelsDisplay)
  return _internal_labelsdisplay();
}
inline void WebFeatures::_internal_set_labelsdisplay(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.labelsdisplay_ = value;
}
inline void WebFeatures::set_labelsdisplay(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_labelsdisplay(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.labelsDisplay)
}

// optional .proto.WebFeatures.WebFeaturesFlag voipIndividualOutgoing = 2;
inline bool WebFeatures::_internal_has_voipindividualoutgoing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WebFeatures::has_voipindividualoutgoing() const {
  return _internal_has_voipindividualoutgoing();
}
inline void WebFeatures::clear_voipindividualoutgoing() {
  _impl_.voipindividualoutgoing_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_voipindividualoutgoing() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.voipindividualoutgoing_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::voipindividualoutgoing() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.voipIndividualOutgoing)
  return _internal_voipindividualoutgoing();
}
inline void WebFeatures::_internal_set_voipindividualoutgoing(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.voipindividualoutgoing_ = value;
}
inline void WebFeatures::set_voipindividualoutgoing(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_voipindividualoutgoing(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.voipIndividualOutgoing)
}

// optional .proto.WebFeatures.WebFeaturesFlag groupsV3 = 3;
inline bool WebFeatures::_internal_has_groupsv3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WebFeatures::has_groupsv3() const {
  return _internal_has_groupsv3();
}
inline void WebFeatures::clear_groupsv3() {
  _impl_.groupsv3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_groupsv3() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.groupsv3_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::groupsv3() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.groupsV3)
  return _internal_groupsv3();
}
inline void WebFeatures::_internal_set_groupsv3(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.groupsv3_ = value;
}
inline void WebFeatures::set_groupsv3(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_groupsv3(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.groupsV3)
}

// optional .proto.WebFeatures.WebFeaturesFlag groupsV3Create = 4;
inline bool WebFeatures::_internal_has_groupsv3create() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool WebFeatures::has_groupsv3create() const {
  return _internal_has_groupsv3create();
}
inline void WebFeatures::clear_groupsv3create() {
  _impl_.groupsv3create_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_groupsv3create() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.groupsv3create_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::groupsv3create() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.groupsV3Create)
  return _internal_groupsv3create();
}
inline void WebFeatures::_internal_set_groupsv3create(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.groupsv3create_ = value;
}
inline void WebFeatures::set_groupsv3create(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_groupsv3create(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.groupsV3Create)
}

// optional .proto.WebFeatures.WebFeaturesFlag changeNumberV2 = 5;
inline bool WebFeatures::_internal_has_changenumberv2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool WebFeatures::has_changenumberv2() const {
  return _internal_has_changenumberv2();
}
inline void WebFeatures::clear_changenumberv2() {
  _impl_.changenumberv2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_changenumberv2() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.changenumberv2_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::changenumberv2() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.changeNumberV2)
  return _internal_changenumberv2();
}
inline void WebFeatures::_internal_set_changenumberv2(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.changenumberv2_ = value;
}
inline void WebFeatures::set_changenumberv2(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_changenumberv2(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.changeNumberV2)
}

// optional .proto.WebFeatures.WebFeaturesFlag queryStatusV3Thumbnail = 6;
inline bool WebFeatures::_internal_has_querystatusv3thumbnail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool WebFeatures::has_querystatusv3thumbnail() const {
  return _internal_has_querystatusv3thumbnail();
}
inline void WebFeatures::clear_querystatusv3thumbnail() {
  _impl_.querystatusv3thumbnail_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_querystatusv3thumbnail() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.querystatusv3thumbnail_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::querystatusv3thumbnail() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.queryStatusV3Thumbnail)
  return _internal_querystatusv3thumbnail();
}
inline void WebFeatures::_internal_set_querystatusv3thumbnail(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.querystatusv3thumbnail_ = value;
}
inline void WebFeatures::set_querystatusv3thumbnail(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_querystatusv3thumbnail(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.queryStatusV3Thumbnail)
}

// optional .proto.WebFeatures.WebFeaturesFlag liveLocations = 7;
inline bool WebFeatures::_internal_has_livelocations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool WebFeatures::has_livelocations() const {
  return _internal_has_livelocations();
}
inline void WebFeatures::clear_livelocations() {
  _impl_.livelocations_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_livelocations() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.livelocations_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::livelocations() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.liveLocations)
  return _internal_livelocations();
}
inline void WebFeatures::_internal_set_livelocations(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.livelocations_ = value;
}
inline void WebFeatures::set_livelocations(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_livelocations(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.liveLocations)
}

// optional .proto.WebFeatures.WebFeaturesFlag queryVname = 8;
inline bool WebFeatures::_internal_has_queryvname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool WebFeatures::has_queryvname() const {
  return _internal_has_queryvname();
}
inline void WebFeatures::clear_queryvname() {
  _impl_.queryvname_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_queryvname() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.queryvname_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::queryvname() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.queryVname)
  return _internal_queryvname();
}
inline void WebFeatures::_internal_set_queryvname(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.queryvname_ = value;
}
inline void WebFeatures::set_queryvname(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_queryvname(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.queryVname)
}

// optional .proto.WebFeatures.WebFeaturesFlag voipIndividualIncoming = 9;
inline bool WebFeatures::_internal_has_voipindividualincoming() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool WebFeatures::has_voipindividualincoming() const {
  return _internal_has_voipindividualincoming();
}
inline void WebFeatures::clear_voipindividualincoming() {
  _impl_.voipindividualincoming_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_voipindividualincoming() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.voipindividualincoming_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::voipindividualincoming() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.voipIndividualIncoming)
  return _internal_voipindividualincoming();
}
inline void WebFeatures::_internal_set_voipindividualincoming(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.voipindividualincoming_ = value;
}
inline void WebFeatures::set_voipindividualincoming(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_voipindividualincoming(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.voipIndividualIncoming)
}

// optional .proto.WebFeatures.WebFeaturesFlag quickRepliesQuery = 10;
inline bool WebFeatures::_internal_has_quickrepliesquery() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool WebFeatures::has_quickrepliesquery() const {
  return _internal_has_quickrepliesquery();
}
inline void WebFeatures::clear_quickrepliesquery() {
  _impl_.quickrepliesquery_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_quickrepliesquery() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.quickrepliesquery_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::quickrepliesquery() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.quickRepliesQuery)
  return _internal_quickrepliesquery();
}
inline void WebFeatures::_internal_set_quickrepliesquery(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.quickrepliesquery_ = value;
}
inline void WebFeatures::set_quickrepliesquery(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_quickrepliesquery(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.quickRepliesQuery)
}

// optional .proto.WebFeatures.WebFeaturesFlag payments = 11;
inline bool WebFeatures::_internal_has_payments() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool WebFeatures::has_payments() const {
  return _internal_has_payments();
}
inline void WebFeatures::clear_payments() {
  _impl_.payments_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_payments() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.payments_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::payments() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.payments)
  return _internal_payments();
}
inline void WebFeatures::_internal_set_payments(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.payments_ = value;
}
inline void WebFeatures::set_payments(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_payments(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.payments)
}

// optional .proto.WebFeatures.WebFeaturesFlag stickerPackQuery = 12;
inline bool WebFeatures::_internal_has_stickerpackquery() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool WebFeatures::has_stickerpackquery() const {
  return _internal_has_stickerpackquery();
}
inline void WebFeatures::clear_stickerpackquery() {
  _impl_.stickerpackquery_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_stickerpackquery() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.stickerpackquery_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::stickerpackquery() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.stickerPackQuery)
  return _internal_stickerpackquery();
}
inline void WebFeatures::_internal_set_stickerpackquery(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.stickerpackquery_ = value;
}
inline void WebFeatures::set_stickerpackquery(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_stickerpackquery(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.stickerPackQuery)
}

// optional .proto.WebFeatures.WebFeaturesFlag liveLocationsFinal = 13;
inline bool WebFeatures::_internal_has_livelocationsfinal() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool WebFeatures::has_livelocationsfinal() const {
  return _internal_has_livelocationsfinal();
}
inline void WebFeatures::clear_livelocationsfinal() {
  _impl_.livelocationsfinal_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_livelocationsfinal() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.livelocationsfinal_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::livelocationsfinal() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.liveLocationsFinal)
  return _internal_livelocationsfinal();
}
inline void WebFeatures::_internal_set_livelocationsfinal(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.livelocationsfinal_ = value;
}
inline void WebFeatures::set_livelocationsfinal(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_livelocationsfinal(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.liveLocationsFinal)
}

// optional .proto.WebFeatures.WebFeaturesFlag labelsEdit = 14;
inline bool WebFeatures::_internal_has_labelsedit() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool WebFeatures::has_labelsedit() const {
  return _internal_has_labelsedit();
}
inline void WebFeatures::clear_labelsedit() {
  _impl_.labelsedit_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_labelsedit() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.labelsedit_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::labelsedit() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.labelsEdit)
  return _internal_labelsedit();
}
inline void WebFeatures::_internal_set_labelsedit(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.labelsedit_ = value;
}
inline void WebFeatures::set_labelsedit(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_labelsedit(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.labelsEdit)
}

// optional .proto.WebFeatures.WebFeaturesFlag mediaUpload = 15;
inline bool WebFeatures::_internal_has_mediaupload() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool WebFeatures::has_mediaupload() const {
  return _internal_has_mediaupload();
}
inline void WebFeatures::clear_mediaupload() {
  _impl_.mediaupload_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_mediaupload() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.mediaupload_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::mediaupload() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.mediaUpload)
  return _internal_mediaupload();
}
inline void WebFeatures::_internal_set_mediaupload(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.mediaupload_ = value;
}
inline void WebFeatures::set_mediaupload(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_mediaupload(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.mediaUpload)
}

// optional .proto.WebFeatures.WebFeaturesFlag mediaUploadRichQuickReplies = 18;
inline bool WebFeatures::_internal_has_mediauploadrichquickreplies() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool WebFeatures::has_mediauploadrichquickreplies() const {
  return _internal_has_mediauploadrichquickreplies();
}
inline void WebFeatures::clear_mediauploadrichquickreplies() {
  _impl_.mediauploadrichquickreplies_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_mediauploadrichquickreplies() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.mediauploadrichquickreplies_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::mediauploadrichquickreplies() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.mediaUploadRichQuickReplies)
  return _internal_mediauploadrichquickreplies();
}
inline void WebFeatures::_internal_set_mediauploadrichquickreplies(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.mediauploadrichquickreplies_ = value;
}
inline void WebFeatures::set_mediauploadrichquickreplies(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_mediauploadrichquickreplies(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.mediaUploadRichQuickReplies)
}

// optional .proto.WebFeatures.WebFeaturesFlag vnameV2 = 19;
inline bool WebFeatures::_internal_has_vnamev2() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool WebFeatures::has_vnamev2() const {
  return _internal_has_vnamev2();
}
inline void WebFeatures::clear_vnamev2() {
  _impl_.vnamev2_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_vnamev2() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.vnamev2_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::vnamev2() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.vnameV2)
  return _internal_vnamev2();
}
inline void WebFeatures::_internal_set_vnamev2(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.vnamev2_ = value;
}
inline void WebFeatures::set_vnamev2(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_vnamev2(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.vnameV2)
}

// optional .proto.WebFeatures.WebFeaturesFlag videoPlaybackUrl = 20;
inline bool WebFeatures::_internal_has_videoplaybackurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool WebFeatures::has_videoplaybackurl() const {
  return _internal_has_videoplaybackurl();
}
inline void WebFeatures::clear_videoplaybackurl() {
  _impl_.videoplaybackurl_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_videoplaybackurl() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.videoplaybackurl_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::videoplaybackurl() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.videoPlaybackUrl)
  return _internal_videoplaybackurl();
}
inline void WebFeatures::_internal_set_videoplaybackurl(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.videoplaybackurl_ = value;
}
inline void WebFeatures::set_videoplaybackurl(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_videoplaybackurl(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.videoPlaybackUrl)
}

// optional .proto.WebFeatures.WebFeaturesFlag statusRanking = 21;
inline bool WebFeatures::_internal_has_statusranking() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool WebFeatures::has_statusranking() const {
  return _internal_has_statusranking();
}
inline void WebFeatures::clear_statusranking() {
  _impl_.statusranking_ = 0;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_statusranking() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.statusranking_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::statusranking() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.statusRanking)
  return _internal_statusranking();
}
inline void WebFeatures::_internal_set_statusranking(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.statusranking_ = value;
}
inline void WebFeatures::set_statusranking(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_statusranking(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.statusRanking)
}

// optional .proto.WebFeatures.WebFeaturesFlag voipIndividualVideo = 22;
inline bool WebFeatures::_internal_has_voipindividualvideo() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool WebFeatures::has_voipindividualvideo() const {
  return _internal_has_voipindividualvideo();
}
inline void WebFeatures::clear_voipindividualvideo() {
  _impl_.voipindividualvideo_ = 0;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_voipindividualvideo() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.voipindividualvideo_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::voipindividualvideo() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.voipIndividualVideo)
  return _internal_voipindividualvideo();
}
inline void WebFeatures::_internal_set_voipindividualvideo(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.voipindividualvideo_ = value;
}
inline void WebFeatures::set_voipindividualvideo(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_voipindividualvideo(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.voipIndividualVideo)
}

// optional .proto.WebFeatures.WebFeaturesFlag thirdPartyStickers = 23;
inline bool WebFeatures::_internal_has_thirdpartystickers() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool WebFeatures::has_thirdpartystickers() const {
  return _internal_has_thirdpartystickers();
}
inline void WebFeatures::clear_thirdpartystickers() {
  _impl_.thirdpartystickers_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_thirdpartystickers() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.thirdpartystickers_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::thirdpartystickers() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.thirdPartyStickers)
  return _internal_thirdpartystickers();
}
inline void WebFeatures::_internal_set_thirdpartystickers(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.thirdpartystickers_ = value;
}
inline void WebFeatures::set_thirdpartystickers(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_thirdpartystickers(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.thirdPartyStickers)
}

// optional .proto.WebFeatures.WebFeaturesFlag frequentlyForwardedSetting = 24;
inline bool WebFeatures::_internal_has_frequentlyforwardedsetting() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool WebFeatures::has_frequentlyforwardedsetting() const {
  return _internal_has_frequentlyforwardedsetting();
}
inline void WebFeatures::clear_frequentlyforwardedsetting() {
  _impl_.frequentlyforwardedsetting_ = 0;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_frequentlyforwardedsetting() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.frequentlyforwardedsetting_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::frequentlyforwardedsetting() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.frequentlyForwardedSetting)
  return _internal_frequentlyforwardedsetting();
}
inline void WebFeatures::_internal_set_frequentlyforwardedsetting(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.frequentlyforwardedsetting_ = value;
}
inline void WebFeatures::set_frequentlyforwardedsetting(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_frequentlyforwardedsetting(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.frequentlyForwardedSetting)
}

// optional .proto.WebFeatures.WebFeaturesFlag groupsV4JoinPermission = 25;
inline bool WebFeatures::_internal_has_groupsv4joinpermission() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool WebFeatures::has_groupsv4joinpermission() const {
  return _internal_has_groupsv4joinpermission();
}
inline void WebFeatures::clear_groupsv4joinpermission() {
  _impl_.groupsv4joinpermission_ = 0;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_groupsv4joinpermission() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.groupsv4joinpermission_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::groupsv4joinpermission() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.groupsV4JoinPermission)
  return _internal_groupsv4joinpermission();
}
inline void WebFeatures::_internal_set_groupsv4joinpermission(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.groupsv4joinpermission_ = value;
}
inline void WebFeatures::set_groupsv4joinpermission(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_groupsv4joinpermission(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.groupsV4JoinPermission)
}

// optional .proto.WebFeatures.WebFeaturesFlag recentStickers = 26;
inline bool WebFeatures::_internal_has_recentstickers() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool WebFeatures::has_recentstickers() const {
  return _internal_has_recentstickers();
}
inline void WebFeatures::clear_recentstickers() {
  _impl_.recentstickers_ = 0;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_recentstickers() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.recentstickers_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::recentstickers() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.recentStickers)
  return _internal_recentstickers();
}
inline void WebFeatures::_internal_set_recentstickers(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.recentstickers_ = value;
}
inline void WebFeatures::set_recentstickers(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_recentstickers(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.recentStickers)
}

// optional .proto.WebFeatures.WebFeaturesFlag catalog = 27;
inline bool WebFeatures::_internal_has_catalog() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool WebFeatures::has_catalog() const {
  return _internal_has_catalog();
}
inline void WebFeatures::clear_catalog() {
  _impl_.catalog_ = 0;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_catalog() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.catalog_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::catalog() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.catalog)
  return _internal_catalog();
}
inline void WebFeatures::_internal_set_catalog(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.catalog_ = value;
}
inline void WebFeatures::set_catalog(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_catalog(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.catalog)
}

// optional .proto.WebFeatures.WebFeaturesFlag starredStickers = 28;
inline bool WebFeatures::_internal_has_starredstickers() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool WebFeatures::has_starredstickers() const {
  return _internal_has_starredstickers();
}
inline void WebFeatures::clear_starredstickers() {
  _impl_.starredstickers_ = 0;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_starredstickers() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.starredstickers_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::starredstickers() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.starredStickers)
  return _internal_starredstickers();
}
inline void WebFeatures::_internal_set_starredstickers(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.starredstickers_ = value;
}
inline void WebFeatures::set_starredstickers(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_starredstickers(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.starredStickers)
}

// optional .proto.WebFeatures.WebFeaturesFlag voipGroupCall = 29;
inline bool WebFeatures::_internal_has_voipgroupcall() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool WebFeatures::has_voipgroupcall() const {
  return _internal_has_voipgroupcall();
}
inline void WebFeatures::clear_voipgroupcall() {
  _impl_.voipgroupcall_ = 0;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_voipgroupcall() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.voipgroupcall_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::voipgroupcall() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.voipGroupCall)
  return _internal_voipgroupcall();
}
inline void WebFeatures::_internal_set_voipgroupcall(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.voipgroupcall_ = value;
}
inline void WebFeatures::set_voipgroupcall(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_voipgroupcall(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.voipGroupCall)
}

// optional .proto.WebFeatures.WebFeaturesFlag templateMessage = 30;
inline bool WebFeatures::_internal_has_templatemessage() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool WebFeatures::has_templatemessage() const {
  return _internal_has_templatemessage();
}
inline void WebFeatures::clear_templatemessage() {
  _impl_.templatemessage_ = 0;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_templatemessage() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.templatemessage_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::templatemessage() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.templateMessage)
  return _internal_templatemessage();
}
inline void WebFeatures::_internal_set_templatemessage(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.templatemessage_ = value;
}
inline void WebFeatures::set_templatemessage(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_templatemessage(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.templateMessage)
}

// optional .proto.WebFeatures.WebFeaturesFlag templateMessageInteractivity = 31;
inline bool WebFeatures::_internal_has_templatemessageinteractivity() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool WebFeatures::has_templatemessageinteractivity() const {
  return _internal_has_templatemessageinteractivity();
}
inline void WebFeatures::clear_templatemessageinteractivity() {
  _impl_.templatemessageinteractivity_ = 0;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_templatemessageinteractivity() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.templatemessageinteractivity_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::templatemessageinteractivity() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.templateMessageInteractivity)
  return _internal_templatemessageinteractivity();
}
inline void WebFeatures::_internal_set_templatemessageinteractivity(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.templatemessageinteractivity_ = value;
}
inline void WebFeatures::set_templatemessageinteractivity(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_templatemessageinteractivity(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.templateMessageInteractivity)
}

// optional .proto.WebFeatures.WebFeaturesFlag ephemeralMessages = 32;
inline bool WebFeatures::_internal_has_ephemeralmessages() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool WebFeatures::has_ephemeralmessages() const {
  return _internal_has_ephemeralmessages();
}
inline void WebFeatures::clear_ephemeralmessages() {
  _impl_.ephemeralmessages_ = 0;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_ephemeralmessages() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.ephemeralmessages_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::ephemeralmessages() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.ephemeralMessages)
  return _internal_ephemeralmessages();
}
inline void WebFeatures::_internal_set_ephemeralmessages(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.ephemeralmessages_ = value;
}
inline void WebFeatures::set_ephemeralmessages(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_ephemeralmessages(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.ephemeralMessages)
}

// optional .proto.WebFeatures.WebFeaturesFlag e2ENotificationSync = 33;
inline bool WebFeatures::_internal_has_e2enotificationsync() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool WebFeatures::has_e2enotificationsync() const {
  return _internal_has_e2enotificationsync();
}
inline void WebFeatures::clear_e2enotificationsync() {
  _impl_.e2enotificationsync_ = 0;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_e2enotificationsync() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.e2enotificationsync_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::e2enotificationsync() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.e2ENotificationSync)
  return _internal_e2enotificationsync();
}
inline void WebFeatures::_internal_set_e2enotificationsync(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.e2enotificationsync_ = value;
}
inline void WebFeatures::set_e2enotificationsync(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_e2enotificationsync(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.e2ENotificationSync)
}

// optional .proto.WebFeatures.WebFeaturesFlag recentStickersV2 = 34;
inline bool WebFeatures::_internal_has_recentstickersv2() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool WebFeatures::has_recentstickersv2() const {
  return _internal_has_recentstickersv2();
}
inline void WebFeatures::clear_recentstickersv2() {
  _impl_.recentstickersv2_ = 0;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_recentstickersv2() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.recentstickersv2_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::recentstickersv2() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.recentStickersV2)
  return _internal_recentstickersv2();
}
inline void WebFeatures::_internal_set_recentstickersv2(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.recentstickersv2_ = value;
}
inline void WebFeatures::set_recentstickersv2(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_recentstickersv2(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.recentStickersV2)
}

// optional .proto.WebFeatures.WebFeaturesFlag syncdRelease1 = 35;
inline bool WebFeatures::_internal_has_syncdrelease1() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool WebFeatures::has_syncdrelease1() const {
  return _internal_has_syncdrelease1();
}
inline void WebFeatures::clear_syncdrelease1() {
  _impl_.syncdrelease1_ = 0;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_syncdrelease1() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.syncdrelease1_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::syncdrelease1() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.syncdRelease1)
  return _internal_syncdrelease1();
}
inline void WebFeatures::_internal_set_syncdrelease1(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.syncdrelease1_ = value;
}
inline void WebFeatures::set_syncdrelease1(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_syncdrelease1(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.syncdRelease1)
}

// optional .proto.WebFeatures.WebFeaturesFlag recentStickersV3 = 36;
inline bool WebFeatures::_internal_has_recentstickersv3() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool WebFeatures::has_recentstickersv3() const {
  return _internal_has_recentstickersv3();
}
inline void WebFeatures::clear_recentstickersv3() {
  _impl_.recentstickersv3_ = 0;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_recentstickersv3() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.recentstickersv3_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::recentstickersv3() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.recentStickersV3)
  return _internal_recentstickersv3();
}
inline void WebFeatures::_internal_set_recentstickersv3(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.recentstickersv3_ = value;
}
inline void WebFeatures::set_recentstickersv3(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_recentstickersv3(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.recentStickersV3)
}

// optional .proto.WebFeatures.WebFeaturesFlag userNotice = 37;
inline bool WebFeatures::_internal_has_usernotice() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool WebFeatures::has_usernotice() const {
  return _internal_has_usernotice();
}
inline void WebFeatures::clear_usernotice() {
  _impl_.usernotice_ = 0;
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_usernotice() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.usernotice_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::usernotice() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.userNotice)
  return _internal_usernotice();
}
inline void WebFeatures::_internal_set_usernotice(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.usernotice_ = value;
}
inline void WebFeatures::set_usernotice(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_usernotice(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.userNotice)
}

// optional .proto.WebFeatures.WebFeaturesFlag syncdRelease11 = 38;
inline bool WebFeatures::_internal_has_syncdrelease11() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool WebFeatures::has_syncdrelease11() const {
  return _internal_has_syncdrelease11();
}
inline void WebFeatures::clear_syncdrelease11() {
  _impl_.syncdrelease11_ = 0;
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_syncdrelease11() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.syncdrelease11_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::syncdrelease11() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.syncdRelease11)
  return _internal_syncdrelease11();
}
inline void WebFeatures::_internal_set_syncdrelease11(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.syncdrelease11_ = value;
}
inline void WebFeatures::set_syncdrelease11(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_syncdrelease11(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.syncdRelease11)
}

// optional .proto.WebFeatures.WebFeaturesFlag support = 39;
inline bool WebFeatures::_internal_has_support() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool WebFeatures::has_support() const {
  return _internal_has_support();
}
inline void WebFeatures::clear_support() {
  _impl_.support_ = 0;
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_support() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.support_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::support() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.support)
  return _internal_support();
}
inline void WebFeatures::_internal_set_support(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.support_ = value;
}
inline void WebFeatures::set_support(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_support(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.support)
}

// optional .proto.WebFeatures.WebFeaturesFlag groupUiiCleanup = 40;
inline bool WebFeatures::_internal_has_groupuiicleanup() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool WebFeatures::has_groupuiicleanup() const {
  return _internal_has_groupuiicleanup();
}
inline void WebFeatures::clear_groupuiicleanup() {
  _impl_.groupuiicleanup_ = 0;
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_groupuiicleanup() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.groupuiicleanup_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::groupuiicleanup() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.groupUiiCleanup)
  return _internal_groupuiicleanup();
}
inline void WebFeatures::_internal_set_groupuiicleanup(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.groupuiicleanup_ = value;
}
inline void WebFeatures::set_groupuiicleanup(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_groupuiicleanup(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.groupUiiCleanup)
}

// optional .proto.WebFeatures.WebFeaturesFlag groupDogfoodingInternalOnly = 41;
inline bool WebFeatures::_internal_has_groupdogfoodinginternalonly() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool WebFeatures::has_groupdogfoodinginternalonly() const {
  return _internal_has_groupdogfoodinginternalonly();
}
inline void WebFeatures::clear_groupdogfoodinginternalonly() {
  _impl_.groupdogfoodinginternalonly_ = 0;
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_groupdogfoodinginternalonly() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.groupdogfoodinginternalonly_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::groupdogfoodinginternalonly() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.groupDogfoodingInternalOnly)
  return _internal_groupdogfoodinginternalonly();
}
inline void WebFeatures::_internal_set_groupdogfoodinginternalonly(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.groupdogfoodinginternalonly_ = value;
}
inline void WebFeatures::set_groupdogfoodinginternalonly(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_groupdogfoodinginternalonly(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.groupDogfoodingInternalOnly)
}

// optional .proto.WebFeatures.WebFeaturesFlag settingsSync = 42;
inline bool WebFeatures::_internal_has_settingssync() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool WebFeatures::has_settingssync() const {
  return _internal_has_settingssync();
}
inline void WebFeatures::clear_settingssync() {
  _impl_.settingssync_ = 0;
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::_internal_settingssync() const {
  return static_cast< ::proto::WebFeatures_WebFeaturesFlag >(_impl_.settingssync_);
}
inline ::proto::WebFeatures_WebFeaturesFlag WebFeatures::settingssync() const {
  // @@protoc_insertion_point(field_get:proto.WebFeatures.settingsSync)
  return _internal_settingssync();
}
inline void WebFeatures::_internal_set_settingssync(::proto::WebFeatures_WebFeaturesFlag value) {
  assert(::proto::WebFeatures_WebFeaturesFlag_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.settingssync_ = value;
}
inline void WebFeatures::set_settingssync(::proto::WebFeatures_WebFeaturesFlag value) {
  _internal_set_settingssync(value);
  // @@protoc_insertion_point(field_set:proto.WebFeatures.settingsSync)
}

// -------------------------------------------------------------------

// NotificationMessageInfo

// optional .proto.MessageKey key = 1;
inline bool NotificationMessageInfo::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline bool NotificationMessageInfo::has_key() const {
  return _internal_has_key();
}
inline void NotificationMessageInfo::clear_key() {
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::MessageKey& NotificationMessageInfo::_internal_key() const {
  const ::proto::MessageKey* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::MessageKey&>(
      ::proto::_MessageKey_default_instance_);
}
inline const ::proto::MessageKey& NotificationMessageInfo::key() const {
  // @@protoc_insertion_point(field_get:proto.NotificationMessageInfo.key)
  return _internal_key();
}
inline void NotificationMessageInfo::unsafe_arena_set_allocated_key(
    ::proto::MessageKey* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.NotificationMessageInfo.key)
}
inline ::proto::MessageKey* NotificationMessageInfo::release_key() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::MessageKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::MessageKey* NotificationMessageInfo::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:proto.NotificationMessageInfo.key)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::proto::MessageKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::proto::MessageKey* NotificationMessageInfo::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::MessageKey>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::proto::MessageKey* NotificationMessageInfo::mutable_key() {
  ::proto::MessageKey* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:proto.NotificationMessageInfo.key)
  return _msg;
}
inline void NotificationMessageInfo::set_allocated_key(::proto::MessageKey* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:proto.NotificationMessageInfo.key)
}

// optional .proto.Message message = 2;
inline bool NotificationMessageInfo::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.message_ != nullptr);
  return value;
}
inline bool NotificationMessageInfo::has_message() const {
  return _internal_has_message();
}
inline void NotificationMessageInfo::clear_message() {
  if (_impl_.message_ != nullptr) _impl_.message_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::proto::Message& NotificationMessageInfo::_internal_message() const {
  const ::proto::Message* p = _impl_.message_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Message&>(
      ::proto::_Message_default_instance_);
}
inline const ::proto::Message& NotificationMessageInfo::message() const {
  // @@protoc_insertion_point(field_get:proto.NotificationMessageInfo.message)
  return _internal_message();
}
inline void NotificationMessageInfo::unsafe_arena_set_allocated_message(
    ::proto::Message* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.message_);
  }
  _impl_.message_ = message;
  if (message) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.NotificationMessageInfo.message)
}
inline ::proto::Message* NotificationMessageInfo::release_message() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Message* NotificationMessageInfo::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:proto.NotificationMessageInfo.message)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
  return temp;
}
inline ::proto::Message* NotificationMessageInfo::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.message_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Message>(GetArenaForAllocation());
    _impl_.message_ = p;
  }
  return _impl_.message_;
}
inline ::proto::Message* NotificationMessageInfo::mutable_message() {
  ::proto::Message* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:proto.NotificationMessageInfo.message)
  return _msg;
}
inline void NotificationMessageInfo::set_allocated_message(::proto::Message* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.message_ = message;
  // @@protoc_insertion_point(field_set_allocated:proto.NotificationMessageInfo.message)
}

// optional uint64 messageTimestamp = 3;
inline bool NotificationMessageInfo::_internal_has_messagetimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NotificationMessageInfo::has_messagetimestamp() const {
  return _internal_has_messagetimestamp();
}
inline void NotificationMessageInfo::clear_messagetimestamp() {
  _impl_.messagetimestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t NotificationMessageInfo::_internal_messagetimestamp() const {
  return _impl_.messagetimestamp_;
}
inline uint64_t NotificationMessageInfo::messagetimestamp() const {
  // @@protoc_insertion_point(field_get:proto.NotificationMessageInfo.messageTimestamp)
  return _internal_messagetimestamp();
}
inline void NotificationMessageInfo::_internal_set_messagetimestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.messagetimestamp_ = value;
}
inline void NotificationMessageInfo::set_messagetimestamp(uint64_t value) {
  _internal_set_messagetimestamp(value);
  // @@protoc_insertion_point(field_set:proto.NotificationMessageInfo.messageTimestamp)
}

// optional string participant = 4;
inline bool NotificationMessageInfo::_internal_has_participant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NotificationMessageInfo::has_participant() const {
  return _internal_has_participant();
}
inline void NotificationMessageInfo::clear_participant() {
  _impl_.participant_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NotificationMessageInfo::participant() const {
  // @@protoc_insertion_point(field_get:proto.NotificationMessageInfo.participant)
  return _internal_participant();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NotificationMessageInfo::set_participant(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.NotificationMessageInfo.participant)
}
inline std::string* NotificationMessageInfo::mutable_participant() {
  std::string* _s = _internal_mutable_participant();
  // @@protoc_insertion_point(field_mutable:proto.NotificationMessageInfo.participant)
  return _s;
}
inline const std::string& NotificationMessageInfo::_internal_participant() const {
  return _impl_.participant_.Get();
}
inline void NotificationMessageInfo::_internal_set_participant(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_.Set(value, GetArenaForAllocation());
}
inline std::string* NotificationMessageInfo::_internal_mutable_participant() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_.Mutable(GetArenaForAllocation());
}
inline std::string* NotificationMessageInfo::release_participant() {
  // @@protoc_insertion_point(field_release:proto.NotificationMessageInfo.participant)
  if (!_internal_has_participant()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_.IsDefault()) {
    _impl_.participant_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NotificationMessageInfo::set_allocated_participant(std::string* participant) {
  if (participant != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_.SetAllocated(participant, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_.IsDefault()) {
    _impl_.participant_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.NotificationMessageInfo.participant)
}

// -------------------------------------------------------------------

// WebNotificationsInfo

// optional uint64 timestamp = 2;
inline bool WebNotificationsInfo::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WebNotificationsInfo::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void WebNotificationsInfo::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t WebNotificationsInfo::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t WebNotificationsInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.WebNotificationsInfo.timestamp)
  return _internal_timestamp();
}
inline void WebNotificationsInfo::_internal_set_timestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ = value;
}
inline void WebNotificationsInfo::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:proto.WebNotificationsInfo.timestamp)
}

// optional uint32 unreadChats = 3;
inline bool WebNotificationsInfo::_internal_has_unreadchats() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WebNotificationsInfo::has_unreadchats() const {
  return _internal_has_unreadchats();
}
inline void WebNotificationsInfo::clear_unreadchats() {
  _impl_.unreadchats_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t WebNotificationsInfo::_internal_unreadchats() const {
  return _impl_.unreadchats_;
}
inline uint32_t WebNotificationsInfo::unreadchats() const {
  // @@protoc_insertion_point(field_get:proto.WebNotificationsInfo.unreadChats)
  return _internal_unreadchats();
}
inline void WebNotificationsInfo::_internal_set_unreadchats(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.unreadchats_ = value;
}
inline void WebNotificationsInfo::set_unreadchats(uint32_t value) {
  _internal_set_unreadchats(value);
  // @@protoc_insertion_point(field_set:proto.WebNotificationsInfo.unreadChats)
}

// optional uint32 notifyMessageCount = 4;
inline bool WebNotificationsInfo::_internal_has_notifymessagecount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WebNotificationsInfo::has_notifymessagecount() const {
  return _internal_has_notifymessagecount();
}
inline void WebNotificationsInfo::clear_notifymessagecount() {
  _impl_.notifymessagecount_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t WebNotificationsInfo::_internal_notifymessagecount() const {
  return _impl_.notifymessagecount_;
}
inline uint32_t WebNotificationsInfo::notifymessagecount() const {
  // @@protoc_insertion_point(field_get:proto.WebNotificationsInfo.notifyMessageCount)
  return _internal_notifymessagecount();
}
inline void WebNotificationsInfo::_internal_set_notifymessagecount(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.notifymessagecount_ = value;
}
inline void WebNotificationsInfo::set_notifymessagecount(uint32_t value) {
  _internal_set_notifymessagecount(value);
  // @@protoc_insertion_point(field_set:proto.WebNotificationsInfo.notifyMessageCount)
}

// repeated .proto.WebMessageInfo notifyMessages = 5;
inline int WebNotificationsInfo::_internal_notifymessages_size() const {
  return _impl_.notifymessages_.size();
}
inline int WebNotificationsInfo::notifymessages_size() const {
  return _internal_notifymessages_size();
}
inline void WebNotificationsInfo::clear_notifymessages() {
  _impl_.notifymessages_.Clear();
}
inline ::proto::WebMessageInfo* WebNotificationsInfo::mutable_notifymessages(int index) {
  // @@protoc_insertion_point(field_mutable:proto.WebNotificationsInfo.notifyMessages)
  return _impl_.notifymessages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::WebMessageInfo >*
WebNotificationsInfo::mutable_notifymessages() {
  // @@protoc_insertion_point(field_mutable_list:proto.WebNotificationsInfo.notifyMessages)
  return &_impl_.notifymessages_;
}
inline const ::proto::WebMessageInfo& WebNotificationsInfo::_internal_notifymessages(int index) const {
  return _impl_.notifymessages_.Get(index);
}
inline const ::proto::WebMessageInfo& WebNotificationsInfo::notifymessages(int index) const {
  // @@protoc_insertion_point(field_get:proto.WebNotificationsInfo.notifyMessages)
  return _internal_notifymessages(index);
}
inline ::proto::WebMessageInfo* WebNotificationsInfo::_internal_add_notifymessages() {
  return _impl_.notifymessages_.Add();
}
inline ::proto::WebMessageInfo* WebNotificationsInfo::add_notifymessages() {
  ::proto::WebMessageInfo* _add = _internal_add_notifymessages();
  // @@protoc_insertion_point(field_add:proto.WebNotificationsInfo.notifyMessages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::WebMessageInfo >&
WebNotificationsInfo::notifymessages() const {
  // @@protoc_insertion_point(field_list:proto.WebNotificationsInfo.notifyMessages)
  return _impl_.notifymessages_;
}

// -------------------------------------------------------------------

// PaymentInfo

// optional .proto.PaymentInfo.PaymentInfoCurrency currencyDeprecated = 1;
inline bool PaymentInfo::_internal_has_currencydeprecated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PaymentInfo::has_currencydeprecated() const {
  return _internal_has_currencydeprecated();
}
inline void PaymentInfo::clear_currencydeprecated() {
  _impl_.currencydeprecated_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::proto::PaymentInfo_PaymentInfoCurrency PaymentInfo::_internal_currencydeprecated() const {
  return static_cast< ::proto::PaymentInfo_PaymentInfoCurrency >(_impl_.currencydeprecated_);
}
inline ::proto::PaymentInfo_PaymentInfoCurrency PaymentInfo::currencydeprecated() const {
  // @@protoc_insertion_point(field_get:proto.PaymentInfo.currencyDeprecated)
  return _internal_currencydeprecated();
}
inline void PaymentInfo::_internal_set_currencydeprecated(::proto::PaymentInfo_PaymentInfoCurrency value) {
  assert(::proto::PaymentInfo_PaymentInfoCurrency_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.currencydeprecated_ = value;
}
inline void PaymentInfo::set_currencydeprecated(::proto::PaymentInfo_PaymentInfoCurrency value) {
  _internal_set_currencydeprecated(value);
  // @@protoc_insertion_point(field_set:proto.PaymentInfo.currencyDeprecated)
}

// optional uint64 amount1000 = 2;
inline bool PaymentInfo::_internal_has_amount1000() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PaymentInfo::has_amount1000() const {
  return _internal_has_amount1000();
}
inline void PaymentInfo::clear_amount1000() {
  _impl_.amount1000_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t PaymentInfo::_internal_amount1000() const {
  return _impl_.amount1000_;
}
inline uint64_t PaymentInfo::amount1000() const {
  // @@protoc_insertion_point(field_get:proto.PaymentInfo.amount1000)
  return _internal_amount1000();
}
inline void PaymentInfo::_internal_set_amount1000(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.amount1000_ = value;
}
inline void PaymentInfo::set_amount1000(uint64_t value) {
  _internal_set_amount1000(value);
  // @@protoc_insertion_point(field_set:proto.PaymentInfo.amount1000)
}

// optional string receiverJid = 3;
inline bool PaymentInfo::_internal_has_receiverjid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PaymentInfo::has_receiverjid() const {
  return _internal_has_receiverjid();
}
inline void PaymentInfo::clear_receiverjid() {
  _impl_.receiverjid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PaymentInfo::receiverjid() const {
  // @@protoc_insertion_point(field_get:proto.PaymentInfo.receiverJid)
  return _internal_receiverjid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentInfo::set_receiverjid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.receiverjid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.PaymentInfo.receiverJid)
}
inline std::string* PaymentInfo::mutable_receiverjid() {
  std::string* _s = _internal_mutable_receiverjid();
  // @@protoc_insertion_point(field_mutable:proto.PaymentInfo.receiverJid)
  return _s;
}
inline const std::string& PaymentInfo::_internal_receiverjid() const {
  return _impl_.receiverjid_.Get();
}
inline void PaymentInfo::_internal_set_receiverjid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.receiverjid_.Set(value, GetArenaForAllocation());
}
inline std::string* PaymentInfo::_internal_mutable_receiverjid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.receiverjid_.Mutable(GetArenaForAllocation());
}
inline std::string* PaymentInfo::release_receiverjid() {
  // @@protoc_insertion_point(field_release:proto.PaymentInfo.receiverJid)
  if (!_internal_has_receiverjid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.receiverjid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.receiverjid_.IsDefault()) {
    _impl_.receiverjid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaymentInfo::set_allocated_receiverjid(std::string* receiverjid) {
  if (receiverjid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.receiverjid_.SetAllocated(receiverjid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.receiverjid_.IsDefault()) {
    _impl_.receiverjid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.PaymentInfo.receiverJid)
}

// optional .proto.PaymentInfo.PaymentInfoStatus status = 4;
inline bool PaymentInfo::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PaymentInfo::has_status() const {
  return _internal_has_status();
}
inline void PaymentInfo::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::proto::PaymentInfo_PaymentInfoStatus PaymentInfo::_internal_status() const {
  return static_cast< ::proto::PaymentInfo_PaymentInfoStatus >(_impl_.status_);
}
inline ::proto::PaymentInfo_PaymentInfoStatus PaymentInfo::status() const {
  // @@protoc_insertion_point(field_get:proto.PaymentInfo.status)
  return _internal_status();
}
inline void PaymentInfo::_internal_set_status(::proto::PaymentInfo_PaymentInfoStatus value) {
  assert(::proto::PaymentInfo_PaymentInfoStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.status_ = value;
}
inline void PaymentInfo::set_status(::proto::PaymentInfo_PaymentInfoStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:proto.PaymentInfo.status)
}

// optional uint64 transactionTimestamp = 5;
inline bool PaymentInfo::_internal_has_transactiontimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PaymentInfo::has_transactiontimestamp() const {
  return _internal_has_transactiontimestamp();
}
inline void PaymentInfo::clear_transactiontimestamp() {
  _impl_.transactiontimestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint64_t PaymentInfo::_internal_transactiontimestamp() const {
  return _impl_.transactiontimestamp_;
}
inline uint64_t PaymentInfo::transactiontimestamp() const {
  // @@protoc_insertion_point(field_get:proto.PaymentInfo.transactionTimestamp)
  return _internal_transactiontimestamp();
}
inline void PaymentInfo::_internal_set_transactiontimestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.transactiontimestamp_ = value;
}
inline void PaymentInfo::set_transactiontimestamp(uint64_t value) {
  _internal_set_transactiontimestamp(value);
  // @@protoc_insertion_point(field_set:proto.PaymentInfo.transactionTimestamp)
}

// optional .proto.MessageKey requestMessageKey = 6;
inline bool PaymentInfo::_internal_has_requestmessagekey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.requestmessagekey_ != nullptr);
  return value;
}
inline bool PaymentInfo::has_requestmessagekey() const {
  return _internal_has_requestmessagekey();
}
inline void PaymentInfo::clear_requestmessagekey() {
  if (_impl_.requestmessagekey_ != nullptr) _impl_.requestmessagekey_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::proto::MessageKey& PaymentInfo::_internal_requestmessagekey() const {
  const ::proto::MessageKey* p = _impl_.requestmessagekey_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::MessageKey&>(
      ::proto::_MessageKey_default_instance_);
}
inline const ::proto::MessageKey& PaymentInfo::requestmessagekey() const {
  // @@protoc_insertion_point(field_get:proto.PaymentInfo.requestMessageKey)
  return _internal_requestmessagekey();
}
inline void PaymentInfo::unsafe_arena_set_allocated_requestmessagekey(
    ::proto::MessageKey* requestmessagekey) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requestmessagekey_);
  }
  _impl_.requestmessagekey_ = requestmessagekey;
  if (requestmessagekey) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.PaymentInfo.requestMessageKey)
}
inline ::proto::MessageKey* PaymentInfo::release_requestmessagekey() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::MessageKey* temp = _impl_.requestmessagekey_;
  _impl_.requestmessagekey_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::MessageKey* PaymentInfo::unsafe_arena_release_requestmessagekey() {
  // @@protoc_insertion_point(field_release:proto.PaymentInfo.requestMessageKey)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::proto::MessageKey* temp = _impl_.requestmessagekey_;
  _impl_.requestmessagekey_ = nullptr;
  return temp;
}
inline ::proto::MessageKey* PaymentInfo::_internal_mutable_requestmessagekey() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.requestmessagekey_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::MessageKey>(GetArenaForAllocation());
    _impl_.requestmessagekey_ = p;
  }
  return _impl_.requestmessagekey_;
}
inline ::proto::MessageKey* PaymentInfo::mutable_requestmessagekey() {
  ::proto::MessageKey* _msg = _internal_mutable_requestmessagekey();
  // @@protoc_insertion_point(field_mutable:proto.PaymentInfo.requestMessageKey)
  return _msg;
}
inline void PaymentInfo::set_allocated_requestmessagekey(::proto::MessageKey* requestmessagekey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.requestmessagekey_;
  }
  if (requestmessagekey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(requestmessagekey);
    if (message_arena != submessage_arena) {
      requestmessagekey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, requestmessagekey, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.requestmessagekey_ = requestmessagekey;
  // @@protoc_insertion_point(field_set_allocated:proto.PaymentInfo.requestMessageKey)
}

// optional uint64 expiryTimestamp = 7;
inline bool PaymentInfo::_internal_has_expirytimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool PaymentInfo::has_expirytimestamp() const {
  return _internal_has_expirytimestamp();
}
inline void PaymentInfo::clear_expirytimestamp() {
  _impl_.expirytimestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint64_t PaymentInfo::_internal_expirytimestamp() const {
  return _impl_.expirytimestamp_;
}
inline uint64_t PaymentInfo::expirytimestamp() const {
  // @@protoc_insertion_point(field_get:proto.PaymentInfo.expiryTimestamp)
  return _internal_expirytimestamp();
}
inline void PaymentInfo::_internal_set_expirytimestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.expirytimestamp_ = value;
}
inline void PaymentInfo::set_expirytimestamp(uint64_t value) {
  _internal_set_expirytimestamp(value);
  // @@protoc_insertion_point(field_set:proto.PaymentInfo.expiryTimestamp)
}

// optional bool futureproofed = 8;
inline bool PaymentInfo::_internal_has_futureproofed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool PaymentInfo::has_futureproofed() const {
  return _internal_has_futureproofed();
}
inline void PaymentInfo::clear_futureproofed() {
  _impl_.futureproofed_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool PaymentInfo::_internal_futureproofed() const {
  return _impl_.futureproofed_;
}
inline bool PaymentInfo::futureproofed() const {
  // @@protoc_insertion_point(field_get:proto.PaymentInfo.futureproofed)
  return _internal_futureproofed();
}
inline void PaymentInfo::_internal_set_futureproofed(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.futureproofed_ = value;
}
inline void PaymentInfo::set_futureproofed(bool value) {
  _internal_set_futureproofed(value);
  // @@protoc_insertion_point(field_set:proto.PaymentInfo.futureproofed)
}

// optional string currency = 9;
inline bool PaymentInfo::_internal_has_currency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PaymentInfo::has_currency() const {
  return _internal_has_currency();
}
inline void PaymentInfo::clear_currency() {
  _impl_.currency_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PaymentInfo::currency() const {
  // @@protoc_insertion_point(field_get:proto.PaymentInfo.currency)
  return _internal_currency();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentInfo::set_currency(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.currency_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.PaymentInfo.currency)
}
inline std::string* PaymentInfo::mutable_currency() {
  std::string* _s = _internal_mutable_currency();
  // @@protoc_insertion_point(field_mutable:proto.PaymentInfo.currency)
  return _s;
}
inline const std::string& PaymentInfo::_internal_currency() const {
  return _impl_.currency_.Get();
}
inline void PaymentInfo::_internal_set_currency(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.currency_.Set(value, GetArenaForAllocation());
}
inline std::string* PaymentInfo::_internal_mutable_currency() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.currency_.Mutable(GetArenaForAllocation());
}
inline std::string* PaymentInfo::release_currency() {
  // @@protoc_insertion_point(field_release:proto.PaymentInfo.currency)
  if (!_internal_has_currency()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.currency_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currency_.IsDefault()) {
    _impl_.currency_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaymentInfo::set_allocated_currency(std::string* currency) {
  if (currency != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.currency_.SetAllocated(currency, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currency_.IsDefault()) {
    _impl_.currency_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.PaymentInfo.currency)
}

// optional .proto.PaymentInfo.PaymentInfoTxnStatus txnStatus = 10;
inline bool PaymentInfo::_internal_has_txnstatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool PaymentInfo::has_txnstatus() const {
  return _internal_has_txnstatus();
}
inline void PaymentInfo::clear_txnstatus() {
  _impl_.txnstatus_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::proto::PaymentInfo_PaymentInfoTxnStatus PaymentInfo::_internal_txnstatus() const {
  return static_cast< ::proto::PaymentInfo_PaymentInfoTxnStatus >(_impl_.txnstatus_);
}
inline ::proto::PaymentInfo_PaymentInfoTxnStatus PaymentInfo::txnstatus() const {
  // @@protoc_insertion_point(field_get:proto.PaymentInfo.txnStatus)
  return _internal_txnstatus();
}
inline void PaymentInfo::_internal_set_txnstatus(::proto::PaymentInfo_PaymentInfoTxnStatus value) {
  assert(::proto::PaymentInfo_PaymentInfoTxnStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.txnstatus_ = value;
}
inline void PaymentInfo::set_txnstatus(::proto::PaymentInfo_PaymentInfoTxnStatus value) {
  _internal_set_txnstatus(value);
  // @@protoc_insertion_point(field_set:proto.PaymentInfo.txnStatus)
}

// optional bool useNoviFiatFormat = 11;
inline bool PaymentInfo::_internal_has_usenovifiatformat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool PaymentInfo::has_usenovifiatformat() const {
  return _internal_has_usenovifiatformat();
}
inline void PaymentInfo::clear_usenovifiatformat() {
  _impl_.usenovifiatformat_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool PaymentInfo::_internal_usenovifiatformat() const {
  return _impl_.usenovifiatformat_;
}
inline bool PaymentInfo::usenovifiatformat() const {
  // @@protoc_insertion_point(field_get:proto.PaymentInfo.useNoviFiatFormat)
  return _internal_usenovifiatformat();
}
inline void PaymentInfo::_internal_set_usenovifiatformat(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.usenovifiatformat_ = value;
}
inline void PaymentInfo::set_usenovifiatformat(bool value) {
  _internal_set_usenovifiatformat(value);
  // @@protoc_insertion_point(field_set:proto.PaymentInfo.useNoviFiatFormat)
}

// optional .proto.PaymentMoney primaryAmount = 12;
inline bool PaymentInfo::_internal_has_primaryamount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.primaryamount_ != nullptr);
  return value;
}
inline bool PaymentInfo::has_primaryamount() const {
  return _internal_has_primaryamount();
}
inline void PaymentInfo::clear_primaryamount() {
  if (_impl_.primaryamount_ != nullptr) _impl_.primaryamount_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::proto::PaymentMoney& PaymentInfo::_internal_primaryamount() const {
  const ::proto::PaymentMoney* p = _impl_.primaryamount_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::PaymentMoney&>(
      ::proto::_PaymentMoney_default_instance_);
}
inline const ::proto::PaymentMoney& PaymentInfo::primaryamount() const {
  // @@protoc_insertion_point(field_get:proto.PaymentInfo.primaryAmount)
  return _internal_primaryamount();
}
inline void PaymentInfo::unsafe_arena_set_allocated_primaryamount(
    ::proto::PaymentMoney* primaryamount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.primaryamount_);
  }
  _impl_.primaryamount_ = primaryamount;
  if (primaryamount) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.PaymentInfo.primaryAmount)
}
inline ::proto::PaymentMoney* PaymentInfo::release_primaryamount() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::proto::PaymentMoney* temp = _impl_.primaryamount_;
  _impl_.primaryamount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::PaymentMoney* PaymentInfo::unsafe_arena_release_primaryamount() {
  // @@protoc_insertion_point(field_release:proto.PaymentInfo.primaryAmount)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::proto::PaymentMoney* temp = _impl_.primaryamount_;
  _impl_.primaryamount_ = nullptr;
  return temp;
}
inline ::proto::PaymentMoney* PaymentInfo::_internal_mutable_primaryamount() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.primaryamount_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::PaymentMoney>(GetArenaForAllocation());
    _impl_.primaryamount_ = p;
  }
  return _impl_.primaryamount_;
}
inline ::proto::PaymentMoney* PaymentInfo::mutable_primaryamount() {
  ::proto::PaymentMoney* _msg = _internal_mutable_primaryamount();
  // @@protoc_insertion_point(field_mutable:proto.PaymentInfo.primaryAmount)
  return _msg;
}
inline void PaymentInfo::set_allocated_primaryamount(::proto::PaymentMoney* primaryamount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.primaryamount_;
  }
  if (primaryamount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(primaryamount);
    if (message_arena != submessage_arena) {
      primaryamount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, primaryamount, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.primaryamount_ = primaryamount;
  // @@protoc_insertion_point(field_set_allocated:proto.PaymentInfo.primaryAmount)
}

// optional .proto.PaymentMoney exchangeAmount = 13;
inline bool PaymentInfo::_internal_has_exchangeamount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.exchangeamount_ != nullptr);
  return value;
}
inline bool PaymentInfo::has_exchangeamount() const {
  return _internal_has_exchangeamount();
}
inline void PaymentInfo::clear_exchangeamount() {
  if (_impl_.exchangeamount_ != nullptr) _impl_.exchangeamount_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::proto::PaymentMoney& PaymentInfo::_internal_exchangeamount() const {
  const ::proto::PaymentMoney* p = _impl_.exchangeamount_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::PaymentMoney&>(
      ::proto::_PaymentMoney_default_instance_);
}
inline const ::proto::PaymentMoney& PaymentInfo::exchangeamount() const {
  // @@protoc_insertion_point(field_get:proto.PaymentInfo.exchangeAmount)
  return _internal_exchangeamount();
}
inline void PaymentInfo::unsafe_arena_set_allocated_exchangeamount(
    ::proto::PaymentMoney* exchangeamount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.exchangeamount_);
  }
  _impl_.exchangeamount_ = exchangeamount;
  if (exchangeamount) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.PaymentInfo.exchangeAmount)
}
inline ::proto::PaymentMoney* PaymentInfo::release_exchangeamount() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::proto::PaymentMoney* temp = _impl_.exchangeamount_;
  _impl_.exchangeamount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::PaymentMoney* PaymentInfo::unsafe_arena_release_exchangeamount() {
  // @@protoc_insertion_point(field_release:proto.PaymentInfo.exchangeAmount)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::proto::PaymentMoney* temp = _impl_.exchangeamount_;
  _impl_.exchangeamount_ = nullptr;
  return temp;
}
inline ::proto::PaymentMoney* PaymentInfo::_internal_mutable_exchangeamount() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.exchangeamount_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::PaymentMoney>(GetArenaForAllocation());
    _impl_.exchangeamount_ = p;
  }
  return _impl_.exchangeamount_;
}
inline ::proto::PaymentMoney* PaymentInfo::mutable_exchangeamount() {
  ::proto::PaymentMoney* _msg = _internal_mutable_exchangeamount();
  // @@protoc_insertion_point(field_mutable:proto.PaymentInfo.exchangeAmount)
  return _msg;
}
inline void PaymentInfo::set_allocated_exchangeamount(::proto::PaymentMoney* exchangeamount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.exchangeamount_;
  }
  if (exchangeamount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(exchangeamount);
    if (message_arena != submessage_arena) {
      exchangeamount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exchangeamount, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.exchangeamount_ = exchangeamount;
  // @@protoc_insertion_point(field_set_allocated:proto.PaymentInfo.exchangeAmount)
}

// -------------------------------------------------------------------

// WebMessageInfo

// required .proto.MessageKey key = 1;
inline bool WebMessageInfo::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline bool WebMessageInfo::has_key() const {
  return _internal_has_key();
}
inline void WebMessageInfo::clear_key() {
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::proto::MessageKey& WebMessageInfo::_internal_key() const {
  const ::proto::MessageKey* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::MessageKey&>(
      ::proto::_MessageKey_default_instance_);
}
inline const ::proto::MessageKey& WebMessageInfo::key() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.key)
  return _internal_key();
}
inline void WebMessageInfo::unsafe_arena_set_allocated_key(
    ::proto::MessageKey* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.WebMessageInfo.key)
}
inline ::proto::MessageKey* WebMessageInfo::release_key() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::proto::MessageKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::MessageKey* WebMessageInfo::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:proto.WebMessageInfo.key)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::proto::MessageKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::proto::MessageKey* WebMessageInfo::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::MessageKey>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::proto::MessageKey* WebMessageInfo::mutable_key() {
  ::proto::MessageKey* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:proto.WebMessageInfo.key)
  return _msg;
}
inline void WebMessageInfo::set_allocated_key(::proto::MessageKey* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:proto.WebMessageInfo.key)
}

// optional .proto.Message message = 2;
inline bool WebMessageInfo::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.message_ != nullptr);
  return value;
}
inline bool WebMessageInfo::has_message() const {
  return _internal_has_message();
}
inline void WebMessageInfo::clear_message() {
  if (_impl_.message_ != nullptr) _impl_.message_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::proto::Message& WebMessageInfo::_internal_message() const {
  const ::proto::Message* p = _impl_.message_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Message&>(
      ::proto::_Message_default_instance_);
}
inline const ::proto::Message& WebMessageInfo::message() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.message)
  return _internal_message();
}
inline void WebMessageInfo::unsafe_arena_set_allocated_message(
    ::proto::Message* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.message_);
  }
  _impl_.message_ = message;
  if (message) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.WebMessageInfo.message)
}
inline ::proto::Message* WebMessageInfo::release_message() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::proto::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Message* WebMessageInfo::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:proto.WebMessageInfo.message)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::proto::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
  return temp;
}
inline ::proto::Message* WebMessageInfo::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.message_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Message>(GetArenaForAllocation());
    _impl_.message_ = p;
  }
  return _impl_.message_;
}
inline ::proto::Message* WebMessageInfo::mutable_message() {
  ::proto::Message* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:proto.WebMessageInfo.message)
  return _msg;
}
inline void WebMessageInfo::set_allocated_message(::proto::Message* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.message_ = message;
  // @@protoc_insertion_point(field_set_allocated:proto.WebMessageInfo.message)
}

// optional uint64 messageTimestamp = 3;
inline bool WebMessageInfo::_internal_has_messagetimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool WebMessageInfo::has_messagetimestamp() const {
  return _internal_has_messagetimestamp();
}
inline void WebMessageInfo::clear_messagetimestamp() {
  _impl_.messagetimestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint64_t WebMessageInfo::_internal_messagetimestamp() const {
  return _impl_.messagetimestamp_;
}
inline uint64_t WebMessageInfo::messagetimestamp() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.messageTimestamp)
  return _internal_messagetimestamp();
}
inline void WebMessageInfo::_internal_set_messagetimestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.messagetimestamp_ = value;
}
inline void WebMessageInfo::set_messagetimestamp(uint64_t value) {
  _internal_set_messagetimestamp(value);
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.messageTimestamp)
}

// optional .proto.WebMessageInfo.WebMessageInfoStatus status = 4;
inline bool WebMessageInfo::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool WebMessageInfo::has_status() const {
  return _internal_has_status();
}
inline void WebMessageInfo::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::proto::WebMessageInfo_WebMessageInfoStatus WebMessageInfo::_internal_status() const {
  return static_cast< ::proto::WebMessageInfo_WebMessageInfoStatus >(_impl_.status_);
}
inline ::proto::WebMessageInfo_WebMessageInfoStatus WebMessageInfo::status() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.status)
  return _internal_status();
}
inline void WebMessageInfo::_internal_set_status(::proto::WebMessageInfo_WebMessageInfoStatus value) {
  assert(::proto::WebMessageInfo_WebMessageInfoStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.status_ = value;
}
inline void WebMessageInfo::set_status(::proto::WebMessageInfo_WebMessageInfoStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.status)
}

// optional string participant = 5;
inline bool WebMessageInfo::_internal_has_participant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WebMessageInfo::has_participant() const {
  return _internal_has_participant();
}
inline void WebMessageInfo::clear_participant() {
  _impl_.participant_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WebMessageInfo::participant() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.participant)
  return _internal_participant();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebMessageInfo::set_participant(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.participant)
}
inline std::string* WebMessageInfo::mutable_participant() {
  std::string* _s = _internal_mutable_participant();
  // @@protoc_insertion_point(field_mutable:proto.WebMessageInfo.participant)
  return _s;
}
inline const std::string& WebMessageInfo::_internal_participant() const {
  return _impl_.participant_.Get();
}
inline void WebMessageInfo::_internal_set_participant(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_.Set(value, GetArenaForAllocation());
}
inline std::string* WebMessageInfo::_internal_mutable_participant() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_.Mutable(GetArenaForAllocation());
}
inline std::string* WebMessageInfo::release_participant() {
  // @@protoc_insertion_point(field_release:proto.WebMessageInfo.participant)
  if (!_internal_has_participant()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_.IsDefault()) {
    _impl_.participant_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void WebMessageInfo::set_allocated_participant(std::string* participant) {
  if (participant != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_.SetAllocated(participant, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_.IsDefault()) {
    _impl_.participant_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.WebMessageInfo.participant)
}

// optional bool ignore = 16;
inline bool WebMessageInfo::_internal_has_ignore() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool WebMessageInfo::has_ignore() const {
  return _internal_has_ignore();
}
inline void WebMessageInfo::clear_ignore() {
  _impl_.ignore_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool WebMessageInfo::_internal_ignore() const {
  return _impl_.ignore_;
}
inline bool WebMessageInfo::ignore() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.ignore)
  return _internal_ignore();
}
inline void WebMessageInfo::_internal_set_ignore(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.ignore_ = value;
}
inline void WebMessageInfo::set_ignore(bool value) {
  _internal_set_ignore(value);
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.ignore)
}

// optional bool starred = 17;
inline bool WebMessageInfo::_internal_has_starred() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool WebMessageInfo::has_starred() const {
  return _internal_has_starred();
}
inline void WebMessageInfo::clear_starred() {
  _impl_.starred_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool WebMessageInfo::_internal_starred() const {
  return _impl_.starred_;
}
inline bool WebMessageInfo::starred() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.starred)
  return _internal_starred();
}
inline void WebMessageInfo::_internal_set_starred(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.starred_ = value;
}
inline void WebMessageInfo::set_starred(bool value) {
  _internal_set_starred(value);
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.starred)
}

// optional bool broadcast = 18;
inline bool WebMessageInfo::_internal_has_broadcast() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool WebMessageInfo::has_broadcast() const {
  return _internal_has_broadcast();
}
inline void WebMessageInfo::clear_broadcast() {
  _impl_.broadcast_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool WebMessageInfo::_internal_broadcast() const {
  return _impl_.broadcast_;
}
inline bool WebMessageInfo::broadcast() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.broadcast)
  return _internal_broadcast();
}
inline void WebMessageInfo::_internal_set_broadcast(bool value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.broadcast_ = value;
}
inline void WebMessageInfo::set_broadcast(bool value) {
  _internal_set_broadcast(value);
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.broadcast)
}

// optional string pushName = 19;
inline bool WebMessageInfo::_internal_has_pushname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WebMessageInfo::has_pushname() const {
  return _internal_has_pushname();
}
inline void WebMessageInfo::clear_pushname() {
  _impl_.pushname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& WebMessageInfo::pushname() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.pushName)
  return _internal_pushname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebMessageInfo::set_pushname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.pushname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.pushName)
}
inline std::string* WebMessageInfo::mutable_pushname() {
  std::string* _s = _internal_mutable_pushname();
  // @@protoc_insertion_point(field_mutable:proto.WebMessageInfo.pushName)
  return _s;
}
inline const std::string& WebMessageInfo::_internal_pushname() const {
  return _impl_.pushname_.Get();
}
inline void WebMessageInfo::_internal_set_pushname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pushname_.Set(value, GetArenaForAllocation());
}
inline std::string* WebMessageInfo::_internal_mutable_pushname() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.pushname_.Mutable(GetArenaForAllocation());
}
inline std::string* WebMessageInfo::release_pushname() {
  // @@protoc_insertion_point(field_release:proto.WebMessageInfo.pushName)
  if (!_internal_has_pushname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.pushname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pushname_.IsDefault()) {
    _impl_.pushname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void WebMessageInfo::set_allocated_pushname(std::string* pushname) {
  if (pushname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pushname_.SetAllocated(pushname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pushname_.IsDefault()) {
    _impl_.pushname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.WebMessageInfo.pushName)
}

// optional bytes mediaCiphertextSha256 = 20;
inline bool WebMessageInfo::_internal_has_mediaciphertextsha256() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WebMessageInfo::has_mediaciphertextsha256() const {
  return _internal_has_mediaciphertextsha256();
}
inline void WebMessageInfo::clear_mediaciphertextsha256() {
  _impl_.mediaciphertextsha256_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& WebMessageInfo::mediaciphertextsha256() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.mediaCiphertextSha256)
  return _internal_mediaciphertextsha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebMessageInfo::set_mediaciphertextsha256(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.mediaciphertextsha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.mediaCiphertextSha256)
}
inline std::string* WebMessageInfo::mutable_mediaciphertextsha256() {
  std::string* _s = _internal_mutable_mediaciphertextsha256();
  // @@protoc_insertion_point(field_mutable:proto.WebMessageInfo.mediaCiphertextSha256)
  return _s;
}
inline const std::string& WebMessageInfo::_internal_mediaciphertextsha256() const {
  return _impl_.mediaciphertextsha256_.Get();
}
inline void WebMessageInfo::_internal_set_mediaciphertextsha256(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.mediaciphertextsha256_.Set(value, GetArenaForAllocation());
}
inline std::string* WebMessageInfo::_internal_mutable_mediaciphertextsha256() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.mediaciphertextsha256_.Mutable(GetArenaForAllocation());
}
inline std::string* WebMessageInfo::release_mediaciphertextsha256() {
  // @@protoc_insertion_point(field_release:proto.WebMessageInfo.mediaCiphertextSha256)
  if (!_internal_has_mediaciphertextsha256()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.mediaciphertextsha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mediaciphertextsha256_.IsDefault()) {
    _impl_.mediaciphertextsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void WebMessageInfo::set_allocated_mediaciphertextsha256(std::string* mediaciphertextsha256) {
  if (mediaciphertextsha256 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.mediaciphertextsha256_.SetAllocated(mediaciphertextsha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mediaciphertextsha256_.IsDefault()) {
    _impl_.mediaciphertextsha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.WebMessageInfo.mediaCiphertextSha256)
}

// optional bool multicast = 21;
inline bool WebMessageInfo::_internal_has_multicast() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool WebMessageInfo::has_multicast() const {
  return _internal_has_multicast();
}
inline void WebMessageInfo::clear_multicast() {
  _impl_.multicast_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool WebMessageInfo::_internal_multicast() const {
  return _impl_.multicast_;
}
inline bool WebMessageInfo::multicast() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.multicast)
  return _internal_multicast();
}
inline void WebMessageInfo::_internal_set_multicast(bool value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.multicast_ = value;
}
inline void WebMessageInfo::set_multicast(bool value) {
  _internal_set_multicast(value);
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.multicast)
}

// optional bool urlText = 22;
inline bool WebMessageInfo::_internal_has_urltext() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool WebMessageInfo::has_urltext() const {
  return _internal_has_urltext();
}
inline void WebMessageInfo::clear_urltext() {
  _impl_.urltext_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool WebMessageInfo::_internal_urltext() const {
  return _impl_.urltext_;
}
inline bool WebMessageInfo::urltext() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.urlText)
  return _internal_urltext();
}
inline void WebMessageInfo::_internal_set_urltext(bool value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.urltext_ = value;
}
inline void WebMessageInfo::set_urltext(bool value) {
  _internal_set_urltext(value);
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.urlText)
}

// optional bool urlNumber = 23;
inline bool WebMessageInfo::_internal_has_urlnumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool WebMessageInfo::has_urlnumber() const {
  return _internal_has_urlnumber();
}
inline void WebMessageInfo::clear_urlnumber() {
  _impl_.urlnumber_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool WebMessageInfo::_internal_urlnumber() const {
  return _impl_.urlnumber_;
}
inline bool WebMessageInfo::urlnumber() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.urlNumber)
  return _internal_urlnumber();
}
inline void WebMessageInfo::_internal_set_urlnumber(bool value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.urlnumber_ = value;
}
inline void WebMessageInfo::set_urlnumber(bool value) {
  _internal_set_urlnumber(value);
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.urlNumber)
}

// optional .proto.WebMessageInfo.WebMessageInfoStubType messageStubType = 24;
inline bool WebMessageInfo::_internal_has_messagestubtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool WebMessageInfo::has_messagestubtype() const {
  return _internal_has_messagestubtype();
}
inline void WebMessageInfo::clear_messagestubtype() {
  _impl_.messagestubtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::proto::WebMessageInfo_WebMessageInfoStubType WebMessageInfo::_internal_messagestubtype() const {
  return static_cast< ::proto::WebMessageInfo_WebMessageInfoStubType >(_impl_.messagestubtype_);
}
inline ::proto::WebMessageInfo_WebMessageInfoStubType WebMessageInfo::messagestubtype() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.messageStubType)
  return _internal_messagestubtype();
}
inline void WebMessageInfo::_internal_set_messagestubtype(::proto::WebMessageInfo_WebMessageInfoStubType value) {
  assert(::proto::WebMessageInfo_WebMessageInfoStubType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.messagestubtype_ = value;
}
inline void WebMessageInfo::set_messagestubtype(::proto::WebMessageInfo_WebMessageInfoStubType value) {
  _internal_set_messagestubtype(value);
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.messageStubType)
}

// optional bool clearMedia = 25;
inline bool WebMessageInfo::_internal_has_clearmedia() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool WebMessageInfo::has_clearmedia() const {
  return _internal_has_clearmedia();
}
inline void WebMessageInfo::clear_clearmedia() {
  _impl_.clearmedia_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool WebMessageInfo::_internal_clearmedia() const {
  return _impl_.clearmedia_;
}
inline bool WebMessageInfo::clearmedia() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.clearMedia)
  return _internal_clearmedia();
}
inline void WebMessageInfo::_internal_set_clearmedia(bool value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.clearmedia_ = value;
}
inline void WebMessageInfo::set_clearmedia(bool value) {
  _internal_set_clearmedia(value);
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.clearMedia)
}

// repeated string messageStubParameters = 26;
inline int WebMessageInfo::_internal_messagestubparameters_size() const {
  return _impl_.messagestubparameters_.size();
}
inline int WebMessageInfo::messagestubparameters_size() const {
  return _internal_messagestubparameters_size();
}
inline void WebMessageInfo::clear_messagestubparameters() {
  _impl_.messagestubparameters_.Clear();
}
inline std::string* WebMessageInfo::add_messagestubparameters() {
  std::string* _s = _internal_add_messagestubparameters();
  // @@protoc_insertion_point(field_add_mutable:proto.WebMessageInfo.messageStubParameters)
  return _s;
}
inline const std::string& WebMessageInfo::_internal_messagestubparameters(int index) const {
  return _impl_.messagestubparameters_.Get(index);
}
inline const std::string& WebMessageInfo::messagestubparameters(int index) const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.messageStubParameters)
  return _internal_messagestubparameters(index);
}
inline std::string* WebMessageInfo::mutable_messagestubparameters(int index) {
  // @@protoc_insertion_point(field_mutable:proto.WebMessageInfo.messageStubParameters)
  return _impl_.messagestubparameters_.Mutable(index);
}
inline void WebMessageInfo::set_messagestubparameters(int index, const std::string& value) {
  _impl_.messagestubparameters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.messageStubParameters)
}
inline void WebMessageInfo::set_messagestubparameters(int index, std::string&& value) {
  _impl_.messagestubparameters_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.messageStubParameters)
}
inline void WebMessageInfo::set_messagestubparameters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.messagestubparameters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.WebMessageInfo.messageStubParameters)
}
inline void WebMessageInfo::set_messagestubparameters(int index, const char* value, size_t size) {
  _impl_.messagestubparameters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.WebMessageInfo.messageStubParameters)
}
inline std::string* WebMessageInfo::_internal_add_messagestubparameters() {
  return _impl_.messagestubparameters_.Add();
}
inline void WebMessageInfo::add_messagestubparameters(const std::string& value) {
  _impl_.messagestubparameters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.WebMessageInfo.messageStubParameters)
}
inline void WebMessageInfo::add_messagestubparameters(std::string&& value) {
  _impl_.messagestubparameters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.WebMessageInfo.messageStubParameters)
}
inline void WebMessageInfo::add_messagestubparameters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.messagestubparameters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.WebMessageInfo.messageStubParameters)
}
inline void WebMessageInfo::add_messagestubparameters(const char* value, size_t size) {
  _impl_.messagestubparameters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.WebMessageInfo.messageStubParameters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WebMessageInfo::messagestubparameters() const {
  // @@protoc_insertion_point(field_list:proto.WebMessageInfo.messageStubParameters)
  return _impl_.messagestubparameters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WebMessageInfo::mutable_messagestubparameters() {
  // @@protoc_insertion_point(field_mutable_list:proto.WebMessageInfo.messageStubParameters)
  return &_impl_.messagestubparameters_;
}

// optional uint32 duration = 27;
inline bool WebMessageInfo::_internal_has_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool WebMessageInfo::has_duration() const {
  return _internal_has_duration();
}
inline void WebMessageInfo::clear_duration() {
  _impl_.duration_ = 0u;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline uint32_t WebMessageInfo::_internal_duration() const {
  return _impl_.duration_;
}
inline uint32_t WebMessageInfo::duration() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.duration)
  return _internal_duration();
}
inline void WebMessageInfo::_internal_set_duration(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.duration_ = value;
}
inline void WebMessageInfo::set_duration(uint32_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.duration)
}

// repeated string labels = 28;
inline int WebMessageInfo::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int WebMessageInfo::labels_size() const {
  return _internal_labels_size();
}
inline void WebMessageInfo::clear_labels() {
  _impl_.labels_.Clear();
}
inline std::string* WebMessageInfo::add_labels() {
  std::string* _s = _internal_add_labels();
  // @@protoc_insertion_point(field_add_mutable:proto.WebMessageInfo.labels)
  return _s;
}
inline const std::string& WebMessageInfo::_internal_labels(int index) const {
  return _impl_.labels_.Get(index);
}
inline const std::string& WebMessageInfo::labels(int index) const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.labels)
  return _internal_labels(index);
}
inline std::string* WebMessageInfo::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:proto.WebMessageInfo.labels)
  return _impl_.labels_.Mutable(index);
}
inline void WebMessageInfo::set_labels(int index, const std::string& value) {
  _impl_.labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.labels)
}
inline void WebMessageInfo::set_labels(int index, std::string&& value) {
  _impl_.labels_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.labels)
}
inline void WebMessageInfo::set_labels(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.WebMessageInfo.labels)
}
inline void WebMessageInfo::set_labels(int index, const char* value, size_t size) {
  _impl_.labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.WebMessageInfo.labels)
}
inline std::string* WebMessageInfo::_internal_add_labels() {
  return _impl_.labels_.Add();
}
inline void WebMessageInfo::add_labels(const std::string& value) {
  _impl_.labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.WebMessageInfo.labels)
}
inline void WebMessageInfo::add_labels(std::string&& value) {
  _impl_.labels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.WebMessageInfo.labels)
}
inline void WebMessageInfo::add_labels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.WebMessageInfo.labels)
}
inline void WebMessageInfo::add_labels(const char* value, size_t size) {
  _impl_.labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.WebMessageInfo.labels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WebMessageInfo::labels() const {
  // @@protoc_insertion_point(field_list:proto.WebMessageInfo.labels)
  return _impl_.labels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WebMessageInfo::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:proto.WebMessageInfo.labels)
  return &_impl_.labels_;
}

// optional .proto.PaymentInfo paymentInfo = 29;
inline bool WebMessageInfo::_internal_has_paymentinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paymentinfo_ != nullptr);
  return value;
}
inline bool WebMessageInfo::has_paymentinfo() const {
  return _internal_has_paymentinfo();
}
inline void WebMessageInfo::clear_paymentinfo() {
  if (_impl_.paymentinfo_ != nullptr) _impl_.paymentinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::proto::PaymentInfo& WebMessageInfo::_internal_paymentinfo() const {
  const ::proto::PaymentInfo* p = _impl_.paymentinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::PaymentInfo&>(
      ::proto::_PaymentInfo_default_instance_);
}
inline const ::proto::PaymentInfo& WebMessageInfo::paymentinfo() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.paymentInfo)
  return _internal_paymentinfo();
}
inline void WebMessageInfo::unsafe_arena_set_allocated_paymentinfo(
    ::proto::PaymentInfo* paymentinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paymentinfo_);
  }
  _impl_.paymentinfo_ = paymentinfo;
  if (paymentinfo) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.WebMessageInfo.paymentInfo)
}
inline ::proto::PaymentInfo* WebMessageInfo::release_paymentinfo() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::proto::PaymentInfo* temp = _impl_.paymentinfo_;
  _impl_.paymentinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::PaymentInfo* WebMessageInfo::unsafe_arena_release_paymentinfo() {
  // @@protoc_insertion_point(field_release:proto.WebMessageInfo.paymentInfo)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::proto::PaymentInfo* temp = _impl_.paymentinfo_;
  _impl_.paymentinfo_ = nullptr;
  return temp;
}
inline ::proto::PaymentInfo* WebMessageInfo::_internal_mutable_paymentinfo() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.paymentinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::PaymentInfo>(GetArenaForAllocation());
    _impl_.paymentinfo_ = p;
  }
  return _impl_.paymentinfo_;
}
inline ::proto::PaymentInfo* WebMessageInfo::mutable_paymentinfo() {
  ::proto::PaymentInfo* _msg = _internal_mutable_paymentinfo();
  // @@protoc_insertion_point(field_mutable:proto.WebMessageInfo.paymentInfo)
  return _msg;
}
inline void WebMessageInfo::set_allocated_paymentinfo(::proto::PaymentInfo* paymentinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paymentinfo_;
  }
  if (paymentinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paymentinfo);
    if (message_arena != submessage_arena) {
      paymentinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paymentinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.paymentinfo_ = paymentinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.WebMessageInfo.paymentInfo)
}

// optional .proto.LiveLocationMessage finalLiveLocation = 30;
inline bool WebMessageInfo::_internal_has_finallivelocation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.finallivelocation_ != nullptr);
  return value;
}
inline bool WebMessageInfo::has_finallivelocation() const {
  return _internal_has_finallivelocation();
}
inline void WebMessageInfo::clear_finallivelocation() {
  if (_impl_.finallivelocation_ != nullptr) _impl_.finallivelocation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::proto::LiveLocationMessage& WebMessageInfo::_internal_finallivelocation() const {
  const ::proto::LiveLocationMessage* p = _impl_.finallivelocation_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::LiveLocationMessage&>(
      ::proto::_LiveLocationMessage_default_instance_);
}
inline const ::proto::LiveLocationMessage& WebMessageInfo::finallivelocation() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.finalLiveLocation)
  return _internal_finallivelocation();
}
inline void WebMessageInfo::unsafe_arena_set_allocated_finallivelocation(
    ::proto::LiveLocationMessage* finallivelocation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.finallivelocation_);
  }
  _impl_.finallivelocation_ = finallivelocation;
  if (finallivelocation) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.WebMessageInfo.finalLiveLocation)
}
inline ::proto::LiveLocationMessage* WebMessageInfo::release_finallivelocation() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::proto::LiveLocationMessage* temp = _impl_.finallivelocation_;
  _impl_.finallivelocation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::LiveLocationMessage* WebMessageInfo::unsafe_arena_release_finallivelocation() {
  // @@protoc_insertion_point(field_release:proto.WebMessageInfo.finalLiveLocation)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::proto::LiveLocationMessage* temp = _impl_.finallivelocation_;
  _impl_.finallivelocation_ = nullptr;
  return temp;
}
inline ::proto::LiveLocationMessage* WebMessageInfo::_internal_mutable_finallivelocation() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.finallivelocation_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::LiveLocationMessage>(GetArenaForAllocation());
    _impl_.finallivelocation_ = p;
  }
  return _impl_.finallivelocation_;
}
inline ::proto::LiveLocationMessage* WebMessageInfo::mutable_finallivelocation() {
  ::proto::LiveLocationMessage* _msg = _internal_mutable_finallivelocation();
  // @@protoc_insertion_point(field_mutable:proto.WebMessageInfo.finalLiveLocation)
  return _msg;
}
inline void WebMessageInfo::set_allocated_finallivelocation(::proto::LiveLocationMessage* finallivelocation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.finallivelocation_;
  }
  if (finallivelocation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(finallivelocation);
    if (message_arena != submessage_arena) {
      finallivelocation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, finallivelocation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.finallivelocation_ = finallivelocation;
  // @@protoc_insertion_point(field_set_allocated:proto.WebMessageInfo.finalLiveLocation)
}

// optional .proto.PaymentInfo quotedPaymentInfo = 31;
inline bool WebMessageInfo::_internal_has_quotedpaymentinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.quotedpaymentinfo_ != nullptr);
  return value;
}
inline bool WebMessageInfo::has_quotedpaymentinfo() const {
  return _internal_has_quotedpaymentinfo();
}
inline void WebMessageInfo::clear_quotedpaymentinfo() {
  if (_impl_.quotedpaymentinfo_ != nullptr) _impl_.quotedpaymentinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::proto::PaymentInfo& WebMessageInfo::_internal_quotedpaymentinfo() const {
  const ::proto::PaymentInfo* p = _impl_.quotedpaymentinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::PaymentInfo&>(
      ::proto::_PaymentInfo_default_instance_);
}
inline const ::proto::PaymentInfo& WebMessageInfo::quotedpaymentinfo() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.quotedPaymentInfo)
  return _internal_quotedpaymentinfo();
}
inline void WebMessageInfo::unsafe_arena_set_allocated_quotedpaymentinfo(
    ::proto::PaymentInfo* quotedpaymentinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.quotedpaymentinfo_);
  }
  _impl_.quotedpaymentinfo_ = quotedpaymentinfo;
  if (quotedpaymentinfo) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.WebMessageInfo.quotedPaymentInfo)
}
inline ::proto::PaymentInfo* WebMessageInfo::release_quotedpaymentinfo() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::proto::PaymentInfo* temp = _impl_.quotedpaymentinfo_;
  _impl_.quotedpaymentinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::PaymentInfo* WebMessageInfo::unsafe_arena_release_quotedpaymentinfo() {
  // @@protoc_insertion_point(field_release:proto.WebMessageInfo.quotedPaymentInfo)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::proto::PaymentInfo* temp = _impl_.quotedpaymentinfo_;
  _impl_.quotedpaymentinfo_ = nullptr;
  return temp;
}
inline ::proto::PaymentInfo* WebMessageInfo::_internal_mutable_quotedpaymentinfo() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.quotedpaymentinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::PaymentInfo>(GetArenaForAllocation());
    _impl_.quotedpaymentinfo_ = p;
  }
  return _impl_.quotedpaymentinfo_;
}
inline ::proto::PaymentInfo* WebMessageInfo::mutable_quotedpaymentinfo() {
  ::proto::PaymentInfo* _msg = _internal_mutable_quotedpaymentinfo();
  // @@protoc_insertion_point(field_mutable:proto.WebMessageInfo.quotedPaymentInfo)
  return _msg;
}
inline void WebMessageInfo::set_allocated_quotedpaymentinfo(::proto::PaymentInfo* quotedpaymentinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.quotedpaymentinfo_;
  }
  if (quotedpaymentinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(quotedpaymentinfo);
    if (message_arena != submessage_arena) {
      quotedpaymentinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quotedpaymentinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.quotedpaymentinfo_ = quotedpaymentinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.WebMessageInfo.quotedPaymentInfo)
}

// optional uint64 ephemeralStartTimestamp = 32;
inline bool WebMessageInfo::_internal_has_ephemeralstarttimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool WebMessageInfo::has_ephemeralstarttimestamp() const {
  return _internal_has_ephemeralstarttimestamp();
}
inline void WebMessageInfo::clear_ephemeralstarttimestamp() {
  _impl_.ephemeralstarttimestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline uint64_t WebMessageInfo::_internal_ephemeralstarttimestamp() const {
  return _impl_.ephemeralstarttimestamp_;
}
inline uint64_t WebMessageInfo::ephemeralstarttimestamp() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.ephemeralStartTimestamp)
  return _internal_ephemeralstarttimestamp();
}
inline void WebMessageInfo::_internal_set_ephemeralstarttimestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.ephemeralstarttimestamp_ = value;
}
inline void WebMessageInfo::set_ephemeralstarttimestamp(uint64_t value) {
  _internal_set_ephemeralstarttimestamp(value);
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.ephemeralStartTimestamp)
}

// optional uint32 ephemeralDuration = 33;
inline bool WebMessageInfo::_internal_has_ephemeralduration() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool WebMessageInfo::has_ephemeralduration() const {
  return _internal_has_ephemeralduration();
}
inline void WebMessageInfo::clear_ephemeralduration() {
  _impl_.ephemeralduration_ = 0u;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline uint32_t WebMessageInfo::_internal_ephemeralduration() const {
  return _impl_.ephemeralduration_;
}
inline uint32_t WebMessageInfo::ephemeralduration() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.ephemeralDuration)
  return _internal_ephemeralduration();
}
inline void WebMessageInfo::_internal_set_ephemeralduration(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.ephemeralduration_ = value;
}
inline void WebMessageInfo::set_ephemeralduration(uint32_t value) {
  _internal_set_ephemeralduration(value);
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.ephemeralDuration)
}

// optional bool ephemeralOffToOn = 34;
inline bool WebMessageInfo::_internal_has_ephemeralofftoon() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool WebMessageInfo::has_ephemeralofftoon() const {
  return _internal_has_ephemeralofftoon();
}
inline void WebMessageInfo::clear_ephemeralofftoon() {
  _impl_.ephemeralofftoon_ = false;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline bool WebMessageInfo::_internal_ephemeralofftoon() const {
  return _impl_.ephemeralofftoon_;
}
inline bool WebMessageInfo::ephemeralofftoon() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.ephemeralOffToOn)
  return _internal_ephemeralofftoon();
}
inline void WebMessageInfo::_internal_set_ephemeralofftoon(bool value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.ephemeralofftoon_ = value;
}
inline void WebMessageInfo::set_ephemeralofftoon(bool value) {
  _internal_set_ephemeralofftoon(value);
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.ephemeralOffToOn)
}

// optional bool ephemeralOutOfSync = 35;
inline bool WebMessageInfo::_internal_has_ephemeraloutofsync() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool WebMessageInfo::has_ephemeraloutofsync() const {
  return _internal_has_ephemeraloutofsync();
}
inline void WebMessageInfo::clear_ephemeraloutofsync() {
  _impl_.ephemeraloutofsync_ = false;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline bool WebMessageInfo::_internal_ephemeraloutofsync() const {
  return _impl_.ephemeraloutofsync_;
}
inline bool WebMessageInfo::ephemeraloutofsync() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.ephemeralOutOfSync)
  return _internal_ephemeraloutofsync();
}
inline void WebMessageInfo::_internal_set_ephemeraloutofsync(bool value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.ephemeraloutofsync_ = value;
}
inline void WebMessageInfo::set_ephemeraloutofsync(bool value) {
  _internal_set_ephemeraloutofsync(value);
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.ephemeralOutOfSync)
}

// optional .proto.WebMessageInfo.WebMessageInfoBizPrivacyStatus bizPrivacyStatus = 36;
inline bool WebMessageInfo::_internal_has_bizprivacystatus() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool WebMessageInfo::has_bizprivacystatus() const {
  return _internal_has_bizprivacystatus();
}
inline void WebMessageInfo::clear_bizprivacystatus() {
  _impl_.bizprivacystatus_ = 0;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline ::proto::WebMessageInfo_WebMessageInfoBizPrivacyStatus WebMessageInfo::_internal_bizprivacystatus() const {
  return static_cast< ::proto::WebMessageInfo_WebMessageInfoBizPrivacyStatus >(_impl_.bizprivacystatus_);
}
inline ::proto::WebMessageInfo_WebMessageInfoBizPrivacyStatus WebMessageInfo::bizprivacystatus() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.bizPrivacyStatus)
  return _internal_bizprivacystatus();
}
inline void WebMessageInfo::_internal_set_bizprivacystatus(::proto::WebMessageInfo_WebMessageInfoBizPrivacyStatus value) {
  assert(::proto::WebMessageInfo_WebMessageInfoBizPrivacyStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.bizprivacystatus_ = value;
}
inline void WebMessageInfo::set_bizprivacystatus(::proto::WebMessageInfo_WebMessageInfoBizPrivacyStatus value) {
  _internal_set_bizprivacystatus(value);
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.bizPrivacyStatus)
}

// optional string verifiedBizName = 37;
inline bool WebMessageInfo::_internal_has_verifiedbizname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool WebMessageInfo::has_verifiedbizname() const {
  return _internal_has_verifiedbizname();
}
inline void WebMessageInfo::clear_verifiedbizname() {
  _impl_.verifiedbizname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& WebMessageInfo::verifiedbizname() const {
  // @@protoc_insertion_point(field_get:proto.WebMessageInfo.verifiedBizName)
  return _internal_verifiedbizname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebMessageInfo::set_verifiedbizname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.verifiedbizname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.WebMessageInfo.verifiedBizName)
}
inline std::string* WebMessageInfo::mutable_verifiedbizname() {
  std::string* _s = _internal_mutable_verifiedbizname();
  // @@protoc_insertion_point(field_mutable:proto.WebMessageInfo.verifiedBizName)
  return _s;
}
inline const std::string& WebMessageInfo::_internal_verifiedbizname() const {
  return _impl_.verifiedbizname_.Get();
}
inline void WebMessageInfo::_internal_set_verifiedbizname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.verifiedbizname_.Set(value, GetArenaForAllocation());
}
inline std::string* WebMessageInfo::_internal_mutable_verifiedbizname() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.verifiedbizname_.Mutable(GetArenaForAllocation());
}
inline std::string* WebMessageInfo::release_verifiedbizname() {
  // @@protoc_insertion_point(field_release:proto.WebMessageInfo.verifiedBizName)
  if (!_internal_has_verifiedbizname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.verifiedbizname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verifiedbizname_.IsDefault()) {
    _impl_.verifiedbizname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void WebMessageInfo::set_allocated_verifiedbizname(std::string* verifiedbizname) {
  if (verifiedbizname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.verifiedbizname_.SetAllocated(verifiedbizname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verifiedbizname_.IsDefault()) {
    _impl_.verifiedbizname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.WebMessageInfo.verifiedBizName)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::AdReplyInfo_AdReplyInfoMediaType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::AdReplyInfo_AdReplyInfoMediaType>() {
  return ::proto::AdReplyInfo_AdReplyInfoMediaType_descriptor();
}
template <> struct is_proto_enum< ::proto::ExternalAdReplyInfo_ExternalAdReplyInfoMediaType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::ExternalAdReplyInfo_ExternalAdReplyInfoMediaType>() {
  return ::proto::ExternalAdReplyInfo_ExternalAdReplyInfoMediaType_descriptor();
}
template <> struct is_proto_enum< ::proto::InvoiceMessage_InvoiceMessageAttachmentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::InvoiceMessage_InvoiceMessageAttachmentType>() {
  return ::proto::InvoiceMessage_InvoiceMessageAttachmentType_descriptor();
}
template <> struct is_proto_enum< ::proto::ExtendedTextMessage_ExtendedTextMessageFontType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::ExtendedTextMessage_ExtendedTextMessageFontType>() {
  return ::proto::ExtendedTextMessage_ExtendedTextMessageFontType_descriptor();
}
template <> struct is_proto_enum< ::proto::ExtendedTextMessage_ExtendedTextMessagePreviewType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::ExtendedTextMessage_ExtendedTextMessagePreviewType>() {
  return ::proto::ExtendedTextMessage_ExtendedTextMessagePreviewType_descriptor();
}
template <> struct is_proto_enum< ::proto::VideoMessage_VideoMessageAttribution> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::VideoMessage_VideoMessageAttribution>() {
  return ::proto::VideoMessage_VideoMessageAttribution_descriptor();
}
template <> struct is_proto_enum< ::proto::ProtocolMessage_ProtocolMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::ProtocolMessage_ProtocolMessageType>() {
  return ::proto::ProtocolMessage_ProtocolMessageType_descriptor();
}
template <> struct is_proto_enum< ::proto::HistorySyncNotification_HistorySyncNotificationHistorySyncType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::HistorySyncNotification_HistorySyncNotificationHistorySyncType>() {
  return ::proto::HistorySyncNotification_HistorySyncNotificationHistorySyncType_descriptor();
}
template <> struct is_proto_enum< ::proto::HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType>() {
  return ::proto::HSMDateTimeComponent_HSMDateTimeComponentDayOfWeekType_descriptor();
}
template <> struct is_proto_enum< ::proto::HSMDateTimeComponent_HSMDateTimeComponentCalendarType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::HSMDateTimeComponent_HSMDateTimeComponentCalendarType>() {
  return ::proto::HSMDateTimeComponent_HSMDateTimeComponentCalendarType_descriptor();
}
template <> struct is_proto_enum< ::proto::OrderMessage_OrderMessageOrderStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::OrderMessage_OrderMessageOrderStatus>() {
  return ::proto::OrderMessage_OrderMessageOrderStatus_descriptor();
}
template <> struct is_proto_enum< ::proto::OrderMessage_OrderMessageOrderSurface> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::OrderMessage_OrderMessageOrderSurface>() {
  return ::proto::OrderMessage_OrderMessageOrderSurface_descriptor();
}
template <> struct is_proto_enum< ::proto::ListMessage_ListMessageListType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::ListMessage_ListMessageListType>() {
  return ::proto::ListMessage_ListMessageListType_descriptor();
}
template <> struct is_proto_enum< ::proto::ListResponseMessage_ListResponseMessageListType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::ListResponseMessage_ListResponseMessageListType>() {
  return ::proto::ListResponseMessage_ListResponseMessageListType_descriptor();
}
template <> struct is_proto_enum< ::proto::Button_ButtonType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::Button_ButtonType>() {
  return ::proto::Button_ButtonType_descriptor();
}
template <> struct is_proto_enum< ::proto::ButtonsMessage_ButtonsMessageHeaderType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::ButtonsMessage_ButtonsMessageHeaderType>() {
  return ::proto::ButtonsMessage_ButtonsMessageHeaderType_descriptor();
}
template <> struct is_proto_enum< ::proto::ButtonsResponseMessage_ButtonsResponseMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::ButtonsResponseMessage_ButtonsResponseMessageType>() {
  return ::proto::ButtonsResponseMessage_ButtonsResponseMessageType_descriptor();
}
template <> struct is_proto_enum< ::proto::WebFeatures_WebFeaturesFlag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::WebFeatures_WebFeaturesFlag>() {
  return ::proto::WebFeatures_WebFeaturesFlag_descriptor();
}
template <> struct is_proto_enum< ::proto::PaymentInfo_PaymentInfoCurrency> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::PaymentInfo_PaymentInfoCurrency>() {
  return ::proto::PaymentInfo_PaymentInfoCurrency_descriptor();
}
template <> struct is_proto_enum< ::proto::PaymentInfo_PaymentInfoStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::PaymentInfo_PaymentInfoStatus>() {
  return ::proto::PaymentInfo_PaymentInfoStatus_descriptor();
}
template <> struct is_proto_enum< ::proto::PaymentInfo_PaymentInfoTxnStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::PaymentInfo_PaymentInfoTxnStatus>() {
  return ::proto::PaymentInfo_PaymentInfoTxnStatus_descriptor();
}
template <> struct is_proto_enum< ::proto::WebMessageInfo_WebMessageInfoStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::WebMessageInfo_WebMessageInfoStatus>() {
  return ::proto::WebMessageInfo_WebMessageInfoStatus_descriptor();
}
template <> struct is_proto_enum< ::proto::WebMessageInfo_WebMessageInfoStubType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::WebMessageInfo_WebMessageInfoStubType>() {
  return ::proto::WebMessageInfo_WebMessageInfoStubType_descriptor();
}
template <> struct is_proto_enum< ::proto::WebMessageInfo_WebMessageInfoBizPrivacyStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::WebMessageInfo_WebMessageInfoBizPrivacyStatus>() {
  return ::proto::WebMessageInfo_WebMessageInfoBizPrivacyStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pmsg_2eproto
